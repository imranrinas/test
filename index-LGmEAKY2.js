(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
    new MutationObserver(i => {
        for (const s of i)
            if (s.type === "childList")
                for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function n(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
    }

    function r(i) {
        if (i.ep) return;
        i.ep = !0;
        const s = n(i);
        fetch(i.href, s)
    }
})();

function Pp(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
var aT = {
        exports: {}
    },
    Ec = {},
    lT = {
        exports: {}
    },
    ee = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ua = Symbol.for("react.element"),
    kR = Symbol.for("react.portal"),
    xR = Symbol.for("react.fragment"),
    bR = Symbol.for("react.strict_mode"),
    NR = Symbol.for("react.profiler"),
    DR = Symbol.for("react.provider"),
    VR = Symbol.for("react.context"),
    OR = Symbol.for("react.forward_ref"),
    LR = Symbol.for("react.suspense"),
    MR = Symbol.for("react.memo"),
    FR = Symbol.for("react.lazy"),
    ev = Symbol.iterator;

function UR(t) {
    return t === null || typeof t != "object" ? null : (t = ev && t[ev] || t["@@iterator"], typeof t == "function" ? t : null)
}
var uT = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    },
    cT = Object.assign,
    hT = {};

function qs(t, e, n) {
    this.props = t, this.context = e, this.refs = hT, this.updater = n || uT
}
qs.prototype.isReactComponent = {};
qs.prototype.setState = function(t, e) {
    if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, e, "setState")
};
qs.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
};

function dT() {}
dT.prototype = qs.prototype;

function Rp(t, e, n) {
    this.props = t, this.context = e, this.refs = hT, this.updater = n || uT
}
var Cp = Rp.prototype = new dT;
Cp.constructor = Rp;
cT(Cp, qs.prototype);
Cp.isPureReactComponent = !0;
var tv = Array.isArray,
    fT = Object.prototype.hasOwnProperty,
    kp = {
        current: null
    },
    pT = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function mT(t, e, n) {
    var r, i = {},
        s = null,
        o = null;
    if (e != null)
        for (r in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) fT.call(e, r) && !pT.hasOwnProperty(r) && (i[r] = e[r]);
    var a = arguments.length - 2;
    if (a === 1) i.children = n;
    else if (1 < a) {
        for (var u = Array(a), c = 0; c < a; c++) u[c] = arguments[c + 2];
        i.children = u
    }
    if (t && t.defaultProps)
        for (r in a = t.defaultProps, a) i[r] === void 0 && (i[r] = a[r]);
    return {
        $$typeof: Ua,
        type: t,
        key: s,
        ref: o,
        props: i,
        _owner: kp.current
    }
}

function jR(t, e) {
    return {
        $$typeof: Ua,
        type: t.type,
        key: e,
        ref: t.ref,
        props: t.props,
        _owner: t._owner
    }
}

function xp(t) {
    return typeof t == "object" && t !== null && t.$$typeof === Ua
}

function BR(t) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(n) {
        return e[n]
    })
}
var nv = /\/+/g;

function Fh(t, e) {
    return typeof t == "object" && t !== null && t.key != null ? BR("" + t.key) : e.toString(36)
}

function Ql(t, e, n, r, i) {
    var s = typeof t;
    (s === "undefined" || s === "boolean") && (t = null);
    var o = !1;
    if (t === null) o = !0;
    else switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (t.$$typeof) {
                case Ua:
                case kR:
                    o = !0
            }
    }
    if (o) return o = t, i = i(o), t = r === "" ? "." + Fh(o, 0) : r, tv(i) ? (n = "", t != null && (n = t.replace(nv, "$&/") + "/"), Ql(i, e, n, "", function(c) {
        return c
    })) : i != null && (xp(i) && (i = jR(i, n + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(nv, "$&/") + "/") + t)), e.push(i)), 1;
    if (o = 0, r = r === "" ? "." : r + ":", tv(t))
        for (var a = 0; a < t.length; a++) {
            s = t[a];
            var u = r + Fh(s, a);
            o += Ql(s, e, n, u, i)
        } else if (u = UR(t), typeof u == "function")
            for (t = u.call(t), a = 0; !(s = t.next()).done;) s = s.value, u = r + Fh(s, a++), o += Ql(s, e, n, u, i);
        else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}

function Tl(t, e, n) {
    if (t == null) return t;
    var r = [],
        i = 0;
    return Ql(t, r, "", "", function(s) {
        return e.call(n, s, i++)
    }), r
}

function $R(t) {
    if (t._status === -1) {
        var e = t._result;
        e = e(), e.then(function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n)
        }, function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n)
        }), t._status === -1 && (t._status = 0, t._result = e)
    }
    if (t._status === 1) return t._result.default;
    throw t._result
}
var _t = {
        current: null
    },
    Yl = {
        transition: null
    },
    zR = {
        ReactCurrentDispatcher: _t,
        ReactCurrentBatchConfig: Yl,
        ReactCurrentOwner: kp
    };

function gT() {
    throw Error("act(...) is not supported in production builds of React.")
}
ee.Children = {
    map: Tl,
    forEach: function(t, e, n) {
        Tl(t, function() {
            e.apply(this, arguments)
        }, n)
    },
    count: function(t) {
        var e = 0;
        return Tl(t, function() {
            e++
        }), e
    },
    toArray: function(t) {
        return Tl(t, function(e) {
            return e
        }) || []
    },
    only: function(t) {
        if (!xp(t)) throw Error("React.Children.only expected to receive a single React element child.");
        return t
    }
};
ee.Component = qs;
ee.Fragment = xR;
ee.Profiler = NR;
ee.PureComponent = Rp;
ee.StrictMode = bR;
ee.Suspense = LR;
ee.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = zR;
ee.act = gT;
ee.cloneElement = function(t, e, n) {
    if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var r = cT({}, t.props),
        i = t.key,
        s = t.ref,
        o = t._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref, o = kp.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps) var a = t.type.defaultProps;
        for (u in e) fT.call(e, u) && !pT.hasOwnProperty(u) && (r[u] = e[u] === void 0 && a !== void 0 ? a[u] : e[u])
    }
    var u = arguments.length - 2;
    if (u === 1) r.children = n;
    else if (1 < u) {
        a = Array(u);
        for (var c = 0; c < u; c++) a[c] = arguments[c + 2];
        r.children = a
    }
    return {
        $$typeof: Ua,
        type: t.type,
        key: i,
        ref: s,
        props: r,
        _owner: o
    }
};
ee.createContext = function(t) {
    return t = {
        $$typeof: VR,
        _currentValue: t,
        _currentValue2: t,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    }, t.Provider = {
        $$typeof: DR,
        _context: t
    }, t.Consumer = t
};
ee.createElement = mT;
ee.createFactory = function(t) {
    var e = mT.bind(null, t);
    return e.type = t, e
};
ee.createRef = function() {
    return {
        current: null
    }
};
ee.forwardRef = function(t) {
    return {
        $$typeof: OR,
        render: t
    }
};
ee.isValidElement = xp;
ee.lazy = function(t) {
    return {
        $$typeof: FR,
        _payload: {
            _status: -1,
            _result: t
        },
        _init: $R
    }
};
ee.memo = function(t, e) {
    return {
        $$typeof: MR,
        type: t,
        compare: e === void 0 ? null : e
    }
};
ee.startTransition = function(t) {
    var e = Yl.transition;
    Yl.transition = {};
    try {
        t()
    } finally {
        Yl.transition = e
    }
};
ee.unstable_act = gT;
ee.useCallback = function(t, e) {
    return _t.current.useCallback(t, e)
};
ee.useContext = function(t) {
    return _t.current.useContext(t)
};
ee.useDebugValue = function() {};
ee.useDeferredValue = function(t) {
    return _t.current.useDeferredValue(t)
};
ee.useEffect = function(t, e) {
    return _t.current.useEffect(t, e)
};
ee.useId = function() {
    return _t.current.useId()
};
ee.useImperativeHandle = function(t, e, n) {
    return _t.current.useImperativeHandle(t, e, n)
};
ee.useInsertionEffect = function(t, e) {
    return _t.current.useInsertionEffect(t, e)
};
ee.useLayoutEffect = function(t, e) {
    return _t.current.useLayoutEffect(t, e)
};
ee.useMemo = function(t, e) {
    return _t.current.useMemo(t, e)
};
ee.useReducer = function(t, e, n) {
    return _t.current.useReducer(t, e, n)
};
ee.useRef = function(t) {
    return _t.current.useRef(t)
};
ee.useState = function(t) {
    return _t.current.useState(t)
};
ee.useSyncExternalStore = function(t, e, n) {
    return _t.current.useSyncExternalStore(t, e, n)
};
ee.useTransition = function() {
    return _t.current.useTransition()
};
ee.version = "18.3.1";
lT.exports = ee;
var M = lT.exports;
const It = Pp(M);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WR = M,
    qR = Symbol.for("react.element"),
    HR = Symbol.for("react.fragment"),
    KR = Object.prototype.hasOwnProperty,
    GR = WR.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    QR = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function yT(t, e, n) {
    var r, i = {},
        s = null,
        o = null;
    n !== void 0 && (s = "" + n), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref);
    for (r in e) KR.call(e, r) && !QR.hasOwnProperty(r) && (i[r] = e[r]);
    if (t && t.defaultProps)
        for (r in e = t.defaultProps, e) i[r] === void 0 && (i[r] = e[r]);
    return {
        $$typeof: qR,
        type: t,
        key: s,
        ref: o,
        props: i,
        _owner: GR.current
    }
}
Ec.Fragment = HR;
Ec.jsx = yT;
Ec.jsxs = yT;
aT.exports = Ec;
var D = aT.exports,
    vT = {
        exports: {}
    },
    $t = {},
    _T = {
        exports: {}
    },
    wT = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
    function e(B, K) {
        var Q = B.length;
        B.push(K);
        e: for (; 0 < Q;) {
            var pe = Q - 1 >>> 1,
                ue = B[pe];
            if (0 < i(ue, K)) B[pe] = K, B[Q] = ue, Q = pe;
            else break e
        }
    }

    function n(B) {
        return B.length === 0 ? null : B[0]
    }

    function r(B) {
        if (B.length === 0) return null;
        var K = B[0],
            Q = B.pop();
        if (Q !== K) {
            B[0] = Q;
            e: for (var pe = 0, ue = B.length, _e = ue >>> 1; pe < _e;) {
                var Tt = 2 * (pe + 1) - 1,
                    Je = B[Tt],
                    Oe = Tt + 1,
                    Wt = B[Oe];
                if (0 > i(Je, Q)) Oe < ue && 0 > i(Wt, Je) ? (B[pe] = Wt, B[Oe] = Q, pe = Oe) : (B[pe] = Je, B[Tt] = Q, pe = Tt);
                else if (Oe < ue && 0 > i(Wt, Q)) B[pe] = Wt, B[Oe] = Q, pe = Oe;
                else break e
            }
        }
        return K
    }

    function i(B, K) {
        var Q = B.sortIndex - K.sortIndex;
        return Q !== 0 ? Q : B.id - K.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        t.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date,
            a = o.now();
        t.unstable_now = function() {
            return o.now() - a
        }
    }
    var u = [],
        c = [],
        h = 1,
        f = null,
        m = 3,
        _ = !1,
        I = !1,
        R = !1,
        k = typeof setTimeout == "function" ? setTimeout : null,
        w = typeof clearTimeout == "function" ? clearTimeout : null,
        v = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function T(B) {
        for (var K = n(c); K !== null;) {
            if (K.callback === null) r(c);
            else if (K.startTime <= B) r(c), K.sortIndex = K.expirationTime, e(u, K);
            else break;
            K = n(c)
        }
    }

    function x(B) {
        if (R = !1, T(B), !I)
            if (n(u) !== null) I = !0, sr(O);
            else {
                var K = n(c);
                K !== null && le(x, K.startTime - B)
            }
    }

    function O(B, K) {
        I = !1, R && (R = !1, w(g), g = -1), _ = !0;
        var Q = m;
        try {
            for (T(K), f = n(u); f !== null && (!(f.expirationTime > K) || B && !C());) {
                var pe = f.callback;
                if (typeof pe == "function") {
                    f.callback = null, m = f.priorityLevel;
                    var ue = pe(f.expirationTime <= K);
                    K = t.unstable_now(), typeof ue == "function" ? f.callback = ue : f === n(u) && r(u), T(K)
                } else r(u);
                f = n(u)
            }
            if (f !== null) var _e = !0;
            else {
                var Tt = n(c);
                Tt !== null && le(x, Tt.startTime - K), _e = !1
            }
            return _e
        } finally {
            f = null, m = Q, _ = !1
        }
    }
    var U = !1,
        S = null,
        g = -1,
        E = 5,
        A = -1;

    function C() {
        return !(t.unstable_now() - A < E)
    }

    function b() {
        if (S !== null) {
            var B = t.unstable_now();
            A = B;
            var K = !0;
            try {
                K = S(!0, B)
            } finally {
                K ? P() : (U = !1, S = null)
            }
        } else U = !1
    }
    var P;
    if (typeof v == "function") P = function() {
        v(b)
    };
    else if (typeof MessageChannel < "u") {
        var ze = new MessageChannel,
            dn = ze.port2;
        ze.port1.onmessage = b, P = function() {
            dn.postMessage(null)
        }
    } else P = function() {
        k(b, 0)
    };

    function sr(B) {
        S = B, U || (U = !0, P())
    }

    function le(B, K) {
        g = k(function() {
            B(t.unstable_now())
        }, K)
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(B) {
        B.callback = null
    }, t.unstable_continueExecution = function() {
        I || _ || (I = !0, sr(O))
    }, t.unstable_forceFrameRate = function(B) {
        0 > B || 125 < B ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : E = 0 < B ? Math.floor(1e3 / B) : 5
    }, t.unstable_getCurrentPriorityLevel = function() {
        return m
    }, t.unstable_getFirstCallbackNode = function() {
        return n(u)
    }, t.unstable_next = function(B) {
        switch (m) {
            case 1:
            case 2:
            case 3:
                var K = 3;
                break;
            default:
                K = m
        }
        var Q = m;
        m = K;
        try {
            return B()
        } finally {
            m = Q
        }
    }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(B, K) {
        switch (B) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                B = 3
        }
        var Q = m;
        m = B;
        try {
            return K()
        } finally {
            m = Q
        }
    }, t.unstable_scheduleCallback = function(B, K, Q) {
        var pe = t.unstable_now();
        switch (typeof Q == "object" && Q !== null ? (Q = Q.delay, Q = typeof Q == "number" && 0 < Q ? pe + Q : pe) : Q = pe, B) {
            case 1:
                var ue = -1;
                break;
            case 2:
                ue = 250;
                break;
            case 5:
                ue = 1073741823;
                break;
            case 4:
                ue = 1e4;
                break;
            default:
                ue = 5e3
        }
        return ue = Q + ue, B = {
            id: h++,
            callback: K,
            priorityLevel: B,
            startTime: Q,
            expirationTime: ue,
            sortIndex: -1
        }, Q > pe ? (B.sortIndex = Q, e(c, B), n(u) === null && B === n(c) && (R ? (w(g), g = -1) : R = !0, le(x, Q - pe))) : (B.sortIndex = ue, e(u, B), I || _ || (I = !0, sr(O))), B
    }, t.unstable_shouldYield = C, t.unstable_wrapCallback = function(B) {
        var K = m;
        return function() {
            var Q = m;
            m = K;
            try {
                return B.apply(this, arguments)
            } finally {
                m = Q
            }
        }
    }
})(wT);
_T.exports = wT;
var YR = _T.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XR = M,
    Ut = YR;

function j(t) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++) e += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var TT = new Set,
    oa = {};

function Vi(t, e) {
    Rs(t, e), Rs(t + "Capture", e)
}

function Rs(t, e) {
    for (oa[t] = e, t = 0; t < e.length; t++) TT.add(e[t])
}
var Gn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
    zd = Object.prototype.hasOwnProperty,
    JR = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    rv = {},
    iv = {};

function ZR(t) {
    return zd.call(iv, t) ? !0 : zd.call(rv, t) ? !1 : JR.test(t) ? iv[t] = !0 : (rv[t] = !0, !1)
}

function eC(t, e, n, r) {
    if (n !== null && n.type === 0) return !1;
    switch (typeof e) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return r ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
        default:
            return !1
    }
}

function tC(t, e, n, r) {
    if (e === null || typeof e > "u" || eC(t, e, n, r)) return !0;
    if (r) return !1;
    if (n !== null) switch (n.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
    }
    return !1
}

function wt(t, e, n, r, i, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o
}
var Ye = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    Ye[t] = new wt(t, 0, !1, t, null, !1, !1)
});
[
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"]
].forEach(function(t) {
    var e = t[0];
    Ye[e] = new wt(e, 1, !1, t[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
    Ye[t] = new wt(t, 2, !1, t.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
    Ye[t] = new wt(t, 2, !1, t, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    Ye[t] = new wt(t, 3, !1, t.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
    Ye[t] = new wt(t, 3, !0, t, null, !1, !1)
});
["capture", "download"].forEach(function(t) {
    Ye[t] = new wt(t, 4, !1, t, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function(t) {
    Ye[t] = new wt(t, 6, !1, t, null, !1, !1)
});
["rowSpan", "start"].forEach(function(t) {
    Ye[t] = new wt(t, 5, !1, t.toLowerCase(), null, !1, !1)
});
var bp = /[\-:]([a-z])/g;

function Np(t) {
    return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var e = t.replace(bp, Np);
    Ye[e] = new wt(e, 1, !1, t, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var e = t.replace(bp, Np);
    Ye[e] = new wt(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
    var e = t.replace(bp, Np);
    Ye[e] = new wt(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function(t) {
    Ye[t] = new wt(t, 1, !1, t.toLowerCase(), null, !1, !1)
});
Ye.xlinkHref = new wt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(t) {
    Ye[t] = new wt(t, 1, !1, t.toLowerCase(), null, !0, !0)
});

function Dp(t, e, n, r) {
    var i = Ye.hasOwnProperty(e) ? Ye[e] : null;
    (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (tC(e, n, i, r) && (n = null), r || i === null ? ZR(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (e = i.attributeName, r = i.attributeNamespace, n === null ? t.removeAttribute(e) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))))
}
var rr = XR.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    El = Symbol.for("react.element"),
    Zi = Symbol.for("react.portal"),
    es = Symbol.for("react.fragment"),
    Vp = Symbol.for("react.strict_mode"),
    Wd = Symbol.for("react.profiler"),
    ET = Symbol.for("react.provider"),
    IT = Symbol.for("react.context"),
    Op = Symbol.for("react.forward_ref"),
    qd = Symbol.for("react.suspense"),
    Hd = Symbol.for("react.suspense_list"),
    Lp = Symbol.for("react.memo"),
    pr = Symbol.for("react.lazy"),
    ST = Symbol.for("react.offscreen"),
    sv = Symbol.iterator;

function wo(t) {
    return t === null || typeof t != "object" ? null : (t = sv && t[sv] || t["@@iterator"], typeof t == "function" ? t : null)
}
var Se = Object.assign,
    Uh;

function ko(t) {
    if (Uh === void 0) try {
        throw Error()
    } catch (n) {
        var e = n.stack.trim().match(/\n( *(at )?)/);
        Uh = e && e[1] || ""
    }
    return `
` + Uh + t
}
var jh = !1;

function Bh(t, e) {
    if (!t || jh) return "";
    jh = !0;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                    throw Error()
                }, Object.defineProperty(e.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (c) {
                    var r = c
                }
                Reflect.construct(t, [], e)
            } else {
                try {
                    e.call()
                } catch (c) {
                    r = c
                }
                t.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                r = c
            }
            t()
        }
    } catch (c) {
        if (c && r && typeof c.stack == "string") {
            for (var i = c.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];) a--;
            for (; 1 <= o && 0 <= a; o--, a--)
                if (i[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--, a--, 0 > a || i[o] !== s[a]) {
                                var u = `
` + i[o].replace(" at new ", " at ");
                                return t.displayName && u.includes("<anonymous>") && (u = u.replace("<anonymous>", t.displayName)), u
                            }
                    while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        jh = !1, Error.prepareStackTrace = n
    }
    return (t = t ? t.displayName || t.name : "") ? ko(t) : ""
}

function nC(t) {
    switch (t.tag) {
        case 5:
            return ko(t.type);
        case 16:
            return ko("Lazy");
        case 13:
            return ko("Suspense");
        case 19:
            return ko("SuspenseList");
        case 0:
        case 2:
        case 15:
            return t = Bh(t.type, !1), t;
        case 11:
            return t = Bh(t.type.render, !1), t;
        case 1:
            return t = Bh(t.type, !0), t;
        default:
            return ""
    }
}

function Kd(t) {
    if (t == null) return null;
    if (typeof t == "function") return t.displayName || t.name || null;
    if (typeof t == "string") return t;
    switch (t) {
        case es:
            return "Fragment";
        case Zi:
            return "Portal";
        case Wd:
            return "Profiler";
        case Vp:
            return "StrictMode";
        case qd:
            return "Suspense";
        case Hd:
            return "SuspenseList"
    }
    if (typeof t == "object") switch (t.$$typeof) {
        case IT:
            return (t.displayName || "Context") + ".Consumer";
        case ET:
            return (t._context.displayName || "Context") + ".Provider";
        case Op:
            var e = t.render;
            return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
        case Lp:
            return e = t.displayName || null, e !== null ? e : Kd(t.type) || "Memo";
        case pr:
            e = t._payload, t = t._init;
            try {
                return Kd(t(e))
            } catch {}
    }
    return null
}

function rC(t) {
    var e = t.type;
    switch (t.tag) {
        case 24:
            return "Cache";
        case 9:
            return (e.displayName || "Context") + ".Consumer";
        case 10:
            return (e._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return e;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return Kd(e);
        case 8:
            return e === Vp ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof e == "function") return e.displayName || e.name || null;
            if (typeof e == "string") return e
    }
    return null
}

function Mr(t) {
    switch (typeof t) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return t;
        case "object":
            return t;
        default:
            return ""
    }
}

function AT(t) {
    var e = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}

function iC(t) {
    var e = AT(t) ? "checked" : "value",
        n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
        r = "" + t[e];
    if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
        var i = n.get,
            s = n.set;
        return Object.defineProperty(t, e, {
            configurable: !0,
            get: function() {
                return i.call(this)
            },
            set: function(o) {
                r = "" + o, s.call(this, o)
            }
        }), Object.defineProperty(t, e, {
            enumerable: n.enumerable
        }), {
            getValue: function() {
                return r
            },
            setValue: function(o) {
                r = "" + o
            },
            stopTracking: function() {
                t._valueTracker = null, delete t[e]
            }
        }
    }
}

function Il(t) {
    t._valueTracker || (t._valueTracker = iC(t))
}

function PT(t) {
    if (!t) return !1;
    var e = t._valueTracker;
    if (!e) return !0;
    var n = e.getValue(),
        r = "";
    return t && (r = AT(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), !0) : !1
}

function Tu(t) {
    if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null;
    try {
        return t.activeElement || t.body
    } catch {
        return t.body
    }
}

function Gd(t, e) {
    var n = e.checked;
    return Se({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: n ? ? t._wrapperState.initialChecked
    })
}

function ov(t, e) {
    var n = e.defaultValue == null ? "" : e.defaultValue,
        r = e.checked != null ? e.checked : e.defaultChecked;
    n = Mr(e.value != null ? e.value : n), t._wrapperState = {
        initialChecked: r,
        initialValue: n,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}

function RT(t, e) {
    e = e.checked, e != null && Dp(t, "checked", e, !1)
}

function Qd(t, e) {
    RT(t, e);
    var n = Mr(e.value),
        r = e.type;
    if (n != null) r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
    else if (r === "submit" || r === "reset") {
        t.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? Yd(t, e.type, n) : e.hasOwnProperty("defaultValue") && Yd(t, e.type, Mr(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
}

function av(t, e, n) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var r = e.type;
        if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null)) return;
        e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e
    }
    n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n)
}

function Yd(t, e, n) {
    (e !== "number" || Tu(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n))
}
var xo = Array.isArray;

function ys(t, e, n, r) {
    if (t = t.options, e) {
        e = {};
        for (var i = 0; i < n.length; i++) e["$" + n[i]] = !0;
        for (n = 0; n < t.length; n++) i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = !0)
    } else {
        for (n = "" + Mr(n), e = null, i = 0; i < t.length; i++) {
            if (t[i].value === n) {
                t[i].selected = !0, r && (t[i].defaultSelected = !0);
                return
            }
            e !== null || t[i].disabled || (e = t[i])
        }
        e !== null && (e.selected = !0)
    }
}

function Xd(t, e) {
    if (e.dangerouslySetInnerHTML != null) throw Error(j(91));
    return Se({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + t._wrapperState.initialValue
    })
}

function lv(t, e) {
    var n = e.value;
    if (n == null) {
        if (n = e.children, e = e.defaultValue, n != null) {
            if (e != null) throw Error(j(92));
            if (xo(n)) {
                if (1 < n.length) throw Error(j(93));
                n = n[0]
            }
            e = n
        }
        e == null && (e = ""), n = e
    }
    t._wrapperState = {
        initialValue: Mr(n)
    }
}

function CT(t, e) {
    var n = Mr(e.value),
        r = Mr(e.defaultValue);
    n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r)
}

function uv(t) {
    var e = t.textContent;
    e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
}

function kT(t) {
    switch (t) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
    }
}

function Jd(t, e) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? kT(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var Sl, xT = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, n, r, i) {
        MSApp.execUnsafeLocalFunction(function() {
            return t(e, n, r, i)
        })
    } : t
}(function(t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e;
    else {
        for (Sl = Sl || document.createElement("div"), Sl.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Sl.firstChild; t.firstChild;) t.removeChild(t.firstChild);
        for (; e.firstChild;) t.appendChild(e.firstChild)
    }
});

function aa(t, e) {
    if (e) {
        var n = t.firstChild;
        if (n && n === t.lastChild && n.nodeType === 3) {
            n.nodeValue = e;
            return
        }
    }
    t.textContent = e
}
var jo = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    },
    sC = ["Webkit", "ms", "Moz", "O"];
Object.keys(jo).forEach(function(t) {
    sC.forEach(function(e) {
        e = e + t.charAt(0).toUpperCase() + t.substring(1), jo[e] = jo[t]
    })
});

function bT(t, e, n) {
    return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || jo.hasOwnProperty(t) && jo[t] ? ("" + e).trim() : e + "px"
}

function NT(t, e) {
    t = t.style;
    for (var n in e)
        if (e.hasOwnProperty(n)) {
            var r = n.indexOf("--") === 0,
                i = bT(n, e[n], r);
            n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i
        }
}
var oC = Se({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});

function Zd(t, e) {
    if (e) {
        if (oC[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(j(137, t));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null) throw Error(j(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(j(61))
        }
        if (e.style != null && typeof e.style != "object") throw Error(j(62))
    }
}

function ef(t, e) {
    if (t.indexOf("-") === -1) return typeof e.is == "string";
    switch (t) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
    }
}
var tf = null;

function Mp(t) {
    return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t
}
var nf = null,
    vs = null,
    _s = null;

function cv(t) {
    if (t = $a(t)) {
        if (typeof nf != "function") throw Error(j(280));
        var e = t.stateNode;
        e && (e = Rc(e), nf(t.stateNode, t.type, e))
    }
}

function DT(t) {
    vs ? _s ? _s.push(t) : _s = [t] : vs = t
}

function VT() {
    if (vs) {
        var t = vs,
            e = _s;
        if (_s = vs = null, cv(t), e)
            for (t = 0; t < e.length; t++) cv(e[t])
    }
}

function OT(t, e) {
    return t(e)
}

function LT() {}
var $h = !1;

function MT(t, e, n) {
    if ($h) return t(e, n);
    $h = !0;
    try {
        return OT(t, e, n)
    } finally {
        $h = !1, (vs !== null || _s !== null) && (LT(), VT())
    }
}

function la(t, e) {
    var n = t.stateNode;
    if (n === null) return null;
    var r = Rc(n);
    if (r === null) return null;
    n = r[e];
    e: switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r;
            break e;
        default:
            t = !1
    }
    if (t) return null;
    if (n && typeof n != "function") throw Error(j(231, e, typeof n));
    return n
}
var rf = !1;
if (Gn) try {
    var To = {};
    Object.defineProperty(To, "passive", {
        get: function() {
            rf = !0
        }
    }), window.addEventListener("test", To, To), window.removeEventListener("test", To, To)
} catch {
    rf = !1
}

function aC(t, e, n, r, i, s, o, a, u) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(n, c)
    } catch (h) {
        this.onError(h)
    }
}
var Bo = !1,
    Eu = null,
    Iu = !1,
    sf = null,
    lC = {
        onError: function(t) {
            Bo = !0, Eu = t
        }
    };

function uC(t, e, n, r, i, s, o, a, u) {
    Bo = !1, Eu = null, aC.apply(lC, arguments)
}

function cC(t, e, n, r, i, s, o, a, u) {
    if (uC.apply(this, arguments), Bo) {
        if (Bo) {
            var c = Eu;
            Bo = !1, Eu = null
        } else throw Error(j(198));
        Iu || (Iu = !0, sf = c)
    }
}

function Oi(t) {
    var e = t,
        n = t;
    if (t.alternate)
        for (; e.return;) e = e.return;
    else {
        t = e;
        do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t)
    }
    return e.tag === 3 ? n : null
}

function FT(t) {
    if (t.tag === 13) {
        var e = t.memoizedState;
        if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated
    }
    return null
}

function hv(t) {
    if (Oi(t) !== t) throw Error(j(188))
}

function hC(t) {
    var e = t.alternate;
    if (!e) {
        if (e = Oi(t), e === null) throw Error(j(188));
        return e !== t ? null : t
    }
    for (var n = t, r = e;;) {
        var i = n.return;
        if (i === null) break;
        var s = i.alternate;
        if (s === null) {
            if (r = i.return, r !== null) {
                n = r;
                continue
            }
            break
        }
        if (i.child === s.child) {
            for (s = i.child; s;) {
                if (s === n) return hv(i), t;
                if (s === r) return hv(i), e;
                s = s.sibling
            }
            throw Error(j(188))
        }
        if (n.return !== r.return) n = i, r = s;
        else {
            for (var o = !1, a = i.child; a;) {
                if (a === n) {
                    o = !0, n = i, r = s;
                    break
                }
                if (a === r) {
                    o = !0, r = i, n = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a;) {
                    if (a === n) {
                        o = !0, n = s, r = i;
                        break
                    }
                    if (a === r) {
                        o = !0, r = s, n = i;
                        break
                    }
                    a = a.sibling
                }
                if (!o) throw Error(j(189))
            }
        }
        if (n.alternate !== r) throw Error(j(190))
    }
    if (n.tag !== 3) throw Error(j(188));
    return n.stateNode.current === n ? t : e
}

function UT(t) {
    return t = hC(t), t !== null ? jT(t) : null
}

function jT(t) {
    if (t.tag === 5 || t.tag === 6) return t;
    for (t = t.child; t !== null;) {
        var e = jT(t);
        if (e !== null) return e;
        t = t.sibling
    }
    return null
}
var BT = Ut.unstable_scheduleCallback,
    dv = Ut.unstable_cancelCallback,
    dC = Ut.unstable_shouldYield,
    fC = Ut.unstable_requestPaint,
    be = Ut.unstable_now,
    pC = Ut.unstable_getCurrentPriorityLevel,
    Fp = Ut.unstable_ImmediatePriority,
    $T = Ut.unstable_UserBlockingPriority,
    Su = Ut.unstable_NormalPriority,
    mC = Ut.unstable_LowPriority,
    zT = Ut.unstable_IdlePriority,
    Ic = null,
    vn = null;

function gC(t) {
    if (vn && typeof vn.onCommitFiberRoot == "function") try {
        vn.onCommitFiberRoot(Ic, t, void 0, (t.current.flags & 128) === 128)
    } catch {}
}
var ln = Math.clz32 ? Math.clz32 : _C,
    yC = Math.log,
    vC = Math.LN2;

function _C(t) {
    return t >>>= 0, t === 0 ? 32 : 31 - (yC(t) / vC | 0) | 0
}
var Al = 64,
    Pl = 4194304;

function bo(t) {
    switch (t & -t) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return t & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return t & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return t
    }
}

function Au(t, e) {
    var n = t.pendingLanes;
    if (n === 0) return 0;
    var r = 0,
        i = t.suspendedLanes,
        s = t.pingedLanes,
        o = n & 268435455;
    if (o !== 0) {
        var a = o & ~i;
        a !== 0 ? r = bo(a) : (s &= o, s !== 0 && (r = bo(s)))
    } else o = n & ~i, o !== 0 ? r = bo(o) : s !== 0 && (r = bo(s));
    if (r === 0) return 0;
    if (e !== 0 && e !== r && !(e & i) && (i = r & -r, s = e & -e, i >= s || i === 16 && (s & 4194240) !== 0)) return e;
    if (r & 4 && (r |= n & 16), e = t.entangledLanes, e !== 0)
        for (t = t.entanglements, e &= r; 0 < e;) n = 31 - ln(e), i = 1 << n, r |= t[n], e &= ~i;
    return r
}

function wC(t, e) {
    switch (t) {
        case 1:
        case 2:
        case 4:
            return e + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return e + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
    }
}

function TC(t, e) {
    for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes; 0 < s;) {
        var o = 31 - ln(s),
            a = 1 << o,
            u = i[o];
        u === -1 ? (!(a & n) || a & r) && (i[o] = wC(a, e)) : u <= e && (t.expiredLanes |= a), s &= ~a
    }
}

function of (t) {
    return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}

function WT() {
    var t = Al;
    return Al <<= 1, !(Al & 4194240) && (Al = 64), t
}

function zh(t) {
    for (var e = [], n = 0; 31 > n; n++) e.push(t);
    return e
}

function ja(t, e, n) {
    t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - ln(e), t[e] = n
}

function EC(t, e) {
    var n = t.pendingLanes & ~e;
    t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements;
    var r = t.eventTimes;
    for (t = t.expirationTimes; 0 < n;) {
        var i = 31 - ln(n),
            s = 1 << i;
        e[i] = 0, r[i] = -1, t[i] = -1, n &= ~s
    }
}

function Up(t, e) {
    var n = t.entangledLanes |= e;
    for (t = t.entanglements; n;) {
        var r = 31 - ln(n),
            i = 1 << r;
        i & e | t[r] & e && (t[r] |= e), n &= ~i
    }
}
var ce = 0;

function qT(t) {
    return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1
}
var HT, jp, KT, GT, QT, af = !1,
    Rl = [],
    Rr = null,
    Cr = null,
    kr = null,
    ua = new Map,
    ca = new Map,
    gr = [],
    IC = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function fv(t, e) {
    switch (t) {
        case "focusin":
        case "focusout":
            Rr = null;
            break;
        case "dragenter":
        case "dragleave":
            Cr = null;
            break;
        case "mouseover":
        case "mouseout":
            kr = null;
            break;
        case "pointerover":
        case "pointerout":
            ua.delete(e.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            ca.delete(e.pointerId)
    }
}

function Eo(t, e, n, r, i, s) {
    return t === null || t.nativeEvent !== s ? (t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i]
    }, e !== null && (e = $a(e), e !== null && jp(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t)
}

function SC(t, e, n, r, i) {
    switch (e) {
        case "focusin":
            return Rr = Eo(Rr, t, e, n, r, i), !0;
        case "dragenter":
            return Cr = Eo(Cr, t, e, n, r, i), !0;
        case "mouseover":
            return kr = Eo(kr, t, e, n, r, i), !0;
        case "pointerover":
            var s = i.pointerId;
            return ua.set(s, Eo(ua.get(s) || null, t, e, n, r, i)), !0;
        case "gotpointercapture":
            return s = i.pointerId, ca.set(s, Eo(ca.get(s) || null, t, e, n, r, i)), !0
    }
    return !1
}

function YT(t) {
    var e = pi(t.target);
    if (e !== null) {
        var n = Oi(e);
        if (n !== null) {
            if (e = n.tag, e === 13) {
                if (e = FT(n), e !== null) {
                    t.blockedOn = e, QT(t.priority, function() {
                        KT(n)
                    });
                    return
                }
            } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
                t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
                return
            }
        }
    }
    t.blockedOn = null
}

function Xl(t) {
    if (t.blockedOn !== null) return !1;
    for (var e = t.targetContainers; 0 < e.length;) {
        var n = lf(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
        if (n === null) {
            n = t.nativeEvent;
            var r = new n.constructor(n.type, n);
            tf = r, n.target.dispatchEvent(r), tf = null
        } else return e = $a(n), e !== null && jp(e), t.blockedOn = n, !1;
        e.shift()
    }
    return !0
}

function pv(t, e, n) {
    Xl(t) && n.delete(e)
}

function AC() {
    af = !1, Rr !== null && Xl(Rr) && (Rr = null), Cr !== null && Xl(Cr) && (Cr = null), kr !== null && Xl(kr) && (kr = null), ua.forEach(pv), ca.forEach(pv)
}

function Io(t, e) {
    t.blockedOn === e && (t.blockedOn = null, af || (af = !0, Ut.unstable_scheduleCallback(Ut.unstable_NormalPriority, AC)))
}

function ha(t) {
    function e(i) {
        return Io(i, t)
    }
    if (0 < Rl.length) {
        Io(Rl[0], t);
        for (var n = 1; n < Rl.length; n++) {
            var r = Rl[n];
            r.blockedOn === t && (r.blockedOn = null)
        }
    }
    for (Rr !== null && Io(Rr, t), Cr !== null && Io(Cr, t), kr !== null && Io(kr, t), ua.forEach(e), ca.forEach(e), n = 0; n < gr.length; n++) r = gr[n], r.blockedOn === t && (r.blockedOn = null);
    for (; 0 < gr.length && (n = gr[0], n.blockedOn === null);) YT(n), n.blockedOn === null && gr.shift()
}
var ws = rr.ReactCurrentBatchConfig,
    Pu = !0;

function PC(t, e, n, r) {
    var i = ce,
        s = ws.transition;
    ws.transition = null;
    try {
        ce = 1, Bp(t, e, n, r)
    } finally {
        ce = i, ws.transition = s
    }
}

function RC(t, e, n, r) {
    var i = ce,
        s = ws.transition;
    ws.transition = null;
    try {
        ce = 4, Bp(t, e, n, r)
    } finally {
        ce = i, ws.transition = s
    }
}

function Bp(t, e, n, r) {
    if (Pu) {
        var i = lf(t, e, n, r);
        if (i === null) Zh(t, e, r, Ru, n), fv(t, r);
        else if (SC(i, t, e, n, r)) r.stopPropagation();
        else if (fv(t, r), e & 4 && -1 < IC.indexOf(t)) {
            for (; i !== null;) {
                var s = $a(i);
                if (s !== null && HT(s), s = lf(t, e, n, r), s === null && Zh(t, e, r, Ru, n), s === i) break;
                i = s
            }
            i !== null && r.stopPropagation()
        } else Zh(t, e, r, null, n)
    }
}
var Ru = null;

function lf(t, e, n, r) {
    if (Ru = null, t = Mp(r), t = pi(t), t !== null)
        if (e = Oi(t), e === null) t = null;
        else if (n = e.tag, n === 13) {
        if (t = FT(e), t !== null) return t;
        t = null
    } else if (n === 3) {
        if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
        t = null
    } else e !== t && (t = null);
    return Ru = t, null
}

function XT(t) {
    switch (t) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (pC()) {
                case Fp:
                    return 1;
                case $T:
                    return 4;
                case Su:
                case mC:
                    return 16;
                case zT:
                    return 536870912;
                default:
                    return 16
            }
        default:
            return 16
    }
}
var Er = null,
    $p = null,
    Jl = null;

function JT() {
    if (Jl) return Jl;
    var t, e = $p,
        n = e.length,
        r, i = "value" in Er ? Er.value : Er.textContent,
        s = i.length;
    for (t = 0; t < n && e[t] === i[t]; t++);
    var o = n - t;
    for (r = 1; r <= o && e[n - r] === i[s - r]; r++);
    return Jl = i.slice(t, 1 < r ? 1 - r : void 0)
}

function Zl(t) {
    var e = t.keyCode;
    return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0
}

function Cl() {
    return !0
}

function mv() {
    return !1
}

function zt(t) {
    function e(n, r, i, s, o) {
        this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = o, this.currentTarget = null;
        for (var a in t) t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Cl : mv, this.isPropagationStopped = mv, this
    }
    return Se(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Cl)
        },
        stopPropagation: function() {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Cl)
        },
        persist: function() {},
        isPersistent: Cl
    }), e
}
var Hs = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(t) {
            return t.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    },
    zp = zt(Hs),
    Ba = Se({}, Hs, {
        view: 0,
        detail: 0
    }),
    CC = zt(Ba),
    Wh, qh, So, Sc = Se({}, Ba, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: Wp,
        button: 0,
        buttons: 0,
        relatedTarget: function(t) {
            return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
        },
        movementX: function(t) {
            return "movementX" in t ? t.movementX : (t !== So && (So && t.type === "mousemove" ? (Wh = t.screenX - So.screenX, qh = t.screenY - So.screenY) : qh = Wh = 0, So = t), Wh)
        },
        movementY: function(t) {
            return "movementY" in t ? t.movementY : qh
        }
    }),
    gv = zt(Sc),
    kC = Se({}, Sc, {
        dataTransfer: 0
    }),
    xC = zt(kC),
    bC = Se({}, Ba, {
        relatedTarget: 0
    }),
    Hh = zt(bC),
    NC = Se({}, Hs, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    DC = zt(NC),
    VC = Se({}, Hs, {
        clipboardData: function(t) {
            return "clipboardData" in t ? t.clipboardData : window.clipboardData
        }
    }),
    OC = zt(VC),
    LC = Se({}, Hs, {
        data: 0
    }),
    yv = zt(LC),
    MC = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    },
    FC = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    },
    UC = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };

function jC(t) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(t) : (t = UC[t]) ? !!e[t] : !1
}

function Wp() {
    return jC
}
var BC = Se({}, Ba, {
        key: function(t) {
            if (t.key) {
                var e = MC[t.key] || t.key;
                if (e !== "Unidentified") return e
            }
            return t.type === "keypress" ? (t = Zl(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? FC[t.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: Wp,
        charCode: function(t) {
            return t.type === "keypress" ? Zl(t) : 0
        },
        keyCode: function(t) {
            return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
        },
        which: function(t) {
            return t.type === "keypress" ? Zl(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
        }
    }),
    $C = zt(BC),
    zC = Se({}, Sc, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }),
    vv = zt(zC),
    WC = Se({}, Ba, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: Wp
    }),
    qC = zt(WC),
    HC = Se({}, Hs, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    KC = zt(HC),
    GC = Se({}, Sc, {
        deltaX: function(t) {
            return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0
        },
        deltaY: function(t) {
            return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    }),
    QC = zt(GC),
    YC = [9, 13, 27, 32],
    qp = Gn && "CompositionEvent" in window,
    $o = null;
Gn && "documentMode" in document && ($o = document.documentMode);
var XC = Gn && "TextEvent" in window && !$o,
    ZT = Gn && (!qp || $o && 8 < $o && 11 >= $o),
    _v = " ",
    wv = !1;

function eE(t, e) {
    switch (t) {
        case "keyup":
            return YC.indexOf(e.keyCode) !== -1;
        case "keydown":
            return e.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
    }
}

function tE(t) {
    return t = t.detail, typeof t == "object" && "data" in t ? t.data : null
}
var ts = !1;

function JC(t, e) {
    switch (t) {
        case "compositionend":
            return tE(e);
        case "keypress":
            return e.which !== 32 ? null : (wv = !0, _v);
        case "textInput":
            return t = e.data, t === _v && wv ? null : t;
        default:
            return null
    }
}

function ZC(t, e) {
    if (ts) return t === "compositionend" || !qp && eE(t, e) ? (t = JT(), Jl = $p = Er = null, ts = !1, t) : null;
    switch (t) {
        case "paste":
            return null;
        case "keypress":
            if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
                if (e.char && 1 < e.char.length) return e.char;
                if (e.which) return String.fromCharCode(e.which)
            }
            return null;
        case "compositionend":
            return ZT && e.locale !== "ko" ? null : e.data;
        default:
            return null
    }
}
var ek = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};

function Tv(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e === "input" ? !!ek[t.type] : e === "textarea"
}

function nE(t, e, n, r) {
    DT(r), e = Cu(e, "onChange"), 0 < e.length && (n = new zp("onChange", "change", null, n, r), t.push({
        event: n,
        listeners: e
    }))
}
var zo = null,
    da = null;

function tk(t) {
    fE(t, 0)
}

function Ac(t) {
    var e = is(t);
    if (PT(e)) return t
}

function nk(t, e) {
    if (t === "change") return e
}
var rE = !1;
if (Gn) {
    var Kh;
    if (Gn) {
        var Gh = "oninput" in document;
        if (!Gh) {
            var Ev = document.createElement("div");
            Ev.setAttribute("oninput", "return;"), Gh = typeof Ev.oninput == "function"
        }
        Kh = Gh
    } else Kh = !1;
    rE = Kh && (!document.documentMode || 9 < document.documentMode)
}

function Iv() {
    zo && (zo.detachEvent("onpropertychange", iE), da = zo = null)
}

function iE(t) {
    if (t.propertyName === "value" && Ac(da)) {
        var e = [];
        nE(e, da, t, Mp(t)), MT(tk, e)
    }
}

function rk(t, e, n) {
    t === "focusin" ? (Iv(), zo = e, da = n, zo.attachEvent("onpropertychange", iE)) : t === "focusout" && Iv()
}

function ik(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown") return Ac(da)
}

function sk(t, e) {
    if (t === "click") return Ac(e)
}

function ok(t, e) {
    if (t === "input" || t === "change") return Ac(e)
}

function ak(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var cn = typeof Object.is == "function" ? Object.is : ak;

function fa(t, e) {
    if (cn(t, e)) return !0;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1;
    var n = Object.keys(t),
        r = Object.keys(e);
    if (n.length !== r.length) return !1;
    for (r = 0; r < n.length; r++) {
        var i = n[r];
        if (!zd.call(e, i) || !cn(t[i], e[i])) return !1
    }
    return !0
}

function Sv(t) {
    for (; t && t.firstChild;) t = t.firstChild;
    return t
}

function Av(t, e) {
    var n = Sv(t);
    t = 0;
    for (var r; n;) {
        if (n.nodeType === 3) {
            if (r = t + n.textContent.length, t <= e && r >= e) return {
                node: n,
                offset: e - t
            };
            t = r
        }
        e: {
            for (; n;) {
                if (n.nextSibling) {
                    n = n.nextSibling;
                    break e
                }
                n = n.parentNode
            }
            n = void 0
        }
        n = Sv(n)
    }
}

function sE(t, e) {
    return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? sE(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
}

function oE() {
    for (var t = window, e = Tu(); e instanceof t.HTMLIFrameElement;) {
        try {
            var n = typeof e.contentWindow.location.href == "string"
        } catch {
            n = !1
        }
        if (n) t = e.contentWindow;
        else break;
        e = Tu(t.document)
    }
    return e
}

function Hp(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
}

function lk(t) {
    var e = oE(),
        n = t.focusedElem,
        r = t.selectionRange;
    if (e !== n && n && n.ownerDocument && sE(n.ownerDocument.documentElement, n)) {
        if (r !== null && Hp(n)) {
            if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length);
            else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) {
                t = t.getSelection();
                var i = n.textContent.length,
                    s = Math.min(r.start, i);
                r = r.end === void 0 ? s : Math.min(r.end, i), !t.extend && s > r && (i = r, r = s, s = i), i = Av(n, s);
                var o = Av(n, r);
                i && o && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), s > r ? (t.addRange(e), t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), t.addRange(e)))
            }
        }
        for (e = [], t = n; t = t.parentNode;) t.nodeType === 1 && e.push({
            element: t,
            left: t.scrollLeft,
            top: t.scrollTop
        });
        for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++) t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top
    }
}
var uk = Gn && "documentMode" in document && 11 >= document.documentMode,
    ns = null,
    uf = null,
    Wo = null,
    cf = !1;

function Pv(t, e, n) {
    var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    cf || ns == null || ns !== Tu(r) || (r = ns, "selectionStart" in r && Hp(r) ? r = {
        start: r.selectionStart,
        end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
        anchorNode: r.anchorNode,
        anchorOffset: r.anchorOffset,
        focusNode: r.focusNode,
        focusOffset: r.focusOffset
    }), Wo && fa(Wo, r) || (Wo = r, r = Cu(uf, "onSelect"), 0 < r.length && (e = new zp("onSelect", "select", null, e, n), t.push({
        event: e,
        listeners: r
    }), e.target = ns)))
}

function kl(t, e) {
    var n = {};
    return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n
}
var rs = {
        animationend: kl("Animation", "AnimationEnd"),
        animationiteration: kl("Animation", "AnimationIteration"),
        animationstart: kl("Animation", "AnimationStart"),
        transitionend: kl("Transition", "TransitionEnd")
    },
    Qh = {},
    aE = {};
Gn && (aE = document.createElement("div").style, "AnimationEvent" in window || (delete rs.animationend.animation, delete rs.animationiteration.animation, delete rs.animationstart.animation), "TransitionEvent" in window || delete rs.transitionend.transition);

function Pc(t) {
    if (Qh[t]) return Qh[t];
    if (!rs[t]) return t;
    var e = rs[t],
        n;
    for (n in e)
        if (e.hasOwnProperty(n) && n in aE) return Qh[t] = e[n];
    return t
}
var lE = Pc("animationend"),
    uE = Pc("animationiteration"),
    cE = Pc("animationstart"),
    hE = Pc("transitionend"),
    dE = new Map,
    Rv = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function Gr(t, e) {
    dE.set(t, e), Vi(e, [t])
}
for (var Yh = 0; Yh < Rv.length; Yh++) {
    var Xh = Rv[Yh],
        ck = Xh.toLowerCase(),
        hk = Xh[0].toUpperCase() + Xh.slice(1);
    Gr(ck, "on" + hk)
}
Gr(lE, "onAnimationEnd");
Gr(uE, "onAnimationIteration");
Gr(cE, "onAnimationStart");
Gr("dblclick", "onDoubleClick");
Gr("focusin", "onFocus");
Gr("focusout", "onBlur");
Gr(hE, "onTransitionEnd");
Rs("onMouseEnter", ["mouseout", "mouseover"]);
Rs("onMouseLeave", ["mouseout", "mouseover"]);
Rs("onPointerEnter", ["pointerout", "pointerover"]);
Rs("onPointerLeave", ["pointerout", "pointerover"]);
Vi("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Vi("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Vi("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Vi("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Vi("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Vi("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var No = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    dk = new Set("cancel close invalid load scroll toggle".split(" ").concat(No));

function Cv(t, e, n) {
    var r = t.type || "unknown-event";
    t.currentTarget = n, cC(r, e, void 0, t), t.currentTarget = null
}

function fE(t, e) {
    e = (e & 4) !== 0;
    for (var n = 0; n < t.length; n++) {
        var r = t[n],
            i = r.event;
        r = r.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = r.length - 1; 0 <= o; o--) {
                    var a = r[o],
                        u = a.instance,
                        c = a.currentTarget;
                    if (a = a.listener, u !== s && i.isPropagationStopped()) break e;
                    Cv(i, a, c), s = u
                } else
                    for (o = 0; o < r.length; o++) {
                        if (a = r[o], u = a.instance, c = a.currentTarget, a = a.listener, u !== s && i.isPropagationStopped()) break e;
                        Cv(i, a, c), s = u
                    }
        }
    }
    if (Iu) throw t = sf, Iu = !1, sf = null, t
}

function ge(t, e) {
    var n = e[mf];
    n === void 0 && (n = e[mf] = new Set);
    var r = t + "__bubble";
    n.has(r) || (pE(e, t, 2, !1), n.add(r))
}

function Jh(t, e, n) {
    var r = 0;
    e && (r |= 4), pE(n, t, r, e)
}
var xl = "_reactListening" + Math.random().toString(36).slice(2);

function pa(t) {
    if (!t[xl]) {
        t[xl] = !0, TT.forEach(function(n) {
            n !== "selectionchange" && (dk.has(n) || Jh(n, !1, t), Jh(n, !0, t))
        });
        var e = t.nodeType === 9 ? t : t.ownerDocument;
        e === null || e[xl] || (e[xl] = !0, Jh("selectionchange", !1, e))
    }
}

function pE(t, e, n, r) {
    switch (XT(e)) {
        case 1:
            var i = PC;
            break;
        case 4:
            i = RC;
            break;
        default:
            i = Bp
    }
    n = i.bind(null, e, n, t), i = void 0, !rf || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), r ? i !== void 0 ? t.addEventListener(e, n, {
        capture: !0,
        passive: i
    }) : t.addEventListener(e, n, !0) : i !== void 0 ? t.addEventListener(e, n, {
        passive: i
    }) : t.addEventListener(e, n, !1)
}

function Zh(t, e, n, r, i) {
    var s = r;
    if (!(e & 1) && !(e & 2) && r !== null) e: for (;;) {
        if (r === null) return;
        var o = r.tag;
        if (o === 3 || o === 4) {
            var a = r.stateNode.containerInfo;
            if (a === i || a.nodeType === 8 && a.parentNode === i) break;
            if (o === 4)
                for (o = r.return; o !== null;) {
                    var u = o.tag;
                    if ((u === 3 || u === 4) && (u = o.stateNode.containerInfo, u === i || u.nodeType === 8 && u.parentNode === i)) return;
                    o = o.return
                }
            for (; a !== null;) {
                if (o = pi(a), o === null) return;
                if (u = o.tag, u === 5 || u === 6) {
                    r = s = o;
                    continue e
                }
                a = a.parentNode
            }
        }
        r = r.return
    }
    MT(function() {
        var c = s,
            h = Mp(n),
            f = [];
        e: {
            var m = dE.get(t);
            if (m !== void 0) {
                var _ = zp,
                    I = t;
                switch (t) {
                    case "keypress":
                        if (Zl(n) === 0) break e;
                    case "keydown":
                    case "keyup":
                        _ = $C;
                        break;
                    case "focusin":
                        I = "focus", _ = Hh;
                        break;
                    case "focusout":
                        I = "blur", _ = Hh;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        _ = Hh;
                        break;
                    case "click":
                        if (n.button === 2) break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        _ = gv;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        _ = xC;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        _ = qC;
                        break;
                    case lE:
                    case uE:
                    case cE:
                        _ = DC;
                        break;
                    case hE:
                        _ = KC;
                        break;
                    case "scroll":
                        _ = CC;
                        break;
                    case "wheel":
                        _ = QC;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        _ = OC;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        _ = vv
                }
                var R = (e & 4) !== 0,
                    k = !R && t === "scroll",
                    w = R ? m !== null ? m + "Capture" : null : m;
                R = [];
                for (var v = c, T; v !== null;) {
                    T = v;
                    var x = T.stateNode;
                    if (T.tag === 5 && x !== null && (T = x, w !== null && (x = la(v, w), x != null && R.push(ma(v, x, T)))), k) break;
                    v = v.return
                }
                0 < R.length && (m = new _(m, I, null, n, h), f.push({
                    event: m,
                    listeners: R
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (m = t === "mouseover" || t === "pointerover", _ = t === "mouseout" || t === "pointerout", m && n !== tf && (I = n.relatedTarget || n.fromElement) && (pi(I) || I[Qn])) break e;
                if ((_ || m) && (m = h.window === h ? h : (m = h.ownerDocument) ? m.defaultView || m.parentWindow : window, _ ? (I = n.relatedTarget || n.toElement, _ = c, I = I ? pi(I) : null, I !== null && (k = Oi(I), I !== k || I.tag !== 5 && I.tag !== 6) && (I = null)) : (_ = null, I = c), _ !== I)) {
                    if (R = gv, x = "onMouseLeave", w = "onMouseEnter", v = "mouse", (t === "pointerout" || t === "pointerover") && (R = vv, x = "onPointerLeave", w = "onPointerEnter", v = "pointer"), k = _ == null ? m : is(_), T = I == null ? m : is(I), m = new R(x, v + "leave", _, n, h), m.target = k, m.relatedTarget = T, x = null, pi(h) === c && (R = new R(w, v + "enter", I, n, h), R.target = T, R.relatedTarget = k, x = R), k = x, _ && I) t: {
                        for (R = _, w = I, v = 0, T = R; T; T = Ki(T)) v++;
                        for (T = 0, x = w; x; x = Ki(x)) T++;
                        for (; 0 < v - T;) R = Ki(R),
                        v--;
                        for (; 0 < T - v;) w = Ki(w),
                        T--;
                        for (; v--;) {
                            if (R === w || w !== null && R === w.alternate) break t;
                            R = Ki(R), w = Ki(w)
                        }
                        R = null
                    }
                    else R = null;
                    _ !== null && kv(f, m, _, R, !1), I !== null && k !== null && kv(f, k, I, R, !0)
                }
            }
            e: {
                if (m = c ? is(c) : window, _ = m.nodeName && m.nodeName.toLowerCase(), _ === "select" || _ === "input" && m.type === "file") var O = nk;
                else if (Tv(m))
                    if (rE) O = ok;
                    else {
                        O = ik;
                        var U = rk
                    }
                else(_ = m.nodeName) && _.toLowerCase() === "input" && (m.type === "checkbox" || m.type === "radio") && (O = sk);
                if (O && (O = O(t, c))) {
                    nE(f, O, n, h);
                    break e
                }
                U && U(t, m, c),
                t === "focusout" && (U = m._wrapperState) && U.controlled && m.type === "number" && Yd(m, "number", m.value)
            }
            switch (U = c ? is(c) : window, t) {
                case "focusin":
                    (Tv(U) || U.contentEditable === "true") && (ns = U, uf = c, Wo = null);
                    break;
                case "focusout":
                    Wo = uf = ns = null;
                    break;
                case "mousedown":
                    cf = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    cf = !1, Pv(f, n, h);
                    break;
                case "selectionchange":
                    if (uk) break;
                case "keydown":
                case "keyup":
                    Pv(f, n, h)
            }
            var S;
            if (qp) e: {
                switch (t) {
                    case "compositionstart":
                        var g = "onCompositionStart";
                        break e;
                    case "compositionend":
                        g = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        g = "onCompositionUpdate";
                        break e
                }
                g = void 0
            }
            else ts ? eE(t, n) && (g = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (g = "onCompositionStart");g && (ZT && n.locale !== "ko" && (ts || g !== "onCompositionStart" ? g === "onCompositionEnd" && ts && (S = JT()) : (Er = h, $p = "value" in Er ? Er.value : Er.textContent, ts = !0)), U = Cu(c, g), 0 < U.length && (g = new yv(g, t, null, n, h), f.push({
                event: g,
                listeners: U
            }), S ? g.data = S : (S = tE(n), S !== null && (g.data = S)))),
            (S = XC ? JC(t, n) : ZC(t, n)) && (c = Cu(c, "onBeforeInput"), 0 < c.length && (h = new yv("onBeforeInput", "beforeinput", null, n, h), f.push({
                event: h,
                listeners: c
            }), h.data = S))
        }
        fE(f, e)
    })
}

function ma(t, e, n) {
    return {
        instance: t,
        listener: e,
        currentTarget: n
    }
}

function Cu(t, e) {
    for (var n = e + "Capture", r = []; t !== null;) {
        var i = t,
            s = i.stateNode;
        i.tag === 5 && s !== null && (i = s, s = la(t, n), s != null && r.unshift(ma(t, s, i)), s = la(t, e), s != null && r.push(ma(t, s, i))), t = t.return
    }
    return r
}

function Ki(t) {
    if (t === null) return null;
    do t = t.return; while (t && t.tag !== 5);
    return t || null
}

function kv(t, e, n, r, i) {
    for (var s = e._reactName, o = []; n !== null && n !== r;) {
        var a = n,
            u = a.alternate,
            c = a.stateNode;
        if (u !== null && u === r) break;
        a.tag === 5 && c !== null && (a = c, i ? (u = la(n, s), u != null && o.unshift(ma(n, u, a))) : i || (u = la(n, s), u != null && o.push(ma(n, u, a)))), n = n.return
    }
    o.length !== 0 && t.push({
        event: e,
        listeners: o
    })
}
var fk = /\r\n?/g,
    pk = /\u0000|\uFFFD/g;

function xv(t) {
    return (typeof t == "string" ? t : "" + t).replace(fk, `
`).replace(pk, "")
}

function bl(t, e, n) {
    if (e = xv(e), xv(t) !== e && n) throw Error(j(425))
}

function ku() {}
var hf = null,
    df = null;

function ff(t, e) {
    return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var pf = typeof setTimeout == "function" ? setTimeout : void 0,
    mk = typeof clearTimeout == "function" ? clearTimeout : void 0,
    bv = typeof Promise == "function" ? Promise : void 0,
    gk = typeof queueMicrotask == "function" ? queueMicrotask : typeof bv < "u" ? function(t) {
        return bv.resolve(null).then(t).catch(yk)
    } : pf;

function yk(t) {
    setTimeout(function() {
        throw t
    })
}

function ed(t, e) {
    var n = e,
        r = 0;
    do {
        var i = n.nextSibling;
        if (t.removeChild(n), i && i.nodeType === 8)
            if (n = i.data, n === "/$") {
                if (r === 0) {
                    t.removeChild(i), ha(e);
                    return
                }
                r--
            } else n !== "$" && n !== "$?" && n !== "$!" || r++;
        n = i
    } while (n);
    ha(e)
}

function xr(t) {
    for (; t != null; t = t.nextSibling) {
        var e = t.nodeType;
        if (e === 1 || e === 3) break;
        if (e === 8) {
            if (e = t.data, e === "$" || e === "$!" || e === "$?") break;
            if (e === "/$") return null
        }
    }
    return t
}

function Nv(t) {
    t = t.previousSibling;
    for (var e = 0; t;) {
        if (t.nodeType === 8) {
            var n = t.data;
            if (n === "$" || n === "$!" || n === "$?") {
                if (e === 0) return t;
                e--
            } else n === "/$" && e++
        }
        t = t.previousSibling
    }
    return null
}
var Ks = Math.random().toString(36).slice(2),
    gn = "__reactFiber$" + Ks,
    ga = "__reactProps$" + Ks,
    Qn = "__reactContainer$" + Ks,
    mf = "__reactEvents$" + Ks,
    vk = "__reactListeners$" + Ks,
    _k = "__reactHandles$" + Ks;

function pi(t) {
    var e = t[gn];
    if (e) return e;
    for (var n = t.parentNode; n;) {
        if (e = n[Qn] || n[gn]) {
            if (n = e.alternate, e.child !== null || n !== null && n.child !== null)
                for (t = Nv(t); t !== null;) {
                    if (n = t[gn]) return n;
                    t = Nv(t)
                }
            return e
        }
        t = n, n = t.parentNode
    }
    return null
}

function $a(t) {
    return t = t[gn] || t[Qn], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}

function is(t) {
    if (t.tag === 5 || t.tag === 6) return t.stateNode;
    throw Error(j(33))
}

function Rc(t) {
    return t[ga] || null
}
var gf = [],
    ss = -1;

function Qr(t) {
    return {
        current: t
    }
}

function ve(t) {
    0 > ss || (t.current = gf[ss], gf[ss] = null, ss--)
}

function fe(t, e) {
    ss++, gf[ss] = t.current, t.current = e
}
var Fr = {},
    ft = Qr(Fr),
    Rt = Qr(!1),
    Ai = Fr;

function Cs(t, e) {
    var n = t.type.contextTypes;
    if (!n) return Fr;
    var r = t.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext;
    var i = {},
        s;
    for (s in n) i[s] = e[s];
    return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i
}

function Ct(t) {
    return t = t.childContextTypes, t != null
}

function xu() {
    ve(Rt), ve(ft)
}

function Dv(t, e, n) {
    if (ft.current !== Fr) throw Error(j(168));
    fe(ft, e), fe(Rt, n)
}

function mE(t, e, n) {
    var r = t.stateNode;
    if (e = e.childContextTypes, typeof r.getChildContext != "function") return n;
    r = r.getChildContext();
    for (var i in r)
        if (!(i in e)) throw Error(j(108, rC(t) || "Unknown", i));
    return Se({}, n, r)
}

function bu(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Fr, Ai = ft.current, fe(ft, t), fe(Rt, Rt.current), !0
}

function Vv(t, e, n) {
    var r = t.stateNode;
    if (!r) throw Error(j(169));
    n ? (t = mE(t, e, Ai), r.__reactInternalMemoizedMergedChildContext = t, ve(Rt), ve(ft), fe(ft, t)) : ve(Rt), fe(Rt, n)
}
var Vn = null,
    Cc = !1,
    td = !1;

function gE(t) {
    Vn === null ? Vn = [t] : Vn.push(t)
}

function wk(t) {
    Cc = !0, gE(t)
}

function Yr() {
    if (!td && Vn !== null) {
        td = !0;
        var t = 0,
            e = ce;
        try {
            var n = Vn;
            for (ce = 1; t < n.length; t++) {
                var r = n[t];
                do r = r(!0); while (r !== null)
            }
            Vn = null, Cc = !1
        } catch (i) {
            throw Vn !== null && (Vn = Vn.slice(t + 1)), BT(Fp, Yr), i
        } finally {
            ce = e, td = !1
        }
    }
    return null
}
var os = [],
    as = 0,
    Nu = null,
    Du = 0,
    Kt = [],
    Gt = 0,
    Pi = null,
    On = 1,
    Ln = "";

function ui(t, e) {
    os[as++] = Du, os[as++] = Nu, Nu = t, Du = e
}

function yE(t, e, n) {
    Kt[Gt++] = On, Kt[Gt++] = Ln, Kt[Gt++] = Pi, Pi = t;
    var r = On;
    t = Ln;
    var i = 32 - ln(r) - 1;
    r &= ~(1 << i), n += 1;
    var s = 32 - ln(e) + i;
    if (30 < s) {
        var o = i - i % 5;
        s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, On = 1 << 32 - ln(e) + i | n << i | r, Ln = s + t
    } else On = 1 << s | n << i | r, Ln = t
}

function Kp(t) {
    t.return !== null && (ui(t, 1), yE(t, 1, 0))
}

function Gp(t) {
    for (; t === Nu;) Nu = os[--as], os[as] = null, Du = os[--as], os[as] = null;
    for (; t === Pi;) Pi = Kt[--Gt], Kt[Gt] = null, Ln = Kt[--Gt], Kt[Gt] = null, On = Kt[--Gt], Kt[Gt] = null
}
var Mt = null,
    Ot = null,
    we = !1,
    on = null;

function vE(t, e) {
    var n = Qt(5, null, null, 0);
    n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n)
}

function Ov(t, e) {
    switch (t.tag) {
        case 5:
            var n = t.type;
            return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Mt = t, Ot = xr(e.firstChild), !0) : !1;
        case 6:
            return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Mt = t, Ot = null, !0) : !1;
        case 13:
            return e = e.nodeType !== 8 ? null : e, e !== null ? (n = Pi !== null ? {
                id: On,
                overflow: Ln
            } : null, t.memoizedState = {
                dehydrated: e,
                treeContext: n,
                retryLane: 1073741824
            }, n = Qt(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, Mt = t, Ot = null, !0) : !1;
        default:
            return !1
    }
}

function yf(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}

function vf(t) {
    if (we) {
        var e = Ot;
        if (e) {
            var n = e;
            if (!Ov(t, e)) {
                if (yf(t)) throw Error(j(418));
                e = xr(n.nextSibling);
                var r = Mt;
                e && Ov(t, e) ? vE(r, n) : (t.flags = t.flags & -4097 | 2, we = !1, Mt = t)
            }
        } else {
            if (yf(t)) throw Error(j(418));
            t.flags = t.flags & -4097 | 2, we = !1, Mt = t
        }
    }
}

function Lv(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;) t = t.return;
    Mt = t
}

function Nl(t) {
    if (t !== Mt) return !1;
    if (!we) return Lv(t), we = !0, !1;
    var e;
    if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !ff(t.type, t.memoizedProps)), e && (e = Ot)) {
        if (yf(t)) throw _E(), Error(j(418));
        for (; e;) vE(t, e), e = xr(e.nextSibling)
    }
    if (Lv(t), t.tag === 13) {
        if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(j(317));
        e: {
            for (t = t.nextSibling, e = 0; t;) {
                if (t.nodeType === 8) {
                    var n = t.data;
                    if (n === "/$") {
                        if (e === 0) {
                            Ot = xr(t.nextSibling);
                            break e
                        }
                        e--
                    } else n !== "$" && n !== "$!" && n !== "$?" || e++
                }
                t = t.nextSibling
            }
            Ot = null
        }
    } else Ot = Mt ? xr(t.stateNode.nextSibling) : null;
    return !0
}

function _E() {
    for (var t = Ot; t;) t = xr(t.nextSibling)
}

function ks() {
    Ot = Mt = null, we = !1
}

function Qp(t) {
    on === null ? on = [t] : on.push(t)
}
var Tk = rr.ReactCurrentBatchConfig;

function Ao(t, e, n) {
    if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") {
        if (n._owner) {
            if (n = n._owner, n) {
                if (n.tag !== 1) throw Error(j(309));
                var r = n.stateNode
            }
            if (!r) throw Error(j(147, t));
            var i = r,
                s = "" + t;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = i.refs;
                o === null ? delete a[s] : a[s] = o
            }, e._stringRef = s, e)
        }
        if (typeof t != "string") throw Error(j(284));
        if (!n._owner) throw Error(j(290, t))
    }
    return t
}

function Dl(t, e) {
    throw t = Object.prototype.toString.call(e), Error(j(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
}

function Mv(t) {
    var e = t._init;
    return e(t._payload)
}

function wE(t) {
    function e(w, v) {
        if (t) {
            var T = w.deletions;
            T === null ? (w.deletions = [v], w.flags |= 16) : T.push(v)
        }
    }

    function n(w, v) {
        if (!t) return null;
        for (; v !== null;) e(w, v), v = v.sibling;
        return null
    }

    function r(w, v) {
        for (w = new Map; v !== null;) v.key !== null ? w.set(v.key, v) : w.set(v.index, v), v = v.sibling;
        return w
    }

    function i(w, v) {
        return w = Vr(w, v), w.index = 0, w.sibling = null, w
    }

    function s(w, v, T) {
        return w.index = T, t ? (T = w.alternate, T !== null ? (T = T.index, T < v ? (w.flags |= 2, v) : T) : (w.flags |= 2, v)) : (w.flags |= 1048576, v)
    }

    function o(w) {
        return t && w.alternate === null && (w.flags |= 2), w
    }

    function a(w, v, T, x) {
        return v === null || v.tag !== 6 ? (v = ld(T, w.mode, x), v.return = w, v) : (v = i(v, T), v.return = w, v)
    }

    function u(w, v, T, x) {
        var O = T.type;
        return O === es ? h(w, v, T.props.children, x, T.key) : v !== null && (v.elementType === O || typeof O == "object" && O !== null && O.$$typeof === pr && Mv(O) === v.type) ? (x = i(v, T.props), x.ref = Ao(w, v, T), x.return = w, x) : (x = ou(T.type, T.key, T.props, null, w.mode, x), x.ref = Ao(w, v, T), x.return = w, x)
    }

    function c(w, v, T, x) {
        return v === null || v.tag !== 4 || v.stateNode.containerInfo !== T.containerInfo || v.stateNode.implementation !== T.implementation ? (v = ud(T, w.mode, x), v.return = w, v) : (v = i(v, T.children || []), v.return = w, v)
    }

    function h(w, v, T, x, O) {
        return v === null || v.tag !== 7 ? (v = Ti(T, w.mode, x, O), v.return = w, v) : (v = i(v, T), v.return = w, v)
    }

    function f(w, v, T) {
        if (typeof v == "string" && v !== "" || typeof v == "number") return v = ld("" + v, w.mode, T), v.return = w, v;
        if (typeof v == "object" && v !== null) {
            switch (v.$$typeof) {
                case El:
                    return T = ou(v.type, v.key, v.props, null, w.mode, T), T.ref = Ao(w, null, v), T.return = w, T;
                case Zi:
                    return v = ud(v, w.mode, T), v.return = w, v;
                case pr:
                    var x = v._init;
                    return f(w, x(v._payload), T)
            }
            if (xo(v) || wo(v)) return v = Ti(v, w.mode, T, null), v.return = w, v;
            Dl(w, v)
        }
        return null
    }

    function m(w, v, T, x) {
        var O = v !== null ? v.key : null;
        if (typeof T == "string" && T !== "" || typeof T == "number") return O !== null ? null : a(w, v, "" + T, x);
        if (typeof T == "object" && T !== null) {
            switch (T.$$typeof) {
                case El:
                    return T.key === O ? u(w, v, T, x) : null;
                case Zi:
                    return T.key === O ? c(w, v, T, x) : null;
                case pr:
                    return O = T._init, m(w, v, O(T._payload), x)
            }
            if (xo(T) || wo(T)) return O !== null ? null : h(w, v, T, x, null);
            Dl(w, T)
        }
        return null
    }

    function _(w, v, T, x, O) {
        if (typeof x == "string" && x !== "" || typeof x == "number") return w = w.get(T) || null, a(v, w, "" + x, O);
        if (typeof x == "object" && x !== null) {
            switch (x.$$typeof) {
                case El:
                    return w = w.get(x.key === null ? T : x.key) || null, u(v, w, x, O);
                case Zi:
                    return w = w.get(x.key === null ? T : x.key) || null, c(v, w, x, O);
                case pr:
                    var U = x._init;
                    return _(w, v, T, U(x._payload), O)
            }
            if (xo(x) || wo(x)) return w = w.get(T) || null, h(v, w, x, O, null);
            Dl(v, x)
        }
        return null
    }

    function I(w, v, T, x) {
        for (var O = null, U = null, S = v, g = v = 0, E = null; S !== null && g < T.length; g++) {
            S.index > g ? (E = S, S = null) : E = S.sibling;
            var A = m(w, S, T[g], x);
            if (A === null) {
                S === null && (S = E);
                break
            }
            t && S && A.alternate === null && e(w, S), v = s(A, v, g), U === null ? O = A : U.sibling = A, U = A, S = E
        }
        if (g === T.length) return n(w, S), we && ui(w, g), O;
        if (S === null) {
            for (; g < T.length; g++) S = f(w, T[g], x), S !== null && (v = s(S, v, g), U === null ? O = S : U.sibling = S, U = S);
            return we && ui(w, g), O
        }
        for (S = r(w, S); g < T.length; g++) E = _(S, w, g, T[g], x), E !== null && (t && E.alternate !== null && S.delete(E.key === null ? g : E.key), v = s(E, v, g), U === null ? O = E : U.sibling = E, U = E);
        return t && S.forEach(function(C) {
            return e(w, C)
        }), we && ui(w, g), O
    }

    function R(w, v, T, x) {
        var O = wo(T);
        if (typeof O != "function") throw Error(j(150));
        if (T = O.call(T), T == null) throw Error(j(151));
        for (var U = O = null, S = v, g = v = 0, E = null, A = T.next(); S !== null && !A.done; g++, A = T.next()) {
            S.index > g ? (E = S, S = null) : E = S.sibling;
            var C = m(w, S, A.value, x);
            if (C === null) {
                S === null && (S = E);
                break
            }
            t && S && C.alternate === null && e(w, S), v = s(C, v, g), U === null ? O = C : U.sibling = C, U = C, S = E
        }
        if (A.done) return n(w, S), we && ui(w, g), O;
        if (S === null) {
            for (; !A.done; g++, A = T.next()) A = f(w, A.value, x), A !== null && (v = s(A, v, g), U === null ? O = A : U.sibling = A, U = A);
            return we && ui(w, g), O
        }
        for (S = r(w, S); !A.done; g++, A = T.next()) A = _(S, w, g, A.value, x), A !== null && (t && A.alternate !== null && S.delete(A.key === null ? g : A.key), v = s(A, v, g), U === null ? O = A : U.sibling = A, U = A);
        return t && S.forEach(function(b) {
            return e(w, b)
        }), we && ui(w, g), O
    }

    function k(w, v, T, x) {
        if (typeof T == "object" && T !== null && T.type === es && T.key === null && (T = T.props.children), typeof T == "object" && T !== null) {
            switch (T.$$typeof) {
                case El:
                    e: {
                        for (var O = T.key, U = v; U !== null;) {
                            if (U.key === O) {
                                if (O = T.type, O === es) {
                                    if (U.tag === 7) {
                                        n(w, U.sibling), v = i(U, T.props.children), v.return = w, w = v;
                                        break e
                                    }
                                } else if (U.elementType === O || typeof O == "object" && O !== null && O.$$typeof === pr && Mv(O) === U.type) {
                                    n(w, U.sibling), v = i(U, T.props), v.ref = Ao(w, U, T), v.return = w, w = v;
                                    break e
                                }
                                n(w, U);
                                break
                            } else e(w, U);
                            U = U.sibling
                        }
                        T.type === es ? (v = Ti(T.props.children, w.mode, x, T.key), v.return = w, w = v) : (x = ou(T.type, T.key, T.props, null, w.mode, x), x.ref = Ao(w, v, T), x.return = w, w = x)
                    }
                    return o(w);
                case Zi:
                    e: {
                        for (U = T.key; v !== null;) {
                            if (v.key === U)
                                if (v.tag === 4 && v.stateNode.containerInfo === T.containerInfo && v.stateNode.implementation === T.implementation) {
                                    n(w, v.sibling), v = i(v, T.children || []), v.return = w, w = v;
                                    break e
                                } else {
                                    n(w, v);
                                    break
                                }
                            else e(w, v);
                            v = v.sibling
                        }
                        v = ud(T, w.mode, x),
                        v.return = w,
                        w = v
                    }
                    return o(w);
                case pr:
                    return U = T._init, k(w, v, U(T._payload), x)
            }
            if (xo(T)) return I(w, v, T, x);
            if (wo(T)) return R(w, v, T, x);
            Dl(w, T)
        }
        return typeof T == "string" && T !== "" || typeof T == "number" ? (T = "" + T, v !== null && v.tag === 6 ? (n(w, v.sibling), v = i(v, T), v.return = w, w = v) : (n(w, v), v = ld(T, w.mode, x), v.return = w, w = v), o(w)) : n(w, v)
    }
    return k
}
var xs = wE(!0),
    TE = wE(!1),
    Vu = Qr(null),
    Ou = null,
    ls = null,
    Yp = null;

function Xp() {
    Yp = ls = Ou = null
}

function Jp(t) {
    var e = Vu.current;
    ve(Vu), t._currentValue = e
}

function _f(t, e, n) {
    for (; t !== null;) {
        var r = t.alternate;
        if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n) break;
        t = t.return
    }
}

function Ts(t, e) {
    Ou = t, Yp = ls = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (Pt = !0), t.firstContext = null)
}

function Jt(t) {
    var e = t._currentValue;
    if (Yp !== t)
        if (t = {
                context: t,
                memoizedValue: e,
                next: null
            }, ls === null) {
            if (Ou === null) throw Error(j(308));
            ls = t, Ou.dependencies = {
                lanes: 0,
                firstContext: t
            }
        } else ls = ls.next = t;
    return e
}
var mi = null;

function Zp(t) {
    mi === null ? mi = [t] : mi.push(t)
}

function EE(t, e, n, r) {
    var i = e.interleaved;
    return i === null ? (n.next = n, Zp(e)) : (n.next = i.next, i.next = n), e.interleaved = n, Yn(t, r)
}

function Yn(t, e) {
    t.lanes |= e;
    var n = t.alternate;
    for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;) t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return;
    return n.tag === 3 ? n.stateNode : null
}
var mr = !1;

function em(t) {
    t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}

function IE(t, e) {
    t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects
    })
}

function Bn(t, e) {
    return {
        eventTime: t,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}

function br(t, e, n) {
    var r = t.updateQueue;
    if (r === null) return null;
    if (r = r.shared, se & 2) {
        var i = r.pending;
        return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, Yn(t, n)
    }
    return i = r.interleaved, i === null ? (e.next = e, Zp(r)) : (e.next = i.next, i.next = e), r.interleaved = e, Yn(t, n)
}

function eu(t, e, n) {
    if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) {
        var r = e.lanes;
        r &= t.pendingLanes, n |= r, e.lanes = n, Up(t, n)
    }
}

function Fv(t, e) {
    var n = t.updateQueue,
        r = t.alternate;
    if (r !== null && (r = r.updateQueue, n === r)) {
        var i = null,
            s = null;
        if (n = n.firstBaseUpdate, n !== null) {
            do {
                var o = {
                    eventTime: n.eventTime,
                    lane: n.lane,
                    tag: n.tag,
                    payload: n.payload,
                    callback: n.callback,
                    next: null
                };
                s === null ? i = s = o : s = s.next = o, n = n.next
            } while (n !== null);
            s === null ? i = s = e : s = s.next = e
        } else i = s = e;
        n = {
            baseState: r.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: s,
            shared: r.shared,
            effects: r.effects
        }, t.updateQueue = n;
        return
    }
    t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e
}

function Lu(t, e, n, r) {
    var i = t.updateQueue;
    mr = !1;
    var s = i.firstBaseUpdate,
        o = i.lastBaseUpdate,
        a = i.shared.pending;
    if (a !== null) {
        i.shared.pending = null;
        var u = a,
            c = u.next;
        u.next = null, o === null ? s = c : o.next = c, o = u;
        var h = t.alternate;
        h !== null && (h = h.updateQueue, a = h.lastBaseUpdate, a !== o && (a === null ? h.firstBaseUpdate = c : a.next = c, h.lastBaseUpdate = u))
    }
    if (s !== null) {
        var f = i.baseState;
        o = 0, h = c = u = null, a = s;
        do {
            var m = a.lane,
                _ = a.eventTime;
            if ((r & m) === m) {
                h !== null && (h = h.next = {
                    eventTime: _,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var I = t,
                        R = a;
                    switch (m = e, _ = n, R.tag) {
                        case 1:
                            if (I = R.payload, typeof I == "function") {
                                f = I.call(_, f, m);
                                break e
                            }
                            f = I;
                            break e;
                        case 3:
                            I.flags = I.flags & -65537 | 128;
                        case 0:
                            if (I = R.payload, m = typeof I == "function" ? I.call(_, f, m) : I, m == null) break e;
                            f = Se({}, f, m);
                            break e;
                        case 2:
                            mr = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (t.flags |= 64, m = i.effects, m === null ? i.effects = [a] : m.push(a))
            } else _ = {
                eventTime: _,
                lane: m,
                tag: a.tag,
                payload: a.payload,
                callback: a.callback,
                next: null
            }, h === null ? (c = h = _, u = f) : h = h.next = _, o |= m;
            if (a = a.next, a === null) {
                if (a = i.shared.pending, a === null) break;
                m = a, a = m.next, m.next = null, i.lastBaseUpdate = m, i.shared.pending = null
            }
        } while (!0);
        if (h === null && (u = f), i.baseState = u, i.firstBaseUpdate = c, i.lastBaseUpdate = h, e = i.shared.interleaved, e !== null) {
            i = e;
            do o |= i.lane, i = i.next; while (i !== e)
        } else s === null && (i.shared.lanes = 0);
        Ci |= o, t.lanes = o, t.memoizedState = f
    }
}

function Uv(t, e, n) {
    if (t = e.effects, e.effects = null, t !== null)
        for (e = 0; e < t.length; e++) {
            var r = t[e],
                i = r.callback;
            if (i !== null) {
                if (r.callback = null, r = n, typeof i != "function") throw Error(j(191, i));
                i.call(r)
            }
        }
}
var za = {},
    _n = Qr(za),
    ya = Qr(za),
    va = Qr(za);

function gi(t) {
    if (t === za) throw Error(j(174));
    return t
}

function tm(t, e) {
    switch (fe(va, e), fe(ya, t), fe(_n, za), t = e.nodeType, t) {
        case 9:
        case 11:
            e = (e = e.documentElement) ? e.namespaceURI : Jd(null, "");
            break;
        default:
            t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = Jd(e, t)
    }
    ve(_n), fe(_n, e)
}

function bs() {
    ve(_n), ve(ya), ve(va)
}

function SE(t) {
    gi(va.current);
    var e = gi(_n.current),
        n = Jd(e, t.type);
    e !== n && (fe(ya, t), fe(_n, n))
}

function nm(t) {
    ya.current === t && (ve(_n), ve(ya))
}
var Te = Qr(0);

function Mu(t) {
    for (var e = t; e !== null;) {
        if (e.tag === 13) {
            var n = e.memoizedState;
            if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128) return e
        } else if (e.child !== null) {
            e.child.return = e, e = e.child;
            continue
        }
        if (e === t) break;
        for (; e.sibling === null;) {
            if (e.return === null || e.return === t) return null;
            e = e.return
        }
        e.sibling.return = e.return, e = e.sibling
    }
    return null
}
var nd = [];

function rm() {
    for (var t = 0; t < nd.length; t++) nd[t]._workInProgressVersionPrimary = null;
    nd.length = 0
}
var tu = rr.ReactCurrentDispatcher,
    rd = rr.ReactCurrentBatchConfig,
    Ri = 0,
    Ie = null,
    Le = null,
    Be = null,
    Fu = !1,
    qo = !1,
    _a = 0,
    Ek = 0;

function nt() {
    throw Error(j(321))
}

function im(t, e) {
    if (e === null) return !1;
    for (var n = 0; n < e.length && n < t.length; n++)
        if (!cn(t[n], e[n])) return !1;
    return !0
}

function sm(t, e, n, r, i, s) {
    if (Ri = s, Ie = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, tu.current = t === null || t.memoizedState === null ? Pk : Rk, t = n(r, i), qo) {
        s = 0;
        do {
            if (qo = !1, _a = 0, 25 <= s) throw Error(j(301));
            s += 1, Be = Le = null, e.updateQueue = null, tu.current = Ck, t = n(r, i)
        } while (qo)
    }
    if (tu.current = Uu, e = Le !== null && Le.next !== null, Ri = 0, Be = Le = Ie = null, Fu = !1, e) throw Error(j(300));
    return t
}

function om() {
    var t = _a !== 0;
    return _a = 0, t
}

function mn() {
    var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Be === null ? Ie.memoizedState = Be = t : Be = Be.next = t, Be
}

function Zt() {
    if (Le === null) {
        var t = Ie.alternate;
        t = t !== null ? t.memoizedState : null
    } else t = Le.next;
    var e = Be === null ? Ie.memoizedState : Be.next;
    if (e !== null) Be = e, Le = t;
    else {
        if (t === null) throw Error(j(310));
        Le = t, t = {
            memoizedState: Le.memoizedState,
            baseState: Le.baseState,
            baseQueue: Le.baseQueue,
            queue: Le.queue,
            next: null
        }, Be === null ? Ie.memoizedState = Be = t : Be = Be.next = t
    }
    return Be
}

function wa(t, e) {
    return typeof e == "function" ? e(t) : e
}

function id(t) {
    var e = Zt(),
        n = e.queue;
    if (n === null) throw Error(j(311));
    n.lastRenderedReducer = t;
    var r = Le,
        i = r.baseQueue,
        s = n.pending;
    if (s !== null) {
        if (i !== null) {
            var o = i.next;
            i.next = s.next, s.next = o
        }
        r.baseQueue = i = s, n.pending = null
    }
    if (i !== null) {
        s = i.next, r = r.baseState;
        var a = o = null,
            u = null,
            c = s;
        do {
            var h = c.lane;
            if ((Ri & h) === h) u !== null && (u = u.next = {
                lane: 0,
                action: c.action,
                hasEagerState: c.hasEagerState,
                eagerState: c.eagerState,
                next: null
            }), r = c.hasEagerState ? c.eagerState : t(r, c.action);
            else {
                var f = {
                    lane: h,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                u === null ? (a = u = f, o = r) : u = u.next = f, Ie.lanes |= h, Ci |= h
            }
            c = c.next
        } while (c !== null && c !== s);
        u === null ? o = r : u.next = a, cn(r, e.memoizedState) || (Pt = !0), e.memoizedState = r, e.baseState = o, e.baseQueue = u, n.lastRenderedState = r
    }
    if (t = n.interleaved, t !== null) {
        i = t;
        do s = i.lane, Ie.lanes |= s, Ci |= s, i = i.next; while (i !== t)
    } else i === null && (n.lanes = 0);
    return [e.memoizedState, n.dispatch]
}

function sd(t) {
    var e = Zt(),
        n = e.queue;
    if (n === null) throw Error(j(311));
    n.lastRenderedReducer = t;
    var r = n.dispatch,
        i = n.pending,
        s = e.memoizedState;
    if (i !== null) {
        n.pending = null;
        var o = i = i.next;
        do s = t(s, o.action), o = o.next; while (o !== i);
        cn(s, e.memoizedState) || (Pt = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), n.lastRenderedState = s
    }
    return [s, r]
}

function AE() {}

function PE(t, e) {
    var n = Ie,
        r = Zt(),
        i = e(),
        s = !cn(r.memoizedState, i);
    if (s && (r.memoizedState = i, Pt = !0), r = r.queue, am(kE.bind(null, n, r, t), [t]), r.getSnapshot !== e || s || Be !== null && Be.memoizedState.tag & 1) {
        if (n.flags |= 2048, Ta(9, CE.bind(null, n, r, i, e), void 0, null), $e === null) throw Error(j(349));
        Ri & 30 || RE(n, e, i)
    }
    return i
}

function RE(t, e, n) {
    t.flags |= 16384, t = {
        getSnapshot: e,
        value: n
    }, e = Ie.updateQueue, e === null ? (e = {
        lastEffect: null,
        stores: null
    }, Ie.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t))
}

function CE(t, e, n, r) {
    e.value = n, e.getSnapshot = r, xE(e) && bE(t)
}

function kE(t, e, n) {
    return n(function() {
        xE(e) && bE(t)
    })
}

function xE(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var n = e();
        return !cn(t, n)
    } catch {
        return !0
    }
}

function bE(t) {
    var e = Yn(t, 1);
    e !== null && un(e, t, 1, -1)
}

function jv(t) {
    var e = mn();
    return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: wa,
        lastRenderedState: t
    }, e.queue = t, t = t.dispatch = Ak.bind(null, Ie, t), [e.memoizedState, t]
}

function Ta(t, e, n, r) {
    return t = {
        tag: t,
        create: e,
        destroy: n,
        deps: r,
        next: null
    }, e = Ie.updateQueue, e === null ? (e = {
        lastEffect: null,
        stores: null
    }, Ie.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t
}

function NE() {
    return Zt().memoizedState
}

function nu(t, e, n, r) {
    var i = mn();
    Ie.flags |= t, i.memoizedState = Ta(1 | e, n, void 0, r === void 0 ? null : r)
}

function kc(t, e, n, r) {
    var i = Zt();
    r = r === void 0 ? null : r;
    var s = void 0;
    if (Le !== null) {
        var o = Le.memoizedState;
        if (s = o.destroy, r !== null && im(r, o.deps)) {
            i.memoizedState = Ta(e, n, s, r);
            return
        }
    }
    Ie.flags |= t, i.memoizedState = Ta(1 | e, n, s, r)
}

function Bv(t, e) {
    return nu(8390656, 8, t, e)
}

function am(t, e) {
    return kc(2048, 8, t, e)
}

function DE(t, e) {
    return kc(4, 2, t, e)
}

function VE(t, e) {
    return kc(4, 4, t, e)
}

function OE(t, e) {
    if (typeof e == "function") return t = t(), e(t),
        function() {
            e(null)
        };
    if (e != null) return t = t(), e.current = t,
        function() {
            e.current = null
        }
}

function LE(t, e, n) {
    return n = n != null ? n.concat([t]) : null, kc(4, 4, OE.bind(null, e, t), n)
}

function lm() {}

function ME(t, e) {
    var n = Zt();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && im(e, r[1]) ? r[0] : (n.memoizedState = [t, e], t)
}

function FE(t, e) {
    var n = Zt();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && im(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [t, e], t)
}

function UE(t, e, n) {
    return Ri & 21 ? (cn(n, e) || (n = WT(), Ie.lanes |= n, Ci |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, Pt = !0), t.memoizedState = n)
}

function Ik(t, e) {
    var n = ce;
    ce = n !== 0 && 4 > n ? n : 4, t(!0);
    var r = rd.transition;
    rd.transition = {};
    try {
        t(!1), e()
    } finally {
        ce = n, rd.transition = r
    }
}

function jE() {
    return Zt().memoizedState
}

function Sk(t, e, n) {
    var r = Dr(t);
    if (n = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, BE(t)) $E(e, n);
    else if (n = EE(t, e, n, r), n !== null) {
        var i = vt();
        un(n, t, r, i), zE(n, e, r)
    }
}

function Ak(t, e, n) {
    var r = Dr(t),
        i = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
    if (BE(t)) $E(e, i);
    else {
        var s = t.alternate;
        if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try {
            var o = e.lastRenderedState,
                a = s(o, n);
            if (i.hasEagerState = !0, i.eagerState = a, cn(a, o)) {
                var u = e.interleaved;
                u === null ? (i.next = i, Zp(e)) : (i.next = u.next, u.next = i), e.interleaved = i;
                return
            }
        } catch {} finally {}
        n = EE(t, e, i, r), n !== null && (i = vt(), un(n, t, r, i), zE(n, e, r))
    }
}

function BE(t) {
    var e = t.alternate;
    return t === Ie || e !== null && e === Ie
}

function $E(t, e) {
    qo = Fu = !0;
    var n = t.pending;
    n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e
}

function zE(t, e, n) {
    if (n & 4194240) {
        var r = e.lanes;
        r &= t.pendingLanes, n |= r, e.lanes = n, Up(t, n)
    }
}
var Uu = {
        readContext: Jt,
        useCallback: nt,
        useContext: nt,
        useEffect: nt,
        useImperativeHandle: nt,
        useInsertionEffect: nt,
        useLayoutEffect: nt,
        useMemo: nt,
        useReducer: nt,
        useRef: nt,
        useState: nt,
        useDebugValue: nt,
        useDeferredValue: nt,
        useTransition: nt,
        useMutableSource: nt,
        useSyncExternalStore: nt,
        useId: nt,
        unstable_isNewReconciler: !1
    },
    Pk = {
        readContext: Jt,
        useCallback: function(t, e) {
            return mn().memoizedState = [t, e === void 0 ? null : e], t
        },
        useContext: Jt,
        useEffect: Bv,
        useImperativeHandle: function(t, e, n) {
            return n = n != null ? n.concat([t]) : null, nu(4194308, 4, OE.bind(null, e, t), n)
        },
        useLayoutEffect: function(t, e) {
            return nu(4194308, 4, t, e)
        },
        useInsertionEffect: function(t, e) {
            return nu(4, 2, t, e)
        },
        useMemo: function(t, e) {
            var n = mn();
            return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t
        },
        useReducer: function(t, e, n) {
            var r = mn();
            return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: t,
                lastRenderedState: e
            }, r.queue = t, t = t.dispatch = Sk.bind(null, Ie, t), [r.memoizedState, t]
        },
        useRef: function(t) {
            var e = mn();
            return t = {
                current: t
            }, e.memoizedState = t
        },
        useState: jv,
        useDebugValue: lm,
        useDeferredValue: function(t) {
            return mn().memoizedState = t
        },
        useTransition: function() {
            var t = jv(!1),
                e = t[0];
            return t = Ik.bind(null, t[1]), mn().memoizedState = t, [e, t]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(t, e, n) {
            var r = Ie,
                i = mn();
            if (we) {
                if (n === void 0) throw Error(j(407));
                n = n()
            } else {
                if (n = e(), $e === null) throw Error(j(349));
                Ri & 30 || RE(r, e, n)
            }
            i.memoizedState = n;
            var s = {
                value: n,
                getSnapshot: e
            };
            return i.queue = s, Bv(kE.bind(null, r, s, t), [t]), r.flags |= 2048, Ta(9, CE.bind(null, r, s, n, e), void 0, null), n
        },
        useId: function() {
            var t = mn(),
                e = $e.identifierPrefix;
            if (we) {
                var n = Ln,
                    r = On;
                n = (r & ~(1 << 32 - ln(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = _a++, 0 < n && (e += "H" + n.toString(32)), e += ":"
            } else n = Ek++, e = ":" + e + "r" + n.toString(32) + ":";
            return t.memoizedState = e
        },
        unstable_isNewReconciler: !1
    },
    Rk = {
        readContext: Jt,
        useCallback: ME,
        useContext: Jt,
        useEffect: am,
        useImperativeHandle: LE,
        useInsertionEffect: DE,
        useLayoutEffect: VE,
        useMemo: FE,
        useReducer: id,
        useRef: NE,
        useState: function() {
            return id(wa)
        },
        useDebugValue: lm,
        useDeferredValue: function(t) {
            var e = Zt();
            return UE(e, Le.memoizedState, t)
        },
        useTransition: function() {
            var t = id(wa)[0],
                e = Zt().memoizedState;
            return [t, e]
        },
        useMutableSource: AE,
        useSyncExternalStore: PE,
        useId: jE,
        unstable_isNewReconciler: !1
    },
    Ck = {
        readContext: Jt,
        useCallback: ME,
        useContext: Jt,
        useEffect: am,
        useImperativeHandle: LE,
        useInsertionEffect: DE,
        useLayoutEffect: VE,
        useMemo: FE,
        useReducer: sd,
        useRef: NE,
        useState: function() {
            return sd(wa)
        },
        useDebugValue: lm,
        useDeferredValue: function(t) {
            var e = Zt();
            return Le === null ? e.memoizedState = t : UE(e, Le.memoizedState, t)
        },
        useTransition: function() {
            var t = sd(wa)[0],
                e = Zt().memoizedState;
            return [t, e]
        },
        useMutableSource: AE,
        useSyncExternalStore: PE,
        useId: jE,
        unstable_isNewReconciler: !1
    };

function rn(t, e) {
    if (t && t.defaultProps) {
        e = Se({}, e), t = t.defaultProps;
        for (var n in t) e[n] === void 0 && (e[n] = t[n]);
        return e
    }
    return e
}

function wf(t, e, n, r) {
    e = t.memoizedState, n = n(r, e), n = n == null ? e : Se({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n)
}
var xc = {
    isMounted: function(t) {
        return (t = t._reactInternals) ? Oi(t) === t : !1
    },
    enqueueSetState: function(t, e, n) {
        t = t._reactInternals;
        var r = vt(),
            i = Dr(t),
            s = Bn(r, i);
        s.payload = e, n != null && (s.callback = n), e = br(t, s, i), e !== null && (un(e, t, i, r), eu(e, t, i))
    },
    enqueueReplaceState: function(t, e, n) {
        t = t._reactInternals;
        var r = vt(),
            i = Dr(t),
            s = Bn(r, i);
        s.tag = 1, s.payload = e, n != null && (s.callback = n), e = br(t, s, i), e !== null && (un(e, t, i, r), eu(e, t, i))
    },
    enqueueForceUpdate: function(t, e) {
        t = t._reactInternals;
        var n = vt(),
            r = Dr(t),
            i = Bn(n, r);
        i.tag = 2, e != null && (i.callback = e), e = br(t, i, r), e !== null && (un(e, t, r, n), eu(e, t, r))
    }
};

function $v(t, e, n, r, i, s, o) {
    return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, s, o) : e.prototype && e.prototype.isPureReactComponent ? !fa(n, r) || !fa(i, s) : !0
}

function WE(t, e, n) {
    var r = !1,
        i = Fr,
        s = e.contextType;
    return typeof s == "object" && s !== null ? s = Jt(s) : (i = Ct(e) ? Ai : ft.current, r = e.contextTypes, s = (r = r != null) ? Cs(t, i) : Fr), e = new e(n, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = xc, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = s), e
}

function zv(t, e, n, r) {
    t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && xc.enqueueReplaceState(e, e.state, null)
}

function Tf(t, e, n, r) {
    var i = t.stateNode;
    i.props = n, i.state = t.memoizedState, i.refs = {}, em(t);
    var s = e.contextType;
    typeof s == "object" && s !== null ? i.context = Jt(s) : (s = Ct(e) ? Ai : ft.current, i.context = Cs(t, s)), i.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (wf(t, e, s, n), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && xc.enqueueReplaceState(i, i.state, null), Lu(t, n, i, r), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308)
}

function Ns(t, e) {
    try {
        var n = "",
            r = e;
        do n += nC(r), r = r.return; while (r);
        var i = n
    } catch (s) {
        i = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: t,
        source: e,
        stack: i,
        digest: null
    }
}

function od(t, e, n) {
    return {
        value: t,
        source: null,
        stack: n ? ? null,
        digest: e ? ? null
    }
}

function Ef(t, e) {
    try {
        console.error(e.value)
    } catch (n) {
        setTimeout(function() {
            throw n
        })
    }
}
var kk = typeof WeakMap == "function" ? WeakMap : Map;

function qE(t, e, n) {
    n = Bn(-1, n), n.tag = 3, n.payload = {
        element: null
    };
    var r = e.value;
    return n.callback = function() {
        Bu || (Bu = !0, Nf = r), Ef(t, e)
    }, n
}

function HE(t, e, n) {
    n = Bn(-1, n), n.tag = 3;
    var r = t.type.getDerivedStateFromError;
    if (typeof r == "function") {
        var i = e.value;
        n.payload = function() {
            return r(i)
        }, n.callback = function() {
            Ef(t, e)
        }
    }
    var s = t.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function() {
        Ef(t, e), typeof r != "function" && (Nr === null ? Nr = new Set([this]) : Nr.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }), n
}

function Wv(t, e, n) {
    var r = t.pingCache;
    if (r === null) {
        r = t.pingCache = new kk;
        var i = new Set;
        r.set(e, i)
    } else i = r.get(e), i === void 0 && (i = new Set, r.set(e, i));
    i.has(n) || (i.add(n), t = zk.bind(null, t, e, n), e.then(t, t))
}

function qv(t) {
    do {
        var e;
        if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t;
        t = t.return
    } while (t !== null);
    return null
}

function Hv(t, e, n, r, i) {
    return t.mode & 1 ? (t.flags |= 65536, t.lanes = i, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = Bn(-1, 1), e.tag = 2, br(n, e, 1))), n.lanes |= 1), t)
}
var xk = rr.ReactCurrentOwner,
    Pt = !1;

function yt(t, e, n, r) {
    e.child = t === null ? TE(e, null, n, r) : xs(e, t.child, n, r)
}

function Kv(t, e, n, r, i) {
    n = n.render;
    var s = e.ref;
    return Ts(e, i), r = sm(t, e, n, r, s, i), n = om(), t !== null && !Pt ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Xn(t, e, i)) : (we && n && Kp(e), e.flags |= 1, yt(t, e, r, i), e.child)
}

function Gv(t, e, n, r, i) {
    if (t === null) {
        var s = n.type;
        return typeof s == "function" && !gm(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = s, KE(t, e, s, r, i)) : (t = ou(n.type, null, r, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t)
    }
    if (s = t.child, !(t.lanes & i)) {
        var o = s.memoizedProps;
        if (n = n.compare, n = n !== null ? n : fa, n(o, r) && t.ref === e.ref) return Xn(t, e, i)
    }
    return e.flags |= 1, t = Vr(s, r), t.ref = e.ref, t.return = e, e.child = t
}

function KE(t, e, n, r, i) {
    if (t !== null) {
        var s = t.memoizedProps;
        if (fa(s, r) && t.ref === e.ref)
            if (Pt = !1, e.pendingProps = r = s, (t.lanes & i) !== 0) t.flags & 131072 && (Pt = !0);
            else return e.lanes = t.lanes, Xn(t, e, i)
    }
    return If(t, e, n, r, i)
}

function GE(t, e, n) {
    var r = e.pendingProps,
        i = r.children,
        s = t !== null ? t.memoizedState : null;
    if (r.mode === "hidden")
        if (!(e.mode & 1)) e.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
        }, fe(cs, Vt), Vt |= n;
        else {
            if (!(n & 1073741824)) return t = s !== null ? s.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
                baseLanes: t,
                cachePool: null,
                transitions: null
            }, e.updateQueue = null, fe(cs, Vt), Vt |= t, null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, r = s !== null ? s.baseLanes : n, fe(cs, Vt), Vt |= r
        }
    else s !== null ? (r = s.baseLanes | n, e.memoizedState = null) : r = n, fe(cs, Vt), Vt |= r;
    return yt(t, e, i, n), e.child
}

function QE(t, e) {
    var n = e.ref;
    (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152)
}

function If(t, e, n, r, i) {
    var s = Ct(n) ? Ai : ft.current;
    return s = Cs(e, s), Ts(e, i), n = sm(t, e, n, r, s, i), r = om(), t !== null && !Pt ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Xn(t, e, i)) : (we && r && Kp(e), e.flags |= 1, yt(t, e, n, i), e.child)
}

function Qv(t, e, n, r, i) {
    if (Ct(n)) {
        var s = !0;
        bu(e)
    } else s = !1;
    if (Ts(e, i), e.stateNode === null) ru(t, e), WE(e, n, r), Tf(e, n, r, i), r = !0;
    else if (t === null) {
        var o = e.stateNode,
            a = e.memoizedProps;
        o.props = a;
        var u = o.context,
            c = n.contextType;
        typeof c == "object" && c !== null ? c = Jt(c) : (c = Ct(n) ? Ai : ft.current, c = Cs(e, c));
        var h = n.getDerivedStateFromProps,
            f = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        f || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || u !== c) && zv(e, o, r, c), mr = !1;
        var m = e.memoizedState;
        o.state = m, Lu(e, r, o, i), u = e.memoizedState, a !== r || m !== u || Rt.current || mr ? (typeof h == "function" && (wf(e, n, h, r), u = e.memoizedState), (a = mr || $v(e, n, a, r, m, u, c)) ? (f || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = u), o.props = r, o.state = u, o.context = c, r = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), r = !1)
    } else {
        o = e.stateNode, IE(t, e), a = e.memoizedProps, c = e.type === e.elementType ? a : rn(e.type, a), o.props = c, f = e.pendingProps, m = o.context, u = n.contextType, typeof u == "object" && u !== null ? u = Jt(u) : (u = Ct(n) ? Ai : ft.current, u = Cs(e, u));
        var _ = n.getDerivedStateFromProps;
        (h = typeof _ == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== f || m !== u) && zv(e, o, r, u), mr = !1, m = e.memoizedState, o.state = m, Lu(e, r, o, i);
        var I = e.memoizedState;
        a !== f || m !== I || Rt.current || mr ? (typeof _ == "function" && (wf(e, n, _, r), I = e.memoizedState), (c = mr || $v(e, n, c, r, m, I, u) || !1) ? (h || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, I, u), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, I, u)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && m === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && m === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = I), o.props = r, o.state = I, o.context = u, r = c) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && m === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && m === t.memoizedState || (e.flags |= 1024), r = !1)
    }
    return Sf(t, e, n, r, s, i)
}

function Sf(t, e, n, r, i, s) {
    QE(t, e);
    var o = (e.flags & 128) !== 0;
    if (!r && !o) return i && Vv(e, n, !1), Xn(t, e, s);
    r = e.stateNode, xk.current = e;
    var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render();
    return e.flags |= 1, t !== null && o ? (e.child = xs(e, t.child, null, s), e.child = xs(e, null, a, s)) : yt(t, e, a, s), e.memoizedState = r.state, i && Vv(e, n, !0), e.child
}

function YE(t) {
    var e = t.stateNode;
    e.pendingContext ? Dv(t, e.pendingContext, e.pendingContext !== e.context) : e.context && Dv(t, e.context, !1), tm(t, e.containerInfo)
}

function Yv(t, e, n, r, i) {
    return ks(), Qp(i), e.flags |= 256, yt(t, e, n, r), e.child
}
var Af = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};

function Pf(t) {
    return {
        baseLanes: t,
        cachePool: null,
        transitions: null
    }
}

function XE(t, e, n) {
    var r = e.pendingProps,
        i = Te.current,
        s = !1,
        o = (e.flags & 128) !== 0,
        a;
    if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), fe(Te, i & 1), t === null) return vf(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = r.children, t = r.fallback, s ? (r = e.mode, s = e.child, o = {
        mode: "hidden",
        children: o
    }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = Dc(o, r, 0, null), t = Ti(t, r, n, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = Pf(n), e.memoizedState = Af, t) : um(e, o));
    if (i = t.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return bk(t, e, o, r, a, i, n);
    if (s) {
        s = r.fallback, o = e.mode, i = t.child, a = i.sibling;
        var u = {
            mode: "hidden",
            children: r.children
        };
        return !(o & 1) && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = u, e.deletions = null) : (r = Vr(i, u), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = Vr(a, s) : (s = Ti(s, o, n, null), s.flags |= 2), s.return = e, r.return = e, r.sibling = s, e.child = r, r = s, s = e.child, o = t.child.memoizedState, o = o === null ? Pf(n) : {
            baseLanes: o.baseLanes | n,
            cachePool: null,
            transitions: o.transitions
        }, s.memoizedState = o, s.childLanes = t.childLanes & ~n, e.memoizedState = Af, r
    }
    return s = t.child, t = s.sibling, r = Vr(s, {
        mode: "visible",
        children: r.children
    }), !(e.mode & 1) && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r
}

function um(t, e) {
    return e = Dc({
        mode: "visible",
        children: e
    }, t.mode, 0, null), e.return = t, t.child = e
}

function Vl(t, e, n, r) {
    return r !== null && Qp(r), xs(e, t.child, null, n), t = um(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t
}

function bk(t, e, n, r, i, s, o) {
    if (n) return e.flags & 256 ? (e.flags &= -257, r = od(Error(j(422))), Vl(t, e, o, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = r.fallback, i = e.mode, r = Dc({
        mode: "visible",
        children: r.children
    }, i, 0, null), s = Ti(s, i, o, null), s.flags |= 2, r.return = e, s.return = e, r.sibling = s, e.child = r, e.mode & 1 && xs(e, t.child, null, o), e.child.memoizedState = Pf(o), e.memoizedState = Af, s);
    if (!(e.mode & 1)) return Vl(t, e, o, null);
    if (i.data === "$!") {
        if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst;
        return r = a, s = Error(j(419)), r = od(s, r, void 0), Vl(t, e, o, r)
    }
    if (a = (o & t.childLanes) !== 0, Pt || a) {
        if (r = $e, r !== null) {
            switch (o & -o) {
                case 4:
                    i = 2;
                    break;
                case 16:
                    i = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    i = 32;
                    break;
                case 536870912:
                    i = 268435456;
                    break;
                default:
                    i = 0
            }
            i = i & (r.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, Yn(t, i), un(r, t, i, -1))
        }
        return mm(), r = od(Error(j(421))), Vl(t, e, o, r)
    }
    return i.data === "$?" ? (e.flags |= 128, e.child = t.child, e = Wk.bind(null, t), i._reactRetry = e, null) : (t = s.treeContext, Ot = xr(i.nextSibling), Mt = e, we = !0, on = null, t !== null && (Kt[Gt++] = On, Kt[Gt++] = Ln, Kt[Gt++] = Pi, On = t.id, Ln = t.overflow, Pi = e), e = um(e, r.children), e.flags |= 4096, e)
}

function Xv(t, e, n) {
    t.lanes |= e;
    var r = t.alternate;
    r !== null && (r.lanes |= e), _f(t.return, e, n)
}

function ad(t, e, n, r, i) {
    var s = t.memoizedState;
    s === null ? t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i
    } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i)
}

function JE(t, e, n) {
    var r = e.pendingProps,
        i = r.revealOrder,
        s = r.tail;
    if (yt(t, e, r.children, n), r = Te.current, r & 2) r = r & 1 | 2, e.flags |= 128;
    else {
        if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) {
            if (t.tag === 13) t.memoizedState !== null && Xv(t, n, e);
            else if (t.tag === 19) Xv(t, n, e);
            else if (t.child !== null) {
                t.child.return = t, t = t.child;
                continue
            }
            if (t === e) break e;
            for (; t.sibling === null;) {
                if (t.return === null || t.return === e) break e;
                t = t.return
            }
            t.sibling.return = t.return, t = t.sibling
        }
        r &= 1
    }
    if (fe(Te, r), !(e.mode & 1)) e.memoizedState = null;
    else switch (i) {
        case "forwards":
            for (n = e.child, i = null; n !== null;) t = n.alternate, t !== null && Mu(t) === null && (i = n), n = n.sibling;
            n = i, n === null ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), ad(e, !1, i, n, s);
            break;
        case "backwards":
            for (n = null, i = e.child, e.child = null; i !== null;) {
                if (t = i.alternate, t !== null && Mu(t) === null) {
                    e.child = i;
                    break
                }
                t = i.sibling, i.sibling = n, n = i, i = t
            }
            ad(e, !0, n, null, s);
            break;
        case "together":
            ad(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
    }
    return e.child
}

function ru(t, e) {
    !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2)
}

function Xn(t, e, n) {
    if (t !== null && (e.dependencies = t.dependencies), Ci |= e.lanes, !(n & e.childLanes)) return null;
    if (t !== null && e.child !== t.child) throw Error(j(153));
    if (e.child !== null) {
        for (t = e.child, n = Vr(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;) t = t.sibling, n = n.sibling = Vr(t, t.pendingProps), n.return = e;
        n.sibling = null
    }
    return e.child
}

function Nk(t, e, n) {
    switch (e.tag) {
        case 3:
            YE(e), ks();
            break;
        case 5:
            SE(e);
            break;
        case 1:
            Ct(e.type) && bu(e);
            break;
        case 4:
            tm(e, e.stateNode.containerInfo);
            break;
        case 10:
            var r = e.type._context,
                i = e.memoizedProps.value;
            fe(Vu, r._currentValue), r._currentValue = i;
            break;
        case 13:
            if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (fe(Te, Te.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? XE(t, e, n) : (fe(Te, Te.current & 1), t = Xn(t, e, n), t !== null ? t.sibling : null);
            fe(Te, Te.current & 1);
            break;
        case 19:
            if (r = (n & e.childLanes) !== 0, t.flags & 128) {
                if (r) return JE(t, e, n);
                e.flags |= 128
            }
            if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), fe(Te, Te.current), r) break;
            return null;
        case 22:
        case 23:
            return e.lanes = 0, GE(t, e, n)
    }
    return Xn(t, e, n)
}
var ZE, Rf, eI, tI;
ZE = function(t, e) {
    for (var n = e.child; n !== null;) {
        if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
        else if (n.tag !== 4 && n.child !== null) {
            n.child.return = n, n = n.child;
            continue
        }
        if (n === e) break;
        for (; n.sibling === null;) {
            if (n.return === null || n.return === e) return;
            n = n.return
        }
        n.sibling.return = n.return, n = n.sibling
    }
};
Rf = function() {};
eI = function(t, e, n, r) {
    var i = t.memoizedProps;
    if (i !== r) {
        t = e.stateNode, gi(_n.current);
        var s = null;
        switch (n) {
            case "input":
                i = Gd(t, i), r = Gd(t, r), s = [];
                break;
            case "select":
                i = Se({}, i, {
                    value: void 0
                }), r = Se({}, r, {
                    value: void 0
                }), s = [];
                break;
            case "textarea":
                i = Xd(t, i), r = Xd(t, r), s = [];
                break;
            default:
                typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = ku)
        }
        Zd(n, r);
        var o;
        n = null;
        for (c in i)
            if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
                if (c === "style") {
                    var a = i[c];
                    for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "")
                } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (oa.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null));
        for (c in r) {
            var u = r[c];
            if (a = i != null ? i[c] : void 0, r.hasOwnProperty(c) && u !== a && (u != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a) !a.hasOwnProperty(o) || u && u.hasOwnProperty(o) || (n || (n = {}), n[o] = "");
                        for (o in u) u.hasOwnProperty(o) && a[o] !== u[o] && (n || (n = {}), n[o] = u[o])
                    } else n || (s || (s = []), s.push(c, n)), n = u;
            else c === "dangerouslySetInnerHTML" ? (u = u ? u.__html : void 0, a = a ? a.__html : void 0, u != null && a !== u && (s = s || []).push(c, u)) : c === "children" ? typeof u != "string" && typeof u != "number" || (s = s || []).push(c, "" + u) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (oa.hasOwnProperty(c) ? (u != null && c === "onScroll" && ge("scroll", t), s || a === u || (s = [])) : (s = s || []).push(c, u))
        }
        n && (s = s || []).push("style", n);
        var c = s;
        (e.updateQueue = c) && (e.flags |= 4)
    }
};
tI = function(t, e, n, r) {
    n !== r && (e.flags |= 4)
};

function Po(t, e) {
    if (!we) switch (t.tailMode) {
        case "hidden":
            e = t.tail;
            for (var n = null; e !== null;) e.alternate !== null && (n = e), e = e.sibling;
            n === null ? t.tail = null : n.sibling = null;
            break;
        case "collapsed":
            n = t.tail;
            for (var r = null; n !== null;) n.alternate !== null && (r = n), n = n.sibling;
            r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null
    }
}

function rt(t) {
    var e = t.alternate !== null && t.alternate.child === t.child,
        n = 0,
        r = 0;
    if (e)
        for (var i = t.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = t, i = i.sibling;
    else
        for (i = t.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = t, i = i.sibling;
    return t.subtreeFlags |= r, t.childLanes = n, e
}

function Dk(t, e, n) {
    var r = e.pendingProps;
    switch (Gp(e), e.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return rt(e), null;
        case 1:
            return Ct(e.type) && xu(), rt(e), null;
        case 3:
            return r = e.stateNode, bs(), ve(Rt), ve(ft), rm(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (Nl(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, on !== null && (Of(on), on = null))), Rf(t, e), rt(e), null;
        case 5:
            nm(e);
            var i = gi(va.current);
            if (n = e.type, t !== null && e.stateNode != null) eI(t, e, n, r, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
            else {
                if (!r) {
                    if (e.stateNode === null) throw Error(j(166));
                    return rt(e), null
                }
                if (t = gi(_n.current), Nl(e)) {
                    r = e.stateNode, n = e.type;
                    var s = e.memoizedProps;
                    switch (r[gn] = e, r[ga] = s, t = (e.mode & 1) !== 0, n) {
                        case "dialog":
                            ge("cancel", r), ge("close", r);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            ge("load", r);
                            break;
                        case "video":
                        case "audio":
                            for (i = 0; i < No.length; i++) ge(No[i], r);
                            break;
                        case "source":
                            ge("error", r);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            ge("error", r), ge("load", r);
                            break;
                        case "details":
                            ge("toggle", r);
                            break;
                        case "input":
                            ov(r, s), ge("invalid", r);
                            break;
                        case "select":
                            r._wrapperState = {
                                wasMultiple: !!s.multiple
                            }, ge("invalid", r);
                            break;
                        case "textarea":
                            lv(r, s), ge("invalid", r)
                    }
                    Zd(n, s), i = null;
                    for (var o in s)
                        if (s.hasOwnProperty(o)) {
                            var a = s[o];
                            o === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && bl(r.textContent, a, t), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && bl(r.textContent, a, t), i = ["children", "" + a]) : oa.hasOwnProperty(o) && a != null && o === "onScroll" && ge("scroll", r)
                        }
                    switch (n) {
                        case "input":
                            Il(r), av(r, s, !0);
                            break;
                        case "textarea":
                            Il(r), uv(r);
                            break;
                        case "select":
                        case "option":
                            break;
                        default:
                            typeof s.onClick == "function" && (r.onclick = ku)
                    }
                    r = i, e.updateQueue = r, r !== null && (e.flags |= 4)
                } else {
                    o = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = kT(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = o.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = o.createElement(n, {
                        is: r.is
                    }) : (t = o.createElement(n), n === "select" && (o = t, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : t = o.createElementNS(t, n), t[gn] = e, t[ga] = r, ZE(t, e, !1, !1), e.stateNode = t;
                    e: {
                        switch (o = ef(n, r), n) {
                            case "dialog":
                                ge("cancel", t), ge("close", t), i = r;
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                ge("load", t), i = r;
                                break;
                            case "video":
                            case "audio":
                                for (i = 0; i < No.length; i++) ge(No[i], t);
                                i = r;
                                break;
                            case "source":
                                ge("error", t), i = r;
                                break;
                            case "img":
                            case "image":
                            case "link":
                                ge("error", t), ge("load", t), i = r;
                                break;
                            case "details":
                                ge("toggle", t), i = r;
                                break;
                            case "input":
                                ov(t, r), i = Gd(t, r), ge("invalid", t);
                                break;
                            case "option":
                                i = r;
                                break;
                            case "select":
                                t._wrapperState = {
                                    wasMultiple: !!r.multiple
                                }, i = Se({}, r, {
                                    value: void 0
                                }), ge("invalid", t);
                                break;
                            case "textarea":
                                lv(t, r), i = Xd(t, r), ge("invalid", t);
                                break;
                            default:
                                i = r
                        }
                        Zd(n, i),
                        a = i;
                        for (s in a)
                            if (a.hasOwnProperty(s)) {
                                var u = a[s];
                                s === "style" ? NT(t, u) : s === "dangerouslySetInnerHTML" ? (u = u ? u.__html : void 0, u != null && xT(t, u)) : s === "children" ? typeof u == "string" ? (n !== "textarea" || u !== "") && aa(t, u) : typeof u == "number" && aa(t, "" + u) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (oa.hasOwnProperty(s) ? u != null && s === "onScroll" && ge("scroll", t) : u != null && Dp(t, s, u, o))
                            }
                        switch (n) {
                            case "input":
                                Il(t), av(t, r, !1);
                                break;
                            case "textarea":
                                Il(t), uv(t);
                                break;
                            case "option":
                                r.value != null && t.setAttribute("value", "" + Mr(r.value));
                                break;
                            case "select":
                                t.multiple = !!r.multiple, s = r.value, s != null ? ys(t, !!r.multiple, s, !1) : r.defaultValue != null && ys(t, !!r.multiple, r.defaultValue, !0);
                                break;
                            default:
                                typeof i.onClick == "function" && (t.onclick = ku)
                        }
                        switch (n) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                r = !!r.autoFocus;
                                break e;
                            case "img":
                                r = !0;
                                break e;
                            default:
                                r = !1
                        }
                    }
                    r && (e.flags |= 4)
                }
                e.ref !== null && (e.flags |= 512, e.flags |= 2097152)
            }
            return rt(e), null;
        case 6:
            if (t && e.stateNode != null) tI(t, e, t.memoizedProps, r);
            else {
                if (typeof r != "string" && e.stateNode === null) throw Error(j(166));
                if (n = gi(va.current), gi(_n.current), Nl(e)) {
                    if (r = e.stateNode, n = e.memoizedProps, r[gn] = e, (s = r.nodeValue !== n) && (t = Mt, t !== null)) switch (t.tag) {
                        case 3:
                            bl(r.nodeValue, n, (t.mode & 1) !== 0);
                            break;
                        case 5:
                            t.memoizedProps.suppressHydrationWarning !== !0 && bl(r.nodeValue, n, (t.mode & 1) !== 0)
                    }
                    s && (e.flags |= 4)
                } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[gn] = e, e.stateNode = r
            }
            return rt(e), null;
        case 13:
            if (ve(Te), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
                if (we && Ot !== null && e.mode & 1 && !(e.flags & 128)) _E(), ks(), e.flags |= 98560, s = !1;
                else if (s = Nl(e), r !== null && r.dehydrated !== null) {
                    if (t === null) {
                        if (!s) throw Error(j(318));
                        if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(j(317));
                        s[gn] = e
                    } else ks(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4;
                    rt(e), s = !1
                } else on !== null && (Of(on), on = null), s = !0;
                if (!s) return e.flags & 65536 ? e : null
            }
            return e.flags & 128 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (t === null || Te.current & 1 ? Me === 0 && (Me = 3) : mm())), e.updateQueue !== null && (e.flags |= 4), rt(e), null);
        case 4:
            return bs(), Rf(t, e), t === null && pa(e.stateNode.containerInfo), rt(e), null;
        case 10:
            return Jp(e.type._context), rt(e), null;
        case 17:
            return Ct(e.type) && xu(), rt(e), null;
        case 19:
            if (ve(Te), s = e.memoizedState, s === null) return rt(e), null;
            if (r = (e.flags & 128) !== 0, o = s.rendering, o === null)
                if (r) Po(s, !1);
                else {
                    if (Me !== 0 || t !== null && t.flags & 128)
                        for (t = e.child; t !== null;) {
                            if (o = Mu(t), o !== null) {
                                for (e.flags |= 128, Po(s, !1), r = o.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null;) s = n, t = r, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, t = o.dependencies, s.dependencies = t === null ? null : {
                                    lanes: t.lanes,
                                    firstContext: t.firstContext
                                }), n = n.sibling;
                                return fe(Te, Te.current & 1 | 2), e.child
                            }
                            t = t.sibling
                        }
                    s.tail !== null && be() > Ds && (e.flags |= 128, r = !0, Po(s, !1), e.lanes = 4194304)
                }
            else {
                if (!r)
                    if (t = Mu(o), t !== null) {
                        if (e.flags |= 128, r = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), Po(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !we) return rt(e), null
                    } else 2 * be() - s.renderingStartTime > Ds && n !== 1073741824 && (e.flags |= 128, r = !0, Po(s, !1), e.lanes = 4194304);
                s.isBackwards ? (o.sibling = e.child, e.child = o) : (n = s.last, n !== null ? n.sibling = o : e.child = o, s.last = o)
            }
            return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = be(), e.sibling = null, n = Te.current, fe(Te, r ? n & 1 | 2 : n & 1), e) : (rt(e), null);
        case 22:
        case 23:
            return pm(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? Vt & 1073741824 && (rt(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : rt(e), null;
        case 24:
            return null;
        case 25:
            return null
    }
    throw Error(j(156, e.tag))
}

function Vk(t, e) {
    switch (Gp(e), e.tag) {
        case 1:
            return Ct(e.type) && xu(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
        case 3:
            return bs(), ve(Rt), ve(ft), rm(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null;
        case 5:
            return nm(e), null;
        case 13:
            if (ve(Te), t = e.memoizedState, t !== null && t.dehydrated !== null) {
                if (e.alternate === null) throw Error(j(340));
                ks()
            }
            return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
        case 19:
            return ve(Te), null;
        case 4:
            return bs(), null;
        case 10:
            return Jp(e.type._context), null;
        case 22:
        case 23:
            return pm(), null;
        case 24:
            return null;
        default:
            return null
    }
}
var Ol = !1,
    at = !1,
    Ok = typeof WeakSet == "function" ? WeakSet : Set,
    q = null;

function us(t, e) {
    var n = t.ref;
    if (n !== null)
        if (typeof n == "function") try {
            n(null)
        } catch (r) {
            Re(t, e, r)
        } else n.current = null
}

function Cf(t, e, n) {
    try {
        n()
    } catch (r) {
        Re(t, e, r)
    }
}
var Jv = !1;

function Lk(t, e) {
    if (hf = Pu, t = oE(), Hp(t)) {
        if ("selectionStart" in t) var n = {
            start: t.selectionStart,
            end: t.selectionEnd
        };
        else e: {
            n = (n = t.ownerDocument) && n.defaultView || window;
            var r = n.getSelection && n.getSelection();
            if (r && r.rangeCount !== 0) {
                n = r.anchorNode;
                var i = r.anchorOffset,
                    s = r.focusNode;
                r = r.focusOffset;
                try {
                    n.nodeType, s.nodeType
                } catch {
                    n = null;
                    break e
                }
                var o = 0,
                    a = -1,
                    u = -1,
                    c = 0,
                    h = 0,
                    f = t,
                    m = null;
                t: for (;;) {
                    for (var _; f !== n || i !== 0 && f.nodeType !== 3 || (a = o + i), f !== s || r !== 0 && f.nodeType !== 3 || (u = o + r), f.nodeType === 3 && (o += f.nodeValue.length), (_ = f.firstChild) !== null;) m = f, f = _;
                    for (;;) {
                        if (f === t) break t;
                        if (m === n && ++c === i && (a = o), m === s && ++h === r && (u = o), (_ = f.nextSibling) !== null) break;
                        f = m, m = f.parentNode
                    }
                    f = _
                }
                n = a === -1 || u === -1 ? null : {
                    start: a,
                    end: u
                }
            } else n = null
        }
        n = n || {
            start: 0,
            end: 0
        }
    } else n = null;
    for (df = {
            focusedElem: t,
            selectionRange: n
        }, Pu = !1, q = e; q !== null;)
        if (e = q, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, q = t;
        else
            for (; q !== null;) {
                e = q;
                try {
                    var I = e.alternate;
                    if (e.flags & 1024) switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (I !== null) {
                                var R = I.memoizedProps,
                                    k = I.memoizedState,
                                    w = e.stateNode,
                                    v = w.getSnapshotBeforeUpdate(e.elementType === e.type ? R : rn(e.type, R), k);
                                w.__reactInternalSnapshotBeforeUpdate = v
                            }
                            break;
                        case 3:
                            var T = e.stateNode.containerInfo;
                            T.nodeType === 1 ? T.textContent = "" : T.nodeType === 9 && T.documentElement && T.removeChild(T.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(j(163))
                    }
                } catch (x) {
                    Re(e, e.return, x)
                }
                if (t = e.sibling, t !== null) {
                    t.return = e.return, q = t;
                    break
                }
                q = e.return
            }
    return I = Jv, Jv = !1, I
}

function Ho(t, e, n) {
    var r = e.updateQueue;
    if (r = r !== null ? r.lastEffect : null, r !== null) {
        var i = r = r.next;
        do {
            if ((i.tag & t) === t) {
                var s = i.destroy;
                i.destroy = void 0, s !== void 0 && Cf(e, n, s)
            }
            i = i.next
        } while (i !== r)
    }
}

function bc(t, e) {
    if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
        var n = e = e.next;
        do {
            if ((n.tag & t) === t) {
                var r = n.create;
                n.destroy = r()
            }
            n = n.next
        } while (n !== e)
    }
}

function kf(t) {
    var e = t.ref;
    if (e !== null) {
        var n = t.stateNode;
        switch (t.tag) {
            case 5:
                t = n;
                break;
            default:
                t = n
        }
        typeof e == "function" ? e(t) : e.current = t
    }
}

function nI(t) {
    var e = t.alternate;
    e !== null && (t.alternate = null, nI(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[gn], delete e[ga], delete e[mf], delete e[vk], delete e[_k])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null
}

function rI(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4
}

function Zv(t) {
    e: for (;;) {
        for (; t.sibling === null;) {
            if (t.return === null || rI(t.return)) return null;
            t = t.return
        }
        for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) {
            if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
            t.child.return = t, t = t.child
        }
        if (!(t.flags & 2)) return t.stateNode
    }
}

function xf(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = ku));
    else if (r !== 4 && (t = t.child, t !== null))
        for (xf(t, e, n), t = t.sibling; t !== null;) xf(t, e, n), t = t.sibling
}

function bf(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t);
    else if (r !== 4 && (t = t.child, t !== null))
        for (bf(t, e, n), t = t.sibling; t !== null;) bf(t, e, n), t = t.sibling
}
var qe = null,
    sn = !1;

function hr(t, e, n) {
    for (n = n.child; n !== null;) iI(t, e, n), n = n.sibling
}

function iI(t, e, n) {
    if (vn && typeof vn.onCommitFiberUnmount == "function") try {
        vn.onCommitFiberUnmount(Ic, n)
    } catch {}
    switch (n.tag) {
        case 5:
            at || us(n, e);
        case 6:
            var r = qe,
                i = sn;
            qe = null, hr(t, e, n), qe = r, sn = i, qe !== null && (sn ? (t = qe, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : qe.removeChild(n.stateNode));
            break;
        case 18:
            qe !== null && (sn ? (t = qe, n = n.stateNode, t.nodeType === 8 ? ed(t.parentNode, n) : t.nodeType === 1 && ed(t, n), ha(t)) : ed(qe, n.stateNode));
            break;
        case 4:
            r = qe, i = sn, qe = n.stateNode.containerInfo, sn = !0, hr(t, e, n), qe = r, sn = i;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!at && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
                i = r = r.next;
                do {
                    var s = i,
                        o = s.destroy;
                    s = s.tag, o !== void 0 && (s & 2 || s & 4) && Cf(n, e, o), i = i.next
                } while (i !== r)
            }
            hr(t, e, n);
            break;
        case 1:
            if (!at && (us(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function")) try {
                r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
            } catch (a) {
                Re(n, e, a)
            }
            hr(t, e, n);
            break;
        case 21:
            hr(t, e, n);
            break;
        case 22:
            n.mode & 1 ? (at = (r = at) || n.memoizedState !== null, hr(t, e, n), at = r) : hr(t, e, n);
            break;
        default:
            hr(t, e, n)
    }
}

function e_(t) {
    var e = t.updateQueue;
    if (e !== null) {
        t.updateQueue = null;
        var n = t.stateNode;
        n === null && (n = t.stateNode = new Ok), e.forEach(function(r) {
            var i = qk.bind(null, t, r);
            n.has(r) || (n.add(r), r.then(i, i))
        })
    }
}

function nn(t, e) {
    var n = e.deletions;
    if (n !== null)
        for (var r = 0; r < n.length; r++) {
            var i = n[r];
            try {
                var s = t,
                    o = e,
                    a = o;
                e: for (; a !== null;) {
                    switch (a.tag) {
                        case 5:
                            qe = a.stateNode, sn = !1;
                            break e;
                        case 3:
                            qe = a.stateNode.containerInfo, sn = !0;
                            break e;
                        case 4:
                            qe = a.stateNode.containerInfo, sn = !0;
                            break e
                    }
                    a = a.return
                }
                if (qe === null) throw Error(j(160));
                iI(s, o, i), qe = null, sn = !1;
                var u = i.alternate;
                u !== null && (u.return = null), i.return = null
            } catch (c) {
                Re(i, e, c)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null;) sI(e, t), e = e.sibling
}

function sI(t, e) {
    var n = t.alternate,
        r = t.flags;
    switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (nn(e, t), fn(t), r & 4) {
                try {
                    Ho(3, t, t.return), bc(3, t)
                } catch (R) {
                    Re(t, t.return, R)
                }
                try {
                    Ho(5, t, t.return)
                } catch (R) {
                    Re(t, t.return, R)
                }
            }
            break;
        case 1:
            nn(e, t), fn(t), r & 512 && n !== null && us(n, n.return);
            break;
        case 5:
            if (nn(e, t), fn(t), r & 512 && n !== null && us(n, n.return), t.flags & 32) {
                var i = t.stateNode;
                try {
                    aa(i, "")
                } catch (R) {
                    Re(t, t.return, R)
                }
            }
            if (r & 4 && (i = t.stateNode, i != null)) {
                var s = t.memoizedProps,
                    o = n !== null ? n.memoizedProps : s,
                    a = t.type,
                    u = t.updateQueue;
                if (t.updateQueue = null, u !== null) try {
                    a === "input" && s.type === "radio" && s.name != null && RT(i, s), ef(a, o);
                    var c = ef(a, s);
                    for (o = 0; o < u.length; o += 2) {
                        var h = u[o],
                            f = u[o + 1];
                        h === "style" ? NT(i, f) : h === "dangerouslySetInnerHTML" ? xT(i, f) : h === "children" ? aa(i, f) : Dp(i, h, f, c)
                    }
                    switch (a) {
                        case "input":
                            Qd(i, s);
                            break;
                        case "textarea":
                            CT(i, s);
                            break;
                        case "select":
                            var m = i._wrapperState.wasMultiple;
                            i._wrapperState.wasMultiple = !!s.multiple;
                            var _ = s.value;
                            _ != null ? ys(i, !!s.multiple, _, !1) : m !== !!s.multiple && (s.defaultValue != null ? ys(i, !!s.multiple, s.defaultValue, !0) : ys(i, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    i[ga] = s
                } catch (R) {
                    Re(t, t.return, R)
                }
            }
            break;
        case 6:
            if (nn(e, t), fn(t), r & 4) {
                if (t.stateNode === null) throw Error(j(162));
                i = t.stateNode, s = t.memoizedProps;
                try {
                    i.nodeValue = s
                } catch (R) {
                    Re(t, t.return, R)
                }
            }
            break;
        case 3:
            if (nn(e, t), fn(t), r & 4 && n !== null && n.memoizedState.isDehydrated) try {
                ha(e.containerInfo)
            } catch (R) {
                Re(t, t.return, R)
            }
            break;
        case 4:
            nn(e, t), fn(t);
            break;
        case 13:
            nn(e, t), fn(t), i = t.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (dm = be())), r & 4 && e_(t);
            break;
        case 22:
            if (h = n !== null && n.memoizedState !== null, t.mode & 1 ? (at = (c = at) || h, nn(e, t), at = c) : nn(e, t), fn(t), r & 8192) {
                if (c = t.memoizedState !== null, (t.stateNode.isHidden = c) && !h && t.mode & 1)
                    for (q = t, h = t.child; h !== null;) {
                        for (f = q = h; q !== null;) {
                            switch (m = q, _ = m.child, m.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    Ho(4, m, m.return);
                                    break;
                                case 1:
                                    us(m, m.return);
                                    var I = m.stateNode;
                                    if (typeof I.componentWillUnmount == "function") {
                                        r = m, n = m.return;
                                        try {
                                            e = r, I.props = e.memoizedProps, I.state = e.memoizedState, I.componentWillUnmount()
                                        } catch (R) {
                                            Re(r, n, R)
                                        }
                                    }
                                    break;
                                case 5:
                                    us(m, m.return);
                                    break;
                                case 22:
                                    if (m.memoizedState !== null) {
                                        n_(f);
                                        continue
                                    }
                            }
                            _ !== null ? (_.return = m, q = _) : n_(f)
                        }
                        h = h.sibling
                    }
                e: for (h = null, f = t;;) {
                    if (f.tag === 5) {
                        if (h === null) {
                            h = f;
                            try {
                                i = f.stateNode, c ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = f.stateNode, u = f.memoizedProps.style, o = u != null && u.hasOwnProperty("display") ? u.display : null, a.style.display = bT("display", o))
                            } catch (R) {
                                Re(t, t.return, R)
                            }
                        }
                    } else if (f.tag === 6) {
                        if (h === null) try {
                            f.stateNode.nodeValue = c ? "" : f.memoizedProps
                        } catch (R) {
                            Re(t, t.return, R)
                        }
                    } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === t) && f.child !== null) {
                        f.child.return = f, f = f.child;
                        continue
                    }
                    if (f === t) break e;
                    for (; f.sibling === null;) {
                        if (f.return === null || f.return === t) break e;
                        h === f && (h = null), f = f.return
                    }
                    h === f && (h = null), f.sibling.return = f.return, f = f.sibling
                }
            }
            break;
        case 19:
            nn(e, t), fn(t), r & 4 && e_(t);
            break;
        case 21:
            break;
        default:
            nn(e, t), fn(t)
    }
}

function fn(t) {
    var e = t.flags;
    if (e & 2) {
        try {
            e: {
                for (var n = t.return; n !== null;) {
                    if (rI(n)) {
                        var r = n;
                        break e
                    }
                    n = n.return
                }
                throw Error(j(160))
            }
            switch (r.tag) {
                case 5:
                    var i = r.stateNode;
                    r.flags & 32 && (aa(i, ""), r.flags &= -33);
                    var s = Zv(t);
                    bf(t, s, i);
                    break;
                case 3:
                case 4:
                    var o = r.stateNode.containerInfo,
                        a = Zv(t);
                    xf(t, a, o);
                    break;
                default:
                    throw Error(j(161))
            }
        }
        catch (u) {
            Re(t, t.return, u)
        }
        t.flags &= -3
    }
    e & 4096 && (t.flags &= -4097)
}

function Mk(t, e, n) {
    q = t, oI(t)
}

function oI(t, e, n) {
    for (var r = (t.mode & 1) !== 0; q !== null;) {
        var i = q,
            s = i.child;
        if (i.tag === 22 && r) {
            var o = i.memoizedState !== null || Ol;
            if (!o) {
                var a = i.alternate,
                    u = a !== null && a.memoizedState !== null || at;
                a = Ol;
                var c = at;
                if (Ol = o, (at = u) && !c)
                    for (q = i; q !== null;) o = q, u = o.child, o.tag === 22 && o.memoizedState !== null ? r_(i) : u !== null ? (u.return = o, q = u) : r_(i);
                for (; s !== null;) q = s, oI(s), s = s.sibling;
                q = i, Ol = a, at = c
            }
            t_(t)
        } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, q = s) : t_(t)
    }
}

function t_(t) {
    for (; q !== null;) {
        var e = q;
        if (e.flags & 8772) {
            var n = e.alternate;
            try {
                if (e.flags & 8772) switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        at || bc(5, e);
                        break;
                    case 1:
                        var r = e.stateNode;
                        if (e.flags & 4 && !at)
                            if (n === null) r.componentDidMount();
                            else {
                                var i = e.elementType === e.type ? n.memoizedProps : rn(e.type, n.memoizedProps);
                                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && Uv(e, s, r);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (n = null, e.child !== null) switch (e.child.tag) {
                                case 5:
                                    n = e.child.stateNode;
                                    break;
                                case 1:
                                    n = e.child.stateNode
                            }
                            Uv(e, o, n)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (n === null && e.flags & 4) {
                            n = a;
                            var u = e.memoizedProps;
                            switch (e.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    u.autoFocus && n.focus();
                                    break;
                                case "img":
                                    u.src && (n.src = u.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var c = e.alternate;
                            if (c !== null) {
                                var h = c.memoizedState;
                                if (h !== null) {
                                    var f = h.dehydrated;
                                    f !== null && ha(f)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(j(163))
                }
                at || e.flags & 512 && kf(e)
            } catch (m) {
                Re(e, e.return, m)
            }
        }
        if (e === t) {
            q = null;
            break
        }
        if (n = e.sibling, n !== null) {
            n.return = e.return, q = n;
            break
        }
        q = e.return
    }
}

function n_(t) {
    for (; q !== null;) {
        var e = q;
        if (e === t) {
            q = null;
            break
        }
        var n = e.sibling;
        if (n !== null) {
            n.return = e.return, q = n;
            break
        }
        q = e.return
    }
}

function r_(t) {
    for (; q !== null;) {
        var e = q;
        try {
            switch (e.tag) {
                case 0:
                case 11:
                case 15:
                    var n = e.return;
                    try {
                        bc(4, e)
                    } catch (u) {
                        Re(e, n, u)
                    }
                    break;
                case 1:
                    var r = e.stateNode;
                    if (typeof r.componentDidMount == "function") {
                        var i = e.return;
                        try {
                            r.componentDidMount()
                        } catch (u) {
                            Re(e, i, u)
                        }
                    }
                    var s = e.return;
                    try {
                        kf(e)
                    } catch (u) {
                        Re(e, s, u)
                    }
                    break;
                case 5:
                    var o = e.return;
                    try {
                        kf(e)
                    } catch (u) {
                        Re(e, o, u)
                    }
            }
        } catch (u) {
            Re(e, e.return, u)
        }
        if (e === t) {
            q = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return, q = a;
            break
        }
        q = e.return
    }
}
var Fk = Math.ceil,
    ju = rr.ReactCurrentDispatcher,
    cm = rr.ReactCurrentOwner,
    Yt = rr.ReactCurrentBatchConfig,
    se = 0,
    $e = null,
    De = null,
    Qe = 0,
    Vt = 0,
    cs = Qr(0),
    Me = 0,
    Ea = null,
    Ci = 0,
    Nc = 0,
    hm = 0,
    Ko = null,
    St = null,
    dm = 0,
    Ds = 1 / 0,
    Nn = null,
    Bu = !1,
    Nf = null,
    Nr = null,
    Ll = !1,
    Ir = null,
    $u = 0,
    Go = 0,
    Df = null,
    iu = -1,
    su = 0;

function vt() {
    return se & 6 ? be() : iu !== -1 ? iu : iu = be()
}

function Dr(t) {
    return t.mode & 1 ? se & 2 && Qe !== 0 ? Qe & -Qe : Tk.transition !== null ? (su === 0 && (su = WT()), su) : (t = ce, t !== 0 || (t = window.event, t = t === void 0 ? 16 : XT(t.type)), t) : 1
}

function un(t, e, n, r) {
    if (50 < Go) throw Go = 0, Df = null, Error(j(185));
    ja(t, n, r), (!(se & 2) || t !== $e) && (t === $e && (!(se & 2) && (Nc |= n), Me === 4 && yr(t, Qe)), kt(t, r), n === 1 && se === 0 && !(e.mode & 1) && (Ds = be() + 500, Cc && Yr()))
}

function kt(t, e) {
    var n = t.callbackNode;
    TC(t, e);
    var r = Au(t, t === $e ? Qe : 0);
    if (r === 0) n !== null && dv(n), t.callbackNode = null, t.callbackPriority = 0;
    else if (e = r & -r, t.callbackPriority !== e) {
        if (n != null && dv(n), e === 1) t.tag === 0 ? wk(i_.bind(null, t)) : gE(i_.bind(null, t)), gk(function() {
            !(se & 6) && Yr()
        }), n = null;
        else {
            switch (qT(r)) {
                case 1:
                    n = Fp;
                    break;
                case 4:
                    n = $T;
                    break;
                case 16:
                    n = Su;
                    break;
                case 536870912:
                    n = zT;
                    break;
                default:
                    n = Su
            }
            n = pI(n, aI.bind(null, t))
        }
        t.callbackPriority = e, t.callbackNode = n
    }
}

function aI(t, e) {
    if (iu = -1, su = 0, se & 6) throw Error(j(327));
    var n = t.callbackNode;
    if (Es() && t.callbackNode !== n) return null;
    var r = Au(t, t === $e ? Qe : 0);
    if (r === 0) return null;
    if (r & 30 || r & t.expiredLanes || e) e = zu(t, r);
    else {
        e = r;
        var i = se;
        se |= 2;
        var s = uI();
        ($e !== t || Qe !== e) && (Nn = null, Ds = be() + 500, wi(t, e));
        do try {
            Bk();
            break
        } catch (a) {
            lI(t, a)
        }
        while (!0);
        Xp(), ju.current = s, se = i, De !== null ? e = 0 : ($e = null, Qe = 0, e = Me)
    }
    if (e !== 0) {
        if (e === 2 && (i = of (t), i !== 0 && (r = i, e = Vf(t, i))), e === 1) throw n = Ea, wi(t, 0), yr(t, r), kt(t, be()), n;
        if (e === 6) yr(t, r);
        else {
            if (i = t.current.alternate, !(r & 30) && !Uk(i) && (e = zu(t, r), e === 2 && (s = of (t), s !== 0 && (r = s, e = Vf(t, s))), e === 1)) throw n = Ea, wi(t, 0), yr(t, r), kt(t, be()), n;
            switch (t.finishedWork = i, t.finishedLanes = r, e) {
                case 0:
                case 1:
                    throw Error(j(345));
                case 2:
                    ci(t, St, Nn);
                    break;
                case 3:
                    if (yr(t, r), (r & 130023424) === r && (e = dm + 500 - be(), 10 < e)) {
                        if (Au(t, 0) !== 0) break;
                        if (i = t.suspendedLanes, (i & r) !== r) {
                            vt(), t.pingedLanes |= t.suspendedLanes & i;
                            break
                        }
                        t.timeoutHandle = pf(ci.bind(null, t, St, Nn), e);
                        break
                    }
                    ci(t, St, Nn);
                    break;
                case 4:
                    if (yr(t, r), (r & 4194240) === r) break;
                    for (e = t.eventTimes, i = -1; 0 < r;) {
                        var o = 31 - ln(r);
                        s = 1 << o, o = e[o], o > i && (i = o), r &= ~s
                    }
                    if (r = i, r = be() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Fk(r / 1960)) - r, 10 < r) {
                        t.timeoutHandle = pf(ci.bind(null, t, St, Nn), r);
                        break
                    }
                    ci(t, St, Nn);
                    break;
                case 5:
                    ci(t, St, Nn);
                    break;
                default:
                    throw Error(j(329))
            }
        }
    }
    return kt(t, be()), t.callbackNode === n ? aI.bind(null, t) : null
}

function Vf(t, e) {
    var n = Ko;
    return t.current.memoizedState.isDehydrated && (wi(t, e).flags |= 256), t = zu(t, e), t !== 2 && (e = St, St = n, e !== null && Of(e)), t
}

function Of(t) {
    St === null ? St = t : St.push.apply(St, t)
}

function Uk(t) {
    for (var e = t;;) {
        if (e.flags & 16384) {
            var n = e.updateQueue;
            if (n !== null && (n = n.stores, n !== null))
                for (var r = 0; r < n.length; r++) {
                    var i = n[r],
                        s = i.getSnapshot;
                    i = i.value;
                    try {
                        if (!cn(s(), i)) return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n;
        else {
            if (e === t) break;
            for (; e.sibling === null;) {
                if (e.return === null || e.return === t) return !0;
                e = e.return
            }
            e.sibling.return = e.return, e = e.sibling
        }
    }
    return !0
}

function yr(t, e) {
    for (e &= ~hm, e &= ~Nc, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) {
        var n = 31 - ln(e),
            r = 1 << n;
        t[n] = -1, e &= ~r
    }
}

function i_(t) {
    if (se & 6) throw Error(j(327));
    Es();
    var e = Au(t, 0);
    if (!(e & 1)) return kt(t, be()), null;
    var n = zu(t, e);
    if (t.tag !== 0 && n === 2) {
        var r = of (t);
        r !== 0 && (e = r, n = Vf(t, r))
    }
    if (n === 1) throw n = Ea, wi(t, 0), yr(t, e), kt(t, be()), n;
    if (n === 6) throw Error(j(345));
    return t.finishedWork = t.current.alternate, t.finishedLanes = e, ci(t, St, Nn), kt(t, be()), null
}

function fm(t, e) {
    var n = se;
    se |= 1;
    try {
        return t(e)
    } finally {
        se = n, se === 0 && (Ds = be() + 500, Cc && Yr())
    }
}

function ki(t) {
    Ir !== null && Ir.tag === 0 && !(se & 6) && Es();
    var e = se;
    se |= 1;
    var n = Yt.transition,
        r = ce;
    try {
        if (Yt.transition = null, ce = 1, t) return t()
    } finally {
        ce = r, Yt.transition = n, se = e, !(se & 6) && Yr()
    }
}

function pm() {
    Vt = cs.current, ve(cs)
}

function wi(t, e) {
    t.finishedWork = null, t.finishedLanes = 0;
    var n = t.timeoutHandle;
    if (n !== -1 && (t.timeoutHandle = -1, mk(n)), De !== null)
        for (n = De.return; n !== null;) {
            var r = n;
            switch (Gp(r), r.tag) {
                case 1:
                    r = r.type.childContextTypes, r != null && xu();
                    break;
                case 3:
                    bs(), ve(Rt), ve(ft), rm();
                    break;
                case 5:
                    nm(r);
                    break;
                case 4:
                    bs();
                    break;
                case 13:
                    ve(Te);
                    break;
                case 19:
                    ve(Te);
                    break;
                case 10:
                    Jp(r.type._context);
                    break;
                case 22:
                case 23:
                    pm()
            }
            n = n.return
        }
    if ($e = t, De = t = Vr(t.current, null), Qe = Vt = e, Me = 0, Ea = null, hm = Nc = Ci = 0, St = Ko = null, mi !== null) {
        for (e = 0; e < mi.length; e++)
            if (n = mi[e], r = n.interleaved, r !== null) {
                n.interleaved = null;
                var i = r.next,
                    s = n.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = i, r.next = o
                }
                n.pending = r
            }
        mi = null
    }
    return t
}

function lI(t, e) {
    do {
        var n = De;
        try {
            if (Xp(), tu.current = Uu, Fu) {
                for (var r = Ie.memoizedState; r !== null;) {
                    var i = r.queue;
                    i !== null && (i.pending = null), r = r.next
                }
                Fu = !1
            }
            if (Ri = 0, Be = Le = Ie = null, qo = !1, _a = 0, cm.current = null, n === null || n.return === null) {
                Me = 1, Ea = e, De = null;
                break
            }
            e: {
                var s = t,
                    o = n.return,
                    a = n,
                    u = e;
                if (e = Qe, a.flags |= 32768, u !== null && typeof u == "object" && typeof u.then == "function") {
                    var c = u,
                        h = a,
                        f = h.tag;
                    if (!(h.mode & 1) && (f === 0 || f === 11 || f === 15)) {
                        var m = h.alternate;
                        m ? (h.updateQueue = m.updateQueue, h.memoizedState = m.memoizedState, h.lanes = m.lanes) : (h.updateQueue = null, h.memoizedState = null)
                    }
                    var _ = qv(o);
                    if (_ !== null) {
                        _.flags &= -257, Hv(_, o, a, s, e), _.mode & 1 && Wv(s, c, e), e = _, u = c;
                        var I = e.updateQueue;
                        if (I === null) {
                            var R = new Set;
                            R.add(u), e.updateQueue = R
                        } else I.add(u);
                        break e
                    } else {
                        if (!(e & 1)) {
                            Wv(s, c, e), mm();
                            break e
                        }
                        u = Error(j(426))
                    }
                } else if (we && a.mode & 1) {
                    var k = qv(o);
                    if (k !== null) {
                        !(k.flags & 65536) && (k.flags |= 256), Hv(k, o, a, s, e), Qp(Ns(u, a));
                        break e
                    }
                }
                s = u = Ns(u, a),
                Me !== 4 && (Me = 2),
                Ko === null ? Ko = [s] : Ko.push(s),
                s = o;do {
                    switch (s.tag) {
                        case 3:
                            s.flags |= 65536, e &= -e, s.lanes |= e;
                            var w = qE(s, u, e);
                            Fv(s, w);
                            break e;
                        case 1:
                            a = u;
                            var v = s.type,
                                T = s.stateNode;
                            if (!(s.flags & 128) && (typeof v.getDerivedStateFromError == "function" || T !== null && typeof T.componentDidCatch == "function" && (Nr === null || !Nr.has(T)))) {
                                s.flags |= 65536, e &= -e, s.lanes |= e;
                                var x = HE(s, a, e);
                                Fv(s, x);
                                break e
                            }
                    }
                    s = s.return
                } while (s !== null)
            }
            hI(n)
        } catch (O) {
            e = O, De === n && n !== null && (De = n = n.return);
            continue
        }
        break
    } while (!0)
}

function uI() {
    var t = ju.current;
    return ju.current = Uu, t === null ? Uu : t
}

function mm() {
    (Me === 0 || Me === 3 || Me === 2) && (Me = 4), $e === null || !(Ci & 268435455) && !(Nc & 268435455) || yr($e, Qe)
}

function zu(t, e) {
    var n = se;
    se |= 2;
    var r = uI();
    ($e !== t || Qe !== e) && (Nn = null, wi(t, e));
    do try {
        jk();
        break
    } catch (i) {
        lI(t, i)
    }
    while (!0);
    if (Xp(), se = n, ju.current = r, De !== null) throw Error(j(261));
    return $e = null, Qe = 0, Me
}

function jk() {
    for (; De !== null;) cI(De)
}

function Bk() {
    for (; De !== null && !dC();) cI(De)
}

function cI(t) {
    var e = fI(t.alternate, t, Vt);
    t.memoizedProps = t.pendingProps, e === null ? hI(t) : De = e, cm.current = null
}

function hI(t) {
    var e = t;
    do {
        var n = e.alternate;
        if (t = e.return, e.flags & 32768) {
            if (n = Vk(n, e), n !== null) {
                n.flags &= 32767, De = n;
                return
            }
            if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
            else {
                Me = 6, De = null;
                return
            }
        } else if (n = Dk(n, e, Vt), n !== null) {
            De = n;
            return
        }
        if (e = e.sibling, e !== null) {
            De = e;
            return
        }
        De = e = t
    } while (e !== null);
    Me === 0 && (Me = 5)
}

function ci(t, e, n) {
    var r = ce,
        i = Yt.transition;
    try {
        Yt.transition = null, ce = 1, $k(t, e, n, r)
    } finally {
        Yt.transition = i, ce = r
    }
    return null
}

function $k(t, e, n, r) {
    do Es(); while (Ir !== null);
    if (se & 6) throw Error(j(327));
    n = t.finishedWork;
    var i = t.finishedLanes;
    if (n === null) return null;
    if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(j(177));
    t.callbackNode = null, t.callbackPriority = 0;
    var s = n.lanes | n.childLanes;
    if (EC(t, s), t === $e && (De = $e = null, Qe = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Ll || (Ll = !0, pI(Su, function() {
            return Es(), null
        })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) {
        s = Yt.transition, Yt.transition = null;
        var o = ce;
        ce = 1;
        var a = se;
        se |= 4, cm.current = null, Lk(t, n), sI(n, t), lk(df), Pu = !!hf, df = hf = null, t.current = n, Mk(n), fC(), se = a, ce = o, Yt.transition = s
    } else t.current = n;
    if (Ll && (Ll = !1, Ir = t, $u = i), s = t.pendingLanes, s === 0 && (Nr = null), gC(n.stateNode), kt(t, be()), e !== null)
        for (r = t.onRecoverableError, n = 0; n < e.length; n++) i = e[n], r(i.value, {
            componentStack: i.stack,
            digest: i.digest
        });
    if (Bu) throw Bu = !1, t = Nf, Nf = null, t;
    return $u & 1 && t.tag !== 0 && Es(), s = t.pendingLanes, s & 1 ? t === Df ? Go++ : (Go = 0, Df = t) : Go = 0, Yr(), null
}

function Es() {
    if (Ir !== null) {
        var t = qT($u),
            e = Yt.transition,
            n = ce;
        try {
            if (Yt.transition = null, ce = 16 > t ? 16 : t, Ir === null) var r = !1;
            else {
                if (t = Ir, Ir = null, $u = 0, se & 6) throw Error(j(331));
                var i = se;
                for (se |= 4, q = t.current; q !== null;) {
                    var s = q,
                        o = s.child;
                    if (q.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var u = 0; u < a.length; u++) {
                                var c = a[u];
                                for (q = c; q !== null;) {
                                    var h = q;
                                    switch (h.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Ho(8, h, s)
                                    }
                                    var f = h.child;
                                    if (f !== null) f.return = h, q = f;
                                    else
                                        for (; q !== null;) {
                                            h = q;
                                            var m = h.sibling,
                                                _ = h.return;
                                            if (nI(h), h === c) {
                                                q = null;
                                                break
                                            }
                                            if (m !== null) {
                                                m.return = _, q = m;
                                                break
                                            }
                                            q = _
                                        }
                                }
                            }
                            var I = s.alternate;
                            if (I !== null) {
                                var R = I.child;
                                if (R !== null) {
                                    I.child = null;
                                    do {
                                        var k = R.sibling;
                                        R.sibling = null, R = k
                                    } while (R !== null)
                                }
                            }
                            q = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null) o.return = s, q = o;
                    else e: for (; q !== null;) {
                        if (s = q, s.flags & 2048) switch (s.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Ho(9, s, s.return)
                        }
                        var w = s.sibling;
                        if (w !== null) {
                            w.return = s.return, q = w;
                            break e
                        }
                        q = s.return
                    }
                }
                var v = t.current;
                for (q = v; q !== null;) {
                    o = q;
                    var T = o.child;
                    if (o.subtreeFlags & 2064 && T !== null) T.return = o, q = T;
                    else e: for (o = v; q !== null;) {
                        if (a = q, a.flags & 2048) try {
                            switch (a.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    bc(9, a)
                            }
                        } catch (O) {
                            Re(a, a.return, O)
                        }
                        if (a === o) {
                            q = null;
                            break e
                        }
                        var x = a.sibling;
                        if (x !== null) {
                            x.return = a.return, q = x;
                            break e
                        }
                        q = a.return
                    }
                }
                if (se = i, Yr(), vn && typeof vn.onPostCommitFiberRoot == "function") try {
                    vn.onPostCommitFiberRoot(Ic, t)
                } catch {}
                r = !0
            }
            return r
        } finally {
            ce = n, Yt.transition = e
        }
    }
    return !1
}

function s_(t, e, n) {
    e = Ns(n, e), e = qE(t, e, 1), t = br(t, e, 1), e = vt(), t !== null && (ja(t, 1, e), kt(t, e))
}

function Re(t, e, n) {
    if (t.tag === 3) s_(t, t, n);
    else
        for (; e !== null;) {
            if (e.tag === 3) {
                s_(e, t, n);
                break
            } else if (e.tag === 1) {
                var r = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Nr === null || !Nr.has(r))) {
                    t = Ns(n, t), t = HE(e, t, 1), e = br(e, t, 1), t = vt(), e !== null && (ja(e, 1, t), kt(e, t));
                    break
                }
            }
            e = e.return
        }
}

function zk(t, e, n) {
    var r = t.pingCache;
    r !== null && r.delete(e), e = vt(), t.pingedLanes |= t.suspendedLanes & n, $e === t && (Qe & n) === n && (Me === 4 || Me === 3 && (Qe & 130023424) === Qe && 500 > be() - dm ? wi(t, 0) : hm |= n), kt(t, e)
}

function dI(t, e) {
    e === 0 && (t.mode & 1 ? (e = Pl, Pl <<= 1, !(Pl & 130023424) && (Pl = 4194304)) : e = 1);
    var n = vt();
    t = Yn(t, e), t !== null && (ja(t, e, n), kt(t, n))
}

function Wk(t) {
    var e = t.memoizedState,
        n = 0;
    e !== null && (n = e.retryLane), dI(t, n)
}

function qk(t, e) {
    var n = 0;
    switch (t.tag) {
        case 13:
            var r = t.stateNode,
                i = t.memoizedState;
            i !== null && (n = i.retryLane);
            break;
        case 19:
            r = t.stateNode;
            break;
        default:
            throw Error(j(314))
    }
    r !== null && r.delete(e), dI(t, n)
}
var fI;
fI = function(t, e, n) {
    if (t !== null)
        if (t.memoizedProps !== e.pendingProps || Rt.current) Pt = !0;
        else {
            if (!(t.lanes & n) && !(e.flags & 128)) return Pt = !1, Nk(t, e, n);
            Pt = !!(t.flags & 131072)
        }
    else Pt = !1, we && e.flags & 1048576 && yE(e, Du, e.index);
    switch (e.lanes = 0, e.tag) {
        case 2:
            var r = e.type;
            ru(t, e), t = e.pendingProps;
            var i = Cs(e, ft.current);
            Ts(e, n), i = sm(null, e, r, t, i, n);
            var s = om();
            return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Ct(r) ? (s = !0, bu(e)) : s = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, em(e), i.updater = xc, e.stateNode = i, i._reactInternals = e, Tf(e, r, t, n), e = Sf(null, e, r, !0, s, n)) : (e.tag = 0, we && s && Kp(e), yt(null, e, i, n), e = e.child), e;
        case 16:
            r = e.elementType;
            e: {
                switch (ru(t, e), t = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = Kk(r), t = rn(r, t), i) {
                    case 0:
                        e = If(null, e, r, t, n);
                        break e;
                    case 1:
                        e = Qv(null, e, r, t, n);
                        break e;
                    case 11:
                        e = Kv(null, e, r, t, n);
                        break e;
                    case 14:
                        e = Gv(null, e, r, rn(r.type, t), n);
                        break e
                }
                throw Error(j(306, r, ""))
            }
            return e;
        case 0:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : rn(r, i), If(t, e, r, i, n);
        case 1:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : rn(r, i), Qv(t, e, r, i, n);
        case 3:
            e: {
                if (YE(e), t === null) throw Error(j(387));r = e.pendingProps,
                s = e.memoizedState,
                i = s.element,
                IE(t, e),
                Lu(e, r, null, n);
                var o = e.memoizedState;
                if (r = o.element, s.isDehydrated)
                    if (s = {
                            element: r,
                            isDehydrated: !1,
                            cache: o.cache,
                            pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                            transitions: o.transitions
                        }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) {
                        i = Ns(Error(j(423)), e), e = Yv(t, e, r, n, i);
                        break e
                    } else if (r !== i) {
                    i = Ns(Error(j(424)), e), e = Yv(t, e, r, n, i);
                    break e
                } else
                    for (Ot = xr(e.stateNode.containerInfo.firstChild), Mt = e, we = !0, on = null, n = TE(e, null, r, n), e.child = n; n;) n.flags = n.flags & -3 | 4096, n = n.sibling;
                else {
                    if (ks(), r === i) {
                        e = Xn(t, e, n);
                        break e
                    }
                    yt(t, e, r, n)
                }
                e = e.child
            }
            return e;
        case 5:
            return SE(e), t === null && vf(e), r = e.type, i = e.pendingProps, s = t !== null ? t.memoizedProps : null, o = i.children, ff(r, i) ? o = null : s !== null && ff(r, s) && (e.flags |= 32), QE(t, e), yt(t, e, o, n), e.child;
        case 6:
            return t === null && vf(e), null;
        case 13:
            return XE(t, e, n);
        case 4:
            return tm(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = xs(e, null, r, n) : yt(t, e, r, n), e.child;
        case 11:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : rn(r, i), Kv(t, e, r, i, n);
        case 7:
            return yt(t, e, e.pendingProps, n), e.child;
        case 8:
            return yt(t, e, e.pendingProps.children, n), e.child;
        case 12:
            return yt(t, e, e.pendingProps.children, n), e.child;
        case 10:
            e: {
                if (r = e.type._context, i = e.pendingProps, s = e.memoizedProps, o = i.value, fe(Vu, r._currentValue), r._currentValue = o, s !== null)
                    if (cn(s.value, o)) {
                        if (s.children === i.children && !Rt.current) {
                            e = Xn(t, e, n);
                            break e
                        }
                    } else
                        for (s = e.child, s !== null && (s.return = e); s !== null;) {
                            var a = s.dependencies;
                            if (a !== null) {
                                o = s.child;
                                for (var u = a.firstContext; u !== null;) {
                                    if (u.context === r) {
                                        if (s.tag === 1) {
                                            u = Bn(-1, n & -n), u.tag = 2;
                                            var c = s.updateQueue;
                                            if (c !== null) {
                                                c = c.shared;
                                                var h = c.pending;
                                                h === null ? u.next = u : (u.next = h.next, h.next = u), c.pending = u
                                            }
                                        }
                                        s.lanes |= n, u = s.alternate, u !== null && (u.lanes |= n), _f(s.return, n, e), a.lanes |= n;
                                        break
                                    }
                                    u = u.next
                                }
                            } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
                            else if (s.tag === 18) {
                                if (o = s.return, o === null) throw Error(j(341));
                                o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), _f(o, n, e), o = s.sibling
                            } else o = s.child;
                            if (o !== null) o.return = s;
                            else
                                for (o = s; o !== null;) {
                                    if (o === e) {
                                        o = null;
                                        break
                                    }
                                    if (s = o.sibling, s !== null) {
                                        s.return = o.return, o = s;
                                        break
                                    }
                                    o = o.return
                                }
                            s = o
                        }
                yt(t, e, i.children, n),
                e = e.child
            }
            return e;
        case 9:
            return i = e.type, r = e.pendingProps.children, Ts(e, n), i = Jt(i), r = r(i), e.flags |= 1, yt(t, e, r, n), e.child;
        case 14:
            return r = e.type, i = rn(r, e.pendingProps), i = rn(r.type, i), Gv(t, e, r, i, n);
        case 15:
            return KE(t, e, e.type, e.pendingProps, n);
        case 17:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : rn(r, i), ru(t, e), e.tag = 1, Ct(r) ? (t = !0, bu(e)) : t = !1, Ts(e, n), WE(e, r, i), Tf(e, r, i, n), Sf(null, e, r, !0, t, n);
        case 19:
            return JE(t, e, n);
        case 22:
            return GE(t, e, n)
    }
    throw Error(j(156, e.tag))
};

function pI(t, e) {
    return BT(t, e)
}

function Hk(t, e, n, r) {
    this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function Qt(t, e, n, r) {
    return new Hk(t, e, n, r)
}

function gm(t) {
    return t = t.prototype, !(!t || !t.isReactComponent)
}

function Kk(t) {
    if (typeof t == "function") return gm(t) ? 1 : 0;
    if (t != null) {
        if (t = t.$$typeof, t === Op) return 11;
        if (t === Lp) return 14
    }
    return 2
}

function Vr(t, e) {
    var n = t.alternate;
    return n === null ? (n = Qt(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n
}

function ou(t, e, n, r, i, s) {
    var o = 2;
    if (r = t, typeof t == "function") gm(t) && (o = 1);
    else if (typeof t == "string") o = 5;
    else e: switch (t) {
        case es:
            return Ti(n.children, i, s, e);
        case Vp:
            o = 8, i |= 8;
            break;
        case Wd:
            return t = Qt(12, n, e, i | 2), t.elementType = Wd, t.lanes = s, t;
        case qd:
            return t = Qt(13, n, e, i), t.elementType = qd, t.lanes = s, t;
        case Hd:
            return t = Qt(19, n, e, i), t.elementType = Hd, t.lanes = s, t;
        case ST:
            return Dc(n, i, s, e);
        default:
            if (typeof t == "object" && t !== null) switch (t.$$typeof) {
                case ET:
                    o = 10;
                    break e;
                case IT:
                    o = 9;
                    break e;
                case Op:
                    o = 11;
                    break e;
                case Lp:
                    o = 14;
                    break e;
                case pr:
                    o = 16, r = null;
                    break e
            }
            throw Error(j(130, t == null ? t : typeof t, ""))
    }
    return e = Qt(o, n, e, i), e.elementType = t, e.type = r, e.lanes = s, e
}

function Ti(t, e, n, r) {
    return t = Qt(7, t, r, e), t.lanes = n, t
}

function Dc(t, e, n, r) {
    return t = Qt(22, t, r, e), t.elementType = ST, t.lanes = n, t.stateNode = {
        isHidden: !1
    }, t
}

function ld(t, e, n) {
    return t = Qt(6, t, null, e), t.lanes = n, t
}

function ud(t, e, n) {
    return e = Qt(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
    }, e
}

function Gk(t, e, n, r, i) {
    this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zh(0), this.expirationTimes = zh(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zh(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
}

function ym(t, e, n, r, i, s, o, a, u) {
    return t = new Gk(t, e, n, a, u), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = Qt(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = {
        element: r,
        isDehydrated: n,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    }, em(s), t
}

function Qk(t, e, n) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Zi,
        key: r == null ? null : "" + r,
        children: t,
        containerInfo: e,
        implementation: n
    }
}

function mI(t) {
    if (!t) return Fr;
    t = t._reactInternals;
    e: {
        if (Oi(t) !== t || t.tag !== 1) throw Error(j(170));
        var e = t;do {
            switch (e.tag) {
                case 3:
                    e = e.stateNode.context;
                    break e;
                case 1:
                    if (Ct(e.type)) {
                        e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
            }
            e = e.return
        } while (e !== null);
        throw Error(j(171))
    }
    if (t.tag === 1) {
        var n = t.type;
        if (Ct(n)) return mE(t, n, e)
    }
    return e
}

function gI(t, e, n, r, i, s, o, a, u) {
    return t = ym(n, r, !0, t, i, s, o, a, u), t.context = mI(null), n = t.current, r = vt(), i = Dr(n), s = Bn(r, i), s.callback = e ? ? null, br(n, s, i), t.current.lanes = i, ja(t, i, r), kt(t, r), t
}

function Vc(t, e, n, r) {
    var i = e.current,
        s = vt(),
        o = Dr(i);
    return n = mI(n), e.context === null ? e.context = n : e.pendingContext = n, e = Bn(s, o), e.payload = {
        element: t
    }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = br(i, e, o), t !== null && (un(t, i, o, s), eu(t, i, o)), o
}

function Wu(t) {
    if (t = t.current, !t.child) return null;
    switch (t.child.tag) {
        case 5:
            return t.child.stateNode;
        default:
            return t.child.stateNode
    }
}

function o_(t, e) {
    if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
        var n = t.retryLane;
        t.retryLane = n !== 0 && n < e ? n : e
    }
}

function vm(t, e) {
    o_(t, e), (t = t.alternate) && o_(t, e)
}

function Yk() {
    return null
}
var yI = typeof reportError == "function" ? reportError : function(t) {
    console.error(t)
};

function _m(t) {
    this._internalRoot = t
}
Oc.prototype.render = _m.prototype.render = function(t) {
    var e = this._internalRoot;
    if (e === null) throw Error(j(409));
    Vc(t, e, null, null)
};
Oc.prototype.unmount = _m.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
        this._internalRoot = null;
        var e = t.containerInfo;
        ki(function() {
            Vc(null, t, null, null)
        }), e[Qn] = null
    }
};

function Oc(t) {
    this._internalRoot = t
}
Oc.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
        var e = GT();
        t = {
            blockedOn: null,
            target: t,
            priority: e
        };
        for (var n = 0; n < gr.length && e !== 0 && e < gr[n].priority; n++);
        gr.splice(n, 0, t), n === 0 && YT(t)
    }
};

function wm(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
}

function Lc(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}

function a_() {}

function Xk(t, e, n, r, i) {
    if (i) {
        if (typeof r == "function") {
            var s = r;
            r = function() {
                var c = Wu(o);
                s.call(c)
            }
        }
        var o = gI(e, r, t, 0, null, !1, !1, "", a_);
        return t._reactRootContainer = o, t[Qn] = o.current, pa(t.nodeType === 8 ? t.parentNode : t), ki(), o
    }
    for (; i = t.lastChild;) t.removeChild(i);
    if (typeof r == "function") {
        var a = r;
        r = function() {
            var c = Wu(u);
            a.call(c)
        }
    }
    var u = ym(t, 0, !1, null, null, !1, !1, "", a_);
    return t._reactRootContainer = u, t[Qn] = u.current, pa(t.nodeType === 8 ? t.parentNode : t), ki(function() {
        Vc(e, u, n, r)
    }), u
}

function Mc(t, e, n, r, i) {
    var s = n._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof i == "function") {
            var a = i;
            i = function() {
                var u = Wu(o);
                a.call(u)
            }
        }
        Vc(e, o, t, i)
    } else o = Xk(n, e, t, i, r);
    return Wu(o)
}
HT = function(t) {
    switch (t.tag) {
        case 3:
            var e = t.stateNode;
            if (e.current.memoizedState.isDehydrated) {
                var n = bo(e.pendingLanes);
                n !== 0 && (Up(e, n | 1), kt(e, be()), !(se & 6) && (Ds = be() + 500, Yr()))
            }
            break;
        case 13:
            ki(function() {
                var r = Yn(t, 1);
                if (r !== null) {
                    var i = vt();
                    un(r, t, 1, i)
                }
            }), vm(t, 1)
    }
};
jp = function(t) {
    if (t.tag === 13) {
        var e = Yn(t, 134217728);
        if (e !== null) {
            var n = vt();
            un(e, t, 134217728, n)
        }
        vm(t, 134217728)
    }
};
KT = function(t) {
    if (t.tag === 13) {
        var e = Dr(t),
            n = Yn(t, e);
        if (n !== null) {
            var r = vt();
            un(n, t, e, r)
        }
        vm(t, e)
    }
};
GT = function() {
    return ce
};
QT = function(t, e) {
    var n = ce;
    try {
        return ce = t, e()
    } finally {
        ce = n
    }
};
nf = function(t, e, n) {
    switch (e) {
        case "input":
            if (Qd(t, n), e = n.name, n.type === "radio" && e != null) {
                for (n = t; n.parentNode;) n = n.parentNode;
                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) {
                    var r = n[e];
                    if (r !== t && r.form === t.form) {
                        var i = Rc(r);
                        if (!i) throw Error(j(90));
                        PT(r), Qd(r, i)
                    }
                }
            }
            break;
        case "textarea":
            CT(t, n);
            break;
        case "select":
            e = n.value, e != null && ys(t, !!n.multiple, e, !1)
    }
};
OT = fm;
LT = ki;
var Jk = {
        usingClientEntryPoint: !1,
        Events: [$a, is, Rc, DT, VT, fm]
    },
    Ro = {
        findFiberByHostInstance: pi,
        bundleType: 0,
        version: "18.3.1",
        rendererPackageName: "react-dom"
    },
    Zk = {
        bundleType: Ro.bundleType,
        version: Ro.version,
        rendererPackageName: Ro.rendererPackageName,
        rendererConfig: Ro.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: rr.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(t) {
            return t = UT(t), t === null ? null : t.stateNode
        },
        findFiberByHostInstance: Ro.findFiberByHostInstance || Yk,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Ml = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Ml.isDisabled && Ml.supportsFiber) try {
        Ic = Ml.inject(Zk), vn = Ml
    } catch {}
}
$t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Jk;
$t.createPortal = function(t, e) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!wm(e)) throw Error(j(200));
    return Qk(t, e, null, n)
};
$t.createRoot = function(t, e) {
    if (!wm(t)) throw Error(j(299));
    var n = !1,
        r = "",
        i = yI;
    return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = ym(t, 1, !1, null, null, n, !1, r, i), t[Qn] = e.current, pa(t.nodeType === 8 ? t.parentNode : t), new _m(e)
};
$t.findDOMNode = function(t) {
    if (t == null) return null;
    if (t.nodeType === 1) return t;
    var e = t._reactInternals;
    if (e === void 0) throw typeof t.render == "function" ? Error(j(188)) : (t = Object.keys(t).join(","), Error(j(268, t)));
    return t = UT(e), t = t === null ? null : t.stateNode, t
};
$t.flushSync = function(t) {
    return ki(t)
};
$t.hydrate = function(t, e, n) {
    if (!Lc(e)) throw Error(j(200));
    return Mc(null, t, e, !0, n)
};
$t.hydrateRoot = function(t, e, n) {
    if (!wm(t)) throw Error(j(405));
    var r = n != null && n.hydratedSources || null,
        i = !1,
        s = "",
        o = yI;
    if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), e = gI(e, null, t, 1, n ? ? null, i, !1, s, o), t[Qn] = e.current, pa(t), r)
        for (t = 0; t < r.length; t++) n = r[t], i = n._getVersion, i = i(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, i] : e.mutableSourceEagerHydrationData.push(n, i);
    return new Oc(e)
};
$t.render = function(t, e, n) {
    if (!Lc(e)) throw Error(j(200));
    return Mc(null, t, e, !1, n)
};
$t.unmountComponentAtNode = function(t) {
    if (!Lc(t)) throw Error(j(40));
    return t._reactRootContainer ? (ki(function() {
        Mc(null, null, t, !1, function() {
            t._reactRootContainer = null, t[Qn] = null
        })
    }), !0) : !1
};
$t.unstable_batchedUpdates = fm;
$t.unstable_renderSubtreeIntoContainer = function(t, e, n, r) {
    if (!Lc(n)) throw Error(j(200));
    if (t == null || t._reactInternals === void 0) throw Error(j(38));
    return Mc(t, e, n, !1, r)
};
$t.version = "18.3.1-next-f1338f8080-20240426";

function vI() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(vI)
    } catch (t) {
        console.error(t)
    }
}
vI(), vT.exports = $t;
var _I = vT.exports;
const ex = Pp(_I);
var wI, l_ = _I;
wI = l_.createRoot, l_.hydrateRoot;
const tx = (t, e) => {
        const n = Object.keys(e || {}),
            r = n.indexOf(t);
        return n[r + 1] || t
    },
    nx = (t, e) => {
        const n = Object.keys(e || {}),
            r = n.indexOf(t);
        return n[r - 1] || t
    },
    rx = t => {
        const e = /[?&]list=([^&]+)/,
            n = t.match(e);
        return n ? n[1] : null
    },
    ix = () => {
        const t = localStorage.getItem("darkMode");
        return t ? JSON.parse(t) : !1
    },
    TI = t => {
        localStorage.setItem("darkMode", JSON.stringify(t))
    },
    u_ = () => /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
    EI = M.createContext({
        isDarkMode: !1,
        toggleTheme: () => {}
    }),
    sx = ({
        children: t
    }) => {
        const [e, n] = M.useState(ix);
        M.useEffect(() => {
            document.body.style.backgroundColor = e ? "#121212" : "#ffffff", TI(e)
        }, [e]);
        const r = () => {
            n(i => !i)
        };
        return D.jsx(EI.Provider, {
            value: {
                isDarkMode: e,
                toggleTheme: r
            },
            children: t
        })
    },
    Fc = () => {
        const t = M.useContext(EI);
        if (t === void 0) throw new Error("useTheme must be used within a ThemeProvider");
        return t
    },
    ox = () => {
        const [t, e] = M.useState(navigator.onLine);
        return M.useEffect(() => {
            const n = () => e(!0),
                r = () => e(!1);
            return window.addEventListener("online", n), window.addEventListener("offline", r), () => {
                window.removeEventListener("online", n), window.removeEventListener("offline", r)
            }
        }, []), t
    },
    ax = ({
        isDarkMode: t
    }) => D.jsx("div", {
        className: "container min-vh-100 d-flex align-items-center justify-content-center",
        children: D.jsxs("div", {
            className: "text-center p-4 rounded-4",
            style: {
                background: t ? "#1e1e1e" : "#f8f9fa",
                boxShadow: t ? "0 4px 20px rgba(0,0,0,0.3)" : "0 4px 20px rgba(0,0,0,0.1)"
            },
            children: [D.jsx("i", {
                className: "bi bi-wifi-off display-1 mb-3",
                style: {
                    color: t ? "#fff" : "#2c3e50"
                }
            }), D.jsx("h2", {
                className: "mb-3",
                style: {
                    color: t ? "#fff" : "#2c3e50"
                },
                children: "No Internet Connection"
            }), D.jsx("p", {
                className: "mb-4",
                style: {
                    color: t ? "#ccc" : "#6c757d"
                },
                children: "Please check your internet connection and try again"
            }), D.jsx("button", {
                className: "btn fw-bold px-4 py-2",
                onClick: () => window.location.reload(),
                style: {
                    background: t ? "#fff" : "linear-gradient(135deg, #2c3e50 0%, #1a252f 100%)",
                    color: t ? "#1e1e1e" : "#fff",
                    border: "none",
                    boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
                    transition: "all 0.3s ease"
                },
                onMouseOver: e => e.target.style.transform = "translateY(-2px)",
                onMouseOut: e => e.target.style.transform = "translateY(0)",
                children: "Retry"
            })]
        })
    }),
    lx = "/assets/logo-dark-Ci4gvqQ2.png",
    ux = "/assets/logo-light-Daus8meI.png",
    cx = "/assets/animation-logo-dark-DPELVb5A.png",
    hx = "/assets/animation-logo-light-BC_eY8GL.png",
    dx = () => {
        const {
            isDarkMode: t,
            toggleTheme: e
        } = Fc();
        return D.jsx("button", {
            className: "theme-toggle-btn",
            onClick: e,
            "aria-label": "Toggle theme",
            style: {
                position: "relative",
                background: "none",
                border: "none",
                padding: "8px",
                cursor: "pointer",
                color: t ? "#fff" : "#2c3e50"
            },
            children: t ? D.jsx("i", {
                className: "bi bi-sun-fill fs-5"
            }) : D.jsx("i", {
                className: "bi bi-moon-fill fs-5"
            })
        })
    };
var c_ = {};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const II = function(t) {
        const e = [];
        let n = 0;
        for (let r = 0; r < t.length; r++) {
            let i = t.charCodeAt(r);
            i < 128 ? e[n++] = i : i < 2048 ? (e[n++] = i >> 6 | 192, e[n++] = i & 63 | 128) : (i & 64512) === 55296 && r + 1 < t.length && (t.charCodeAt(r + 1) & 64512) === 56320 ? (i = 65536 + ((i & 1023) << 10) + (t.charCodeAt(++r) & 1023), e[n++] = i >> 18 | 240, e[n++] = i >> 12 & 63 | 128, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128) : (e[n++] = i >> 12 | 224, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128)
        }
        return e
    },
    fx = function(t) {
        const e = [];
        let n = 0,
            r = 0;
        for (; n < t.length;) {
            const i = t[n++];
            if (i < 128) e[r++] = String.fromCharCode(i);
            else if (i > 191 && i < 224) {
                const s = t[n++];
                e[r++] = String.fromCharCode((i & 31) << 6 | s & 63)
            } else if (i > 239 && i < 365) {
                const s = t[n++],
                    o = t[n++],
                    a = t[n++],
                    u = ((i & 7) << 18 | (s & 63) << 12 | (o & 63) << 6 | a & 63) - 65536;
                e[r++] = String.fromCharCode(55296 + (u >> 10)), e[r++] = String.fromCharCode(56320 + (u & 1023))
            } else {
                const s = t[n++],
                    o = t[n++];
                e[r++] = String.fromCharCode((i & 15) << 12 | (s & 63) << 6 | o & 63)
            }
        }
        return e.join("")
    },
    SI = {
        byteToCharMap_: null,
        charToByteMap_: null,
        byteToCharMapWebSafe_: null,
        charToByteMapWebSafe_: null,
        ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
        get ENCODED_VALS() {
            return this.ENCODED_VALS_BASE + "+/="
        },
        get ENCODED_VALS_WEBSAFE() {
            return this.ENCODED_VALS_BASE + "-_."
        },
        HAS_NATIVE_SUPPORT: typeof atob == "function",
        encodeByteArray(t, e) {
            if (!Array.isArray(t)) throw Error("encodeByteArray takes an array as a parameter");
            this.init_();
            const n = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
                r = [];
            for (let i = 0; i < t.length; i += 3) {
                const s = t[i],
                    o = i + 1 < t.length,
                    a = o ? t[i + 1] : 0,
                    u = i + 2 < t.length,
                    c = u ? t[i + 2] : 0,
                    h = s >> 2,
                    f = (s & 3) << 4 | a >> 4;
                let m = (a & 15) << 2 | c >> 6,
                    _ = c & 63;
                u || (_ = 64, o || (m = 64)), r.push(n[h], n[f], n[m], n[_])
            }
            return r.join("")
        },
        encodeString(t, e) {
            return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(II(t), e)
        },
        decodeString(t, e) {
            return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : fx(this.decodeStringToByteArray(t, e))
        },
        decodeStringToByteArray(t, e) {
            this.init_();
            const n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_,
                r = [];
            for (let i = 0; i < t.length;) {
                const s = n[t.charAt(i++)],
                    a = i < t.length ? n[t.charAt(i)] : 0;
                ++i;
                const c = i < t.length ? n[t.charAt(i)] : 64;
                ++i;
                const f = i < t.length ? n[t.charAt(i)] : 64;
                if (++i, s == null || a == null || c == null || f == null) throw new px;
                const m = s << 2 | a >> 4;
                if (r.push(m), c !== 64) {
                    const _ = a << 4 & 240 | c >> 2;
                    if (r.push(_), f !== 64) {
                        const I = c << 6 & 192 | f;
                        r.push(I)
                    }
                }
            }
            return r
        },
        init_() {
            if (!this.byteToCharMap_) {
                this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
                for (let t = 0; t < this.ENCODED_VALS.length; t++) this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t), this.charToByteMap_[this.byteToCharMap_[t]] = t, this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t, t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t)
            }
        }
    };
class px extends Error {
    constructor() {
        super(...arguments), this.name = "DecodeBase64StringError"
    }
}
const mx = function(t) {
        const e = II(t);
        return SI.encodeByteArray(e, !0)
    },
    qu = function(t) {
        return mx(t).replace(/\./g, "")
    },
    AI = function(t) {
        try {
            return SI.decodeString(t, !0)
        } catch (e) {
            console.error("base64Decode failed: ", e)
        }
        return null
    };
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function gx() {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("Unable to locate global object.")
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yx = () => gx().__FIREBASE_DEFAULTS__,
    vx = () => {
        if (typeof process > "u" || typeof c_ > "u") return;
        const t = c_.__FIREBASE_DEFAULTS__;
        if (t) return JSON.parse(t)
    },
    _x = () => {
        if (typeof document > "u") return;
        let t;
        try {
            t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
        } catch {
            return
        }
        const e = t && AI(t[1]);
        return e && JSON.parse(e)
    },
    Uc = () => {
        try {
            return yx() || vx() || _x()
        } catch (t) {
            console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);
            return
        }
    },
    PI = t => {
        var e, n;
        return (n = (e = Uc()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || n === void 0 ? void 0 : n[t]
    },
    RI = t => {
        const e = PI(t);
        if (!e) return;
        const n = e.lastIndexOf(":");
        if (n <= 0 || n + 1 === e.length) throw new Error(`Invalid host ${e} with no separate hostname and port!`);
        const r = parseInt(e.substring(n + 1), 10);
        return e[0] === "[" ? [e.substring(1, n - 1), r] : [e.substring(0, n), r]
    },
    CI = () => {
        var t;
        return (t = Uc()) === null || t === void 0 ? void 0 : t.config
    },
    kI = t => {
        var e;
        return (e = Uc()) === null || e === void 0 ? void 0 : e[`_${t}`]
    };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wx {
    constructor() {
        this.reject = () => {}, this.resolve = () => {}, this.promise = new Promise((e, n) => {
            this.resolve = e, this.reject = n
        })
    }
    wrapCallback(e) {
        return (n, r) => {
            n ? this.reject(n) : this.resolve(r), typeof e == "function" && (this.promise.catch(() => {}), e.length === 1 ? e(n) : e(n, r))
        }
    }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function xI(t, e) {
    if (t.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
    const n = {
            alg: "none",
            type: "JWT"
        },
        r = e || "demo-project",
        i = t.iat || 0,
        s = t.sub || t.user_id;
    if (!s) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
    const o = Object.assign({
        iss: `https://securetoken.google.com/${r}`,
        aud: r,
        iat: i,
        exp: i + 3600,
        auth_time: i,
        sub: s,
        user_id: s,
        firebase: {
            sign_in_provider: "custom",
            identities: {}
        }
    }, t);
    return [qu(JSON.stringify(n)), qu(JSON.stringify(o)), ""].join(".")
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function pt() {
    return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : ""
}

function Tx() {
    return typeof window < "u" && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(pt())
}

function Ex() {
    var t;
    const e = (t = Uc()) === null || t === void 0 ? void 0 : t.forceEnvironment;
    if (e === "node") return !0;
    if (e === "browser") return !1;
    try {
        return Object.prototype.toString.call(global.process) === "[object process]"
    } catch {
        return !1
    }
}

function Ix() {
    return typeof navigator < "u" && navigator.userAgent === "Cloudflare-Workers"
}

function bI() {
    const t = typeof chrome == "object" ? chrome.runtime : typeof browser == "object" ? browser.runtime : void 0;
    return typeof t == "object" && t.id !== void 0
}

function Sx() {
    return typeof navigator == "object" && navigator.product === "ReactNative"
}

function Ax() {
    const t = pt();
    return t.indexOf("MSIE ") >= 0 || t.indexOf("Trident/") >= 0
}

function Px() {
    return !Ex() && !!navigator.userAgent && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome")
}

function Tm() {
    try {
        return typeof indexedDB == "object"
    } catch {
        return !1
    }
}

function Em() {
    return new Promise((t, e) => {
        try {
            let n = !0;
            const r = "validate-browser-context-for-indexeddb-analytics-module",
                i = self.indexedDB.open(r);
            i.onsuccess = () => {
                i.result.close(), n || self.indexedDB.deleteDatabase(r), t(!0)
            }, i.onupgradeneeded = () => {
                n = !1
            }, i.onerror = () => {
                var s;
                e(((s = i.error) === null || s === void 0 ? void 0 : s.message) || "")
            }
        } catch (n) {
            e(n)
        }
    })
}

function NI() {
    return !(typeof navigator > "u" || !navigator.cookieEnabled)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Rx = "FirebaseError";
class en extends Error {
    constructor(e, n, r) {
        super(n), this.code = e, this.customData = r, this.name = Rx, Object.setPrototypeOf(this, en.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Xr.prototype.create)
    }
}
class Xr {
    constructor(e, n, r) {
        this.service = e, this.serviceName = n, this.errors = r
    }
    create(e, ...n) {
        const r = n[0] || {},
            i = `${this.service}/${e}`,
            s = this.errors[e],
            o = s ? Cx(s, r) : "Error",
            a = `${this.serviceName}: ${o} (${i}).`;
        return new en(i, a, r)
    }
}

function Cx(t, e) {
    return t.replace(kx, (n, r) => {
        const i = e[r];
        return i != null ? String(i) : `<${r}?>`
    })
}
const kx = /\{\$([^}]+)}/g;

function xx(t) {
    for (const e in t)
        if (Object.prototype.hasOwnProperty.call(t, e)) return !1;
    return !0
}

function Ia(t, e) {
    if (t === e) return !0;
    const n = Object.keys(t),
        r = Object.keys(e);
    for (const i of n) {
        if (!r.includes(i)) return !1;
        const s = t[i],
            o = e[i];
        if (h_(s) && h_(o)) {
            if (!Ia(s, o)) return !1
        } else if (s !== o) return !1
    }
    for (const i of r)
        if (!n.includes(i)) return !1;
    return !0
}

function h_(t) {
    return t !== null && typeof t == "object"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Wa(t) {
    const e = [];
    for (const [n, r] of Object.entries(t)) Array.isArray(r) ? r.forEach(i => {
        e.push(encodeURIComponent(n) + "=" + encodeURIComponent(i))
    }) : e.push(encodeURIComponent(n) + "=" + encodeURIComponent(r));
    return e.length ? "&" + e.join("&") : ""
}

function bx(t, e) {
    const n = new Nx(t, e);
    return n.subscribe.bind(n)
}
class Nx {
    constructor(e, n) {
        this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = n, this.task.then(() => {
            e(this)
        }).catch(r => {
            this.error(r)
        })
    }
    next(e) {
        this.forEachObserver(n => {
            n.next(e)
        })
    }
    error(e) {
        this.forEachObserver(n => {
            n.error(e)
        }), this.close(e)
    }
    complete() {
        this.forEachObserver(e => {
            e.complete()
        }), this.close()
    }
    subscribe(e, n, r) {
        let i;
        if (e === void 0 && n === void 0 && r === void 0) throw new Error("Missing Observer.");
        Dx(e, ["next", "error", "complete"]) ? i = e : i = {
            next: e,
            error: n,
            complete: r
        }, i.next === void 0 && (i.next = cd), i.error === void 0 && (i.error = cd), i.complete === void 0 && (i.complete = cd);
        const s = this.unsubscribeOne.bind(this, this.observers.length);
        return this.finalized && this.task.then(() => {
            try {
                this.finalError ? i.error(this.finalError) : i.complete()
            } catch {}
        }), this.observers.push(i), s
    }
    unsubscribeOne(e) {
        this.observers === void 0 || this.observers[e] === void 0 || (delete this.observers[e], this.observerCount -= 1, this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this))
    }
    forEachObserver(e) {
        if (!this.finalized)
            for (let n = 0; n < this.observers.length; n++) this.sendOne(n, e)
    }
    sendOne(e, n) {
        this.task.then(() => {
            if (this.observers !== void 0 && this.observers[e] !== void 0) try {
                n(this.observers[e])
            } catch (r) {
                typeof console < "u" && console.error && console.error(r)
            }
        })
    }
    close(e) {
        this.finalized || (this.finalized = !0, e !== void 0 && (this.finalError = e), this.task.then(() => {
            this.observers = void 0, this.onNoObservers = void 0
        }))
    }
}

function Dx(t, e) {
    if (typeof t != "object" || t === null) return !1;
    for (const n of e)
        if (n in t && typeof t[n] == "function") return !0;
    return !1
}

function cd() {}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Vx = 1e3,
    Ox = 2,
    Lx = 4 * 60 * 60 * 1e3,
    Mx = .5;

function d_(t, e = Vx, n = Ox) {
    const r = e * Math.pow(n, t),
        i = Math.round(Mx * r * (Math.random() - .5) * 2);
    return Math.min(Lx, r + i)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ce(t) {
    return t && t._delegate ? t._delegate : t
}
class Nt {
    constructor(e, n, r) {
        this.name = e, this.instanceFactory = n, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null
    }
    setInstantiationMode(e) {
        return this.instantiationMode = e, this
    }
    setMultipleInstances(e) {
        return this.multipleInstances = e, this
    }
    setServiceProps(e) {
        return this.serviceProps = e, this
    }
    setInstanceCreatedCallback(e) {
        return this.onInstanceCreated = e, this
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const hi = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fx {
    constructor(e, n) {
        this.name = e, this.container = n, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map
    }
    get(e) {
        const n = this.normalizeInstanceIdentifier(e);
        if (!this.instancesDeferred.has(n)) {
            const r = new wx;
            if (this.instancesDeferred.set(n, r), this.isInitialized(n) || this.shouldAutoInitialize()) try {
                const i = this.getOrInitializeService({
                    instanceIdentifier: n
                });
                i && r.resolve(i)
            } catch {}
        }
        return this.instancesDeferred.get(n).promise
    }
    getImmediate(e) {
        var n;
        const r = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier),
            i = (n = e == null ? void 0 : e.optional) !== null && n !== void 0 ? n : !1;
        if (this.isInitialized(r) || this.shouldAutoInitialize()) try {
            return this.getOrInitializeService({
                instanceIdentifier: r
            })
        } catch (s) {
            if (i) return null;
            throw s
        } else {
            if (i) return null;
            throw Error(`Service ${this.name} is not available`)
        }
    }
    getComponent() {
        return this.component
    }
    setComponent(e) {
        if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
        if (this.component) throw Error(`Component for ${this.name} has already been provided`);
        if (this.component = e, !!this.shouldAutoInitialize()) {
            if (jx(e)) try {
                this.getOrInitializeService({
                    instanceIdentifier: hi
                })
            } catch {}
            for (const [n, r] of this.instancesDeferred.entries()) {
                const i = this.normalizeInstanceIdentifier(n);
                try {
                    const s = this.getOrInitializeService({
                        instanceIdentifier: i
                    });
                    r.resolve(s)
                } catch {}
            }
        }
    }
    clearInstance(e = hi) {
        this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e)
    }
    async delete() {
        const e = Array.from(this.instances.values());
        await Promise.all([...e.filter(n => "INTERNAL" in n).map(n => n.INTERNAL.delete()), ...e.filter(n => "_delete" in n).map(n => n._delete())])
    }
    isComponentSet() {
        return this.component != null
    }
    isInitialized(e = hi) {
        return this.instances.has(e)
    }
    getOptions(e = hi) {
        return this.instancesOptions.get(e) || {}
    }
    initialize(e = {}) {
        const {
            options: n = {}
        } = e, r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
        if (this.isInitialized(r)) throw Error(`${this.name}(${r}) has already been initialized`);
        if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
        const i = this.getOrInitializeService({
            instanceIdentifier: r,
            options: n
        });
        for (const [s, o] of this.instancesDeferred.entries()) {
            const a = this.normalizeInstanceIdentifier(s);
            r === a && o.resolve(i)
        }
        return i
    }
    onInit(e, n) {
        var r;
        const i = this.normalizeInstanceIdentifier(n),
            s = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : new Set;
        s.add(e), this.onInitCallbacks.set(i, s);
        const o = this.instances.get(i);
        return o && e(o, i), () => {
            s.delete(e)
        }
    }
    invokeOnInitCallbacks(e, n) {
        const r = this.onInitCallbacks.get(n);
        if (r)
            for (const i of r) try {
                i(e, n)
            } catch {}
    }
    getOrInitializeService({
        instanceIdentifier: e,
        options: n = {}
    }) {
        let r = this.instances.get(e);
        if (!r && this.component && (r = this.component.instanceFactory(this.container, {
                instanceIdentifier: Ux(e),
                options: n
            }), this.instances.set(e, r), this.instancesOptions.set(e, n), this.invokeOnInitCallbacks(r, e), this.component.onInstanceCreated)) try {
            this.component.onInstanceCreated(this.container, e, r)
        } catch {}
        return r || null
    }
    normalizeInstanceIdentifier(e = hi) {
        return this.component ? this.component.multipleInstances ? e : hi : e
    }
    shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT"
    }
}

function Ux(t) {
    return t === hi ? void 0 : t
}

function jx(t) {
    return t.instantiationMode === "EAGER"
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bx {
    constructor(e) {
        this.name = e, this.providers = new Map
    }
    addComponent(e) {
        const n = this.getProvider(e.name);
        if (n.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
        n.setComponent(e)
    }
    addOrOverwriteComponent(e) {
        this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e)
    }
    getProvider(e) {
        if (this.providers.has(e)) return this.providers.get(e);
        const n = new Fx(e, this);
        return this.providers.set(e, n), n
    }
    getProviders() {
        return Array.from(this.providers.values())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var te;
(function(t) {
    t[t.DEBUG = 0] = "DEBUG", t[t.VERBOSE = 1] = "VERBOSE", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.SILENT = 5] = "SILENT"
})(te || (te = {}));
const $x = {
        debug: te.DEBUG,
        verbose: te.VERBOSE,
        info: te.INFO,
        warn: te.WARN,
        error: te.ERROR,
        silent: te.SILENT
    },
    zx = te.INFO,
    Wx = {
        [te.DEBUG]: "log",
        [te.VERBOSE]: "log",
        [te.INFO]: "info",
        [te.WARN]: "warn",
        [te.ERROR]: "error"
    },
    qx = (t, e, ...n) => {
        if (e < t.logLevel) return;
        const r = new Date().toISOString(),
            i = Wx[e];
        if (i) console[i](`[${r}]  ${t.name}:`, ...n);
        else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`)
    };
class jc {
    constructor(e) {
        this.name = e, this._logLevel = zx, this._logHandler = qx, this._userLogHandler = null
    }
    get logLevel() {
        return this._logLevel
    }
    set logLevel(e) {
        if (!(e in te)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
        this._logLevel = e
    }
    setLogLevel(e) {
        this._logLevel = typeof e == "string" ? $x[e] : e
    }
    get logHandler() {
        return this._logHandler
    }
    set logHandler(e) {
        if (typeof e != "function") throw new TypeError("Value assigned to `logHandler` must be a function");
        this._logHandler = e
    }
    get userLogHandler() {
        return this._userLogHandler
    }
    set userLogHandler(e) {
        this._userLogHandler = e
    }
    debug(...e) {
        this._userLogHandler && this._userLogHandler(this, te.DEBUG, ...e), this._logHandler(this, te.DEBUG, ...e)
    }
    log(...e) {
        this._userLogHandler && this._userLogHandler(this, te.VERBOSE, ...e), this._logHandler(this, te.VERBOSE, ...e)
    }
    info(...e) {
        this._userLogHandler && this._userLogHandler(this, te.INFO, ...e), this._logHandler(this, te.INFO, ...e)
    }
    warn(...e) {
        this._userLogHandler && this._userLogHandler(this, te.WARN, ...e), this._logHandler(this, te.WARN, ...e)
    }
    error(...e) {
        this._userLogHandler && this._userLogHandler(this, te.ERROR, ...e), this._logHandler(this, te.ERROR, ...e)
    }
}
const Hx = (t, e) => e.some(n => t instanceof n);
let f_, p_;

function Kx() {
    return f_ || (f_ = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}

function Gx() {
    return p_ || (p_ = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
}
const DI = new WeakMap,
    Lf = new WeakMap,
    VI = new WeakMap,
    hd = new WeakMap,
    Im = new WeakMap;

function Qx(t) {
    const e = new Promise((n, r) => {
        const i = () => {
                t.removeEventListener("success", s), t.removeEventListener("error", o)
            },
            s = () => {
                n($n(t.result)), i()
            },
            o = () => {
                r(t.error), i()
            };
        t.addEventListener("success", s), t.addEventListener("error", o)
    });
    return e.then(n => {
        n instanceof IDBCursor && DI.set(n, t)
    }).catch(() => {}), Im.set(e, t), e
}

function Yx(t) {
    if (Lf.has(t)) return;
    const e = new Promise((n, r) => {
        const i = () => {
                t.removeEventListener("complete", s), t.removeEventListener("error", o), t.removeEventListener("abort", o)
            },
            s = () => {
                n(), i()
            },
            o = () => {
                r(t.error || new DOMException("AbortError", "AbortError")), i()
            };
        t.addEventListener("complete", s), t.addEventListener("error", o), t.addEventListener("abort", o)
    });
    Lf.set(t, e)
}
let Mf = {
    get(t, e, n) {
        if (t instanceof IDBTransaction) {
            if (e === "done") return Lf.get(t);
            if (e === "objectStoreNames") return t.objectStoreNames || VI.get(t);
            if (e === "store") return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
        }
        return $n(t[e])
    },
    set(t, e, n) {
        return t[e] = n, !0
    },
    has(t, e) {
        return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t
    }
};

function Xx(t) {
    Mf = t(Mf)
}

function Jx(t) {
    return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
        const r = t.call(dd(this), e, ...n);
        return VI.set(r, e.sort ? e.sort() : [e]), $n(r)
    } : Gx().includes(t) ? function(...e) {
        return t.apply(dd(this), e), $n(DI.get(this))
    } : function(...e) {
        return $n(t.apply(dd(this), e))
    }
}

function Zx(t) {
    return typeof t == "function" ? Jx(t) : (t instanceof IDBTransaction && Yx(t), Hx(t, Kx()) ? new Proxy(t, Mf) : t)
}

function $n(t) {
    if (t instanceof IDBRequest) return Qx(t);
    if (hd.has(t)) return hd.get(t);
    const e = Zx(t);
    return e !== t && (hd.set(t, e), Im.set(e, t)), e
}
const dd = t => Im.get(t);

function Bc(t, e, {
    blocked: n,
    upgrade: r,
    blocking: i,
    terminated: s
} = {}) {
    const o = indexedDB.open(t, e),
        a = $n(o);
    return r && o.addEventListener("upgradeneeded", u => {
        r($n(o.result), u.oldVersion, u.newVersion, $n(o.transaction), u)
    }), n && o.addEventListener("blocked", u => n(u.oldVersion, u.newVersion, u)), a.then(u => {
        s && u.addEventListener("close", () => s()), i && u.addEventListener("versionchange", c => i(c.oldVersion, c.newVersion, c))
    }).catch(() => {}), a
}

function fd(t, {
    blocked: e
} = {}) {
    const n = indexedDB.deleteDatabase(t);
    return e && n.addEventListener("blocked", r => e(r.oldVersion, r)), $n(n).then(() => {})
}
const eb = ["get", "getKey", "getAll", "getAllKeys", "count"],
    tb = ["put", "add", "delete", "clear"],
    pd = new Map;

function m_(t, e) {
    if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string")) return;
    if (pd.get(e)) return pd.get(e);
    const n = e.replace(/FromIndex$/, ""),
        r = e !== n,
        i = tb.includes(n);
    if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || eb.includes(n))) return;
    const s = async function(o, ...a) {
        const u = this.transaction(o, i ? "readwrite" : "readonly");
        let c = u.store;
        return r && (c = c.index(a.shift())), (await Promise.all([c[n](...a), i && u.done]))[0]
    };
    return pd.set(e, s), s
}
Xx(t => ({ ...t,
    get: (e, n, r) => m_(e, n) || t.get(e, n, r),
    has: (e, n) => !!m_(e, n) || t.has(e, n)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class nb {
    constructor(e) {
        this.container = e
    }
    getPlatformInfoString() {
        return this.container.getProviders().map(n => {
            if (rb(n)) {
                const r = n.getImmediate();
                return `${r.library}/${r.version}`
            } else return null
        }).filter(n => n).join(" ")
    }
}

function rb(t) {
    const e = t.getComponent();
    return (e == null ? void 0 : e.type) === "VERSION"
}
const Ff = "@firebase/app",
    g_ = "0.10.16";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Jn = new jc("@firebase/app"),
    ib = "@firebase/app-compat",
    sb = "@firebase/analytics-compat",
    ob = "@firebase/analytics",
    ab = "@firebase/app-check-compat",
    lb = "@firebase/app-check",
    ub = "@firebase/auth",
    cb = "@firebase/auth-compat",
    hb = "@firebase/database",
    db = "@firebase/data-connect",
    fb = "@firebase/database-compat",
    pb = "@firebase/functions",
    mb = "@firebase/functions-compat",
    gb = "@firebase/installations",
    yb = "@firebase/installations-compat",
    vb = "@firebase/messaging",
    _b = "@firebase/messaging-compat",
    wb = "@firebase/performance",
    Tb = "@firebase/performance-compat",
    Eb = "@firebase/remote-config",
    Ib = "@firebase/remote-config-compat",
    Sb = "@firebase/storage",
    Ab = "@firebase/storage-compat",
    Pb = "@firebase/firestore",
    Rb = "@firebase/vertexai",
    Cb = "@firebase/firestore-compat",
    kb = "firebase",
    xb = "11.0.2";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Uf = "[DEFAULT]",
    bb = {
        [Ff]: "fire-core",
        [ib]: "fire-core-compat",
        [ob]: "fire-analytics",
        [sb]: "fire-analytics-compat",
        [lb]: "fire-app-check",
        [ab]: "fire-app-check-compat",
        [ub]: "fire-auth",
        [cb]: "fire-auth-compat",
        [hb]: "fire-rtdb",
        [db]: "fire-data-connect",
        [fb]: "fire-rtdb-compat",
        [pb]: "fire-fn",
        [mb]: "fire-fn-compat",
        [gb]: "fire-iid",
        [yb]: "fire-iid-compat",
        [vb]: "fire-fcm",
        [_b]: "fire-fcm-compat",
        [wb]: "fire-perf",
        [Tb]: "fire-perf-compat",
        [Eb]: "fire-rc",
        [Ib]: "fire-rc-compat",
        [Sb]: "fire-gcs",
        [Ab]: "fire-gcs-compat",
        [Pb]: "fire-fst",
        [Cb]: "fire-fst-compat",
        [Rb]: "fire-vertex",
        "fire-js": "fire-js",
        [kb]: "fire-js-all"
    };
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Hu = new Map,
    Nb = new Map,
    jf = new Map;

function y_(t, e) {
    try {
        t.container.addComponent(e)
    } catch (n) {
        Jn.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, n)
    }
}

function jt(t) {
    const e = t.name;
    if (jf.has(e)) return Jn.debug(`There were multiple attempts to register component ${e}.`), !1;
    jf.set(e, t);
    for (const n of Hu.values()) y_(n, t);
    for (const n of Nb.values()) y_(n, t);
    return !0
}

function ir(t, e) {
    const n = t.container.getProvider("heartbeat").getImmediate({
        optional: !0
    });
    return n && n.triggerHeartbeat(), t.container.getProvider(e)
}

function Sr(t) {
    return t.settings !== void 0
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Db = {
        "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
        "bad-app-name": "Illegal App name: '{$appName}'",
        "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
        "app-deleted": "Firebase App named '{$appName}' already deleted",
        "server-app-deleted": "Firebase Server App has been deleted",
        "no-options": "Need to provide options, when not being deployed to hosting via source.",
        "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
        "invalid-log-argument": "First argument to `onLog` must be null or a function.",
        "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
        "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
        "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
        "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
        "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
        "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
    },
    Or = new Xr("app", "Firebase", Db);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vb {
    constructor(e, n, r) {
        this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, n), this._name = n.name, this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled, this._container = r, this.container.addComponent(new Nt("app", () => this, "PUBLIC"))
    }
    get automaticDataCollectionEnabled() {
        return this.checkDestroyed(), this._automaticDataCollectionEnabled
    }
    set automaticDataCollectionEnabled(e) {
        this.checkDestroyed(), this._automaticDataCollectionEnabled = e
    }
    get name() {
        return this.checkDestroyed(), this._name
    }
    get options() {
        return this.checkDestroyed(), this._options
    }
    get config() {
        return this.checkDestroyed(), this._config
    }
    get container() {
        return this._container
    }
    get isDeleted() {
        return this._isDeleted
    }
    set isDeleted(e) {
        this._isDeleted = e
    }
    checkDestroyed() {
        if (this.isDeleted) throw Or.create("app-deleted", {
            appName: this._name
        })
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Li = xb;

function OI(t, e = {}) {
    let n = t;
    typeof e != "object" && (e = {
        name: e
    });
    const r = Object.assign({
            name: Uf,
            automaticDataCollectionEnabled: !1
        }, e),
        i = r.name;
    if (typeof i != "string" || !i) throw Or.create("bad-app-name", {
        appName: String(i)
    });
    if (n || (n = CI()), !n) throw Or.create("no-options");
    const s = Hu.get(i);
    if (s) {
        if (Ia(n, s.options) && Ia(r, s.config)) return s;
        throw Or.create("duplicate-app", {
            appName: i
        })
    }
    const o = new Bx(i);
    for (const u of jf.values()) o.addComponent(u);
    const a = new Vb(n, r, o);
    return Hu.set(i, a), a
}

function qa(t = Uf) {
    const e = Hu.get(t);
    if (!e && t === Uf && CI()) return OI();
    if (!e) throw Or.create("no-app", {
        appName: t
    });
    return e
}

function ct(t, e, n) {
    var r;
    let i = (r = bb[t]) !== null && r !== void 0 ? r : t;
    n && (i += `-${n}`);
    const s = i.match(/\s|\//),
        o = e.match(/\s|\//);
    if (s || o) {
        const a = [`Unable to register library "${i}" with version "${e}":`];
        s && a.push(`library name "${i}" contains illegal characters (whitespace or "/")`), s && o && a.push("and"), o && a.push(`version name "${e}" contains illegal characters (whitespace or "/")`), Jn.warn(a.join(" "));
        return
    }
    jt(new Nt(`${i}-version`, () => ({
        library: i,
        version: e
    }), "VERSION"))
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ob = "firebase-heartbeat-database",
    Lb = 1,
    Sa = "firebase-heartbeat-store";
let md = null;

function LI() {
    return md || (md = Bc(Ob, Lb, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    try {
                        t.createObjectStore(Sa)
                    } catch (n) {
                        console.warn(n)
                    }
            }
        }
    }).catch(t => {
        throw Or.create("idb-open", {
            originalErrorMessage: t.message
        })
    })), md
}
async function Mb(t) {
    try {
        const n = (await LI()).transaction(Sa),
            r = await n.objectStore(Sa).get(MI(t));
        return await n.done, r
    } catch (e) {
        if (e instanceof en) Jn.warn(e.message);
        else {
            const n = Or.create("idb-get", {
                originalErrorMessage: e == null ? void 0 : e.message
            });
            Jn.warn(n.message)
        }
    }
}
async function v_(t, e) {
    try {
        const r = (await LI()).transaction(Sa, "readwrite");
        await r.objectStore(Sa).put(e, MI(t)), await r.done
    } catch (n) {
        if (n instanceof en) Jn.warn(n.message);
        else {
            const r = Or.create("idb-set", {
                originalErrorMessage: n == null ? void 0 : n.message
            });
            Jn.warn(r.message)
        }
    }
}

function MI(t) {
    return `${t.name}!${t.options.appId}`
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Fb = 1024,
    Ub = 30 * 24 * 60 * 60 * 1e3;
class jb {
    constructor(e) {
        this.container = e, this._heartbeatsCache = null;
        const n = this.container.getProvider("app").getImmediate();
        this._storage = new $b(n), this._heartbeatsCachePromise = this._storage.read().then(r => (this._heartbeatsCache = r, r))
    }
    async triggerHeartbeat() {
        var e, n;
        try {
            const i = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),
                s = __();
            return ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === s || this._heartbeatsCache.heartbeats.some(o => o.date === s) ? void 0 : (this._heartbeatsCache.heartbeats.push({
                date: s,
                agent: i
            }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(o => {
                const a = new Date(o.date).valueOf();
                return Date.now() - a <= Ub
            }), this._storage.overwrite(this._heartbeatsCache))
        } catch (r) {
            Jn.warn(r)
        }
    }
    async getHeartbeatsHeader() {
        var e;
        try {
            if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) return "";
            const n = __(),
                {
                    heartbeatsToSend: r,
                    unsentEntries: i
                } = Bb(this._heartbeatsCache.heartbeats),
                s = qu(JSON.stringify({
                    version: 2,
                    heartbeats: r
                }));
            return this._heartbeatsCache.lastSentHeartbeatDate = n, i.length > 0 ? (this._heartbeatsCache.heartbeats = i, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s
        } catch (n) {
            return Jn.warn(n), ""
        }
    }
}

function __() {
    return new Date().toISOString().substring(0, 10)
}

function Bb(t, e = Fb) {
    const n = [];
    let r = t.slice();
    for (const i of t) {
        const s = n.find(o => o.agent === i.agent);
        if (s) {
            if (s.dates.push(i.date), w_(n) > e) {
                s.dates.pop();
                break
            }
        } else if (n.push({
                agent: i.agent,
                dates: [i.date]
            }), w_(n) > e) {
            n.pop();
            break
        }
        r = r.slice(1)
    }
    return {
        heartbeatsToSend: n,
        unsentEntries: r
    }
}
class $b {
    constructor(e) {
        this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck()
    }
    async runIndexedDBEnvironmentCheck() {
        return Tm() ? Em().then(() => !0).catch(() => !1) : !1
    }
    async read() {
        if (await this._canUseIndexedDBPromise) {
            const n = await Mb(this.app);
            return n != null && n.heartbeats ? n : {
                heartbeats: []
            }
        } else return {
            heartbeats: []
        }
    }
    async overwrite(e) {
        var n;
        if (await this._canUseIndexedDBPromise) {
            const i = await this.read();
            return v_(this.app, {
                lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
                heartbeats: e.heartbeats
            })
        } else return
    }
    async add(e) {
        var n;
        if (await this._canUseIndexedDBPromise) {
            const i = await this.read();
            return v_(this.app, {
                lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
                heartbeats: [...i.heartbeats, ...e.heartbeats]
            })
        } else return
    }
}

function w_(t) {
    return qu(JSON.stringify({
        version: 2,
        heartbeats: t
    })).length
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function zb(t) {
    jt(new Nt("platform-logger", e => new nb(e), "PRIVATE")), jt(new Nt("heartbeat", e => new jb(e), "PRIVATE")), ct(Ff, g_, t), ct(Ff, g_, "esm2017"), ct("fire-js", "")
}
zb("");
var Wb = "firebase",
    qb = "11.0.2";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
ct(Wb, qb, "app");
const FI = "@firebase/installations",
    Sm = "0.6.11";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const UI = 1e4,
    jI = `w:${Sm}`,
    BI = "FIS_v2",
    Hb = "https://firebaseinstallations.googleapis.com/v1",
    Kb = 60 * 60 * 1e3,
    Gb = "installations",
    Qb = "Installations";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yb = {
        "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
        "not-registered": "Firebase Installation is not registered.",
        "installation-not-found": "Firebase Installation not found.",
        "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
        "app-offline": "Could not process request. Application offline.",
        "delete-pending-registration": "Can't delete installation while there is a pending registration request."
    },
    xi = new Xr(Gb, Qb, Yb);

function $I(t) {
    return t instanceof en && t.code.includes("request-failed")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function zI({
    projectId: t
}) {
    return `${Hb}/projects/${t}/installations`
}

function WI(t) {
    return {
        token: t.token,
        requestStatus: 2,
        expiresIn: Jb(t.expiresIn),
        creationTime: Date.now()
    }
}
async function qI(t, e) {
    const r = (await e.json()).error;
    return xi.create("request-failed", {
        requestName: t,
        serverCode: r.code,
        serverMessage: r.message,
        serverStatus: r.status
    })
}

function HI({
    apiKey: t
}) {
    return new Headers({
        "Content-Type": "application/json",
        Accept: "application/json",
        "x-goog-api-key": t
    })
}

function Xb(t, {
    refreshToken: e
}) {
    const n = HI(t);
    return n.append("Authorization", Zb(e)), n
}
async function KI(t) {
    const e = await t();
    return e.status >= 500 && e.status < 600 ? t() : e
}

function Jb(t) {
    return Number(t.replace("s", "000"))
}

function Zb(t) {
    return `${BI} ${t}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function eN({
    appConfig: t,
    heartbeatServiceProvider: e
}, {
    fid: n
}) {
    const r = zI(t),
        i = HI(t),
        s = e.getImmediate({
            optional: !0
        });
    if (s) {
        const c = await s.getHeartbeatsHeader();
        c && i.append("x-firebase-client", c)
    }
    const o = {
            fid: n,
            authVersion: BI,
            appId: t.appId,
            sdkVersion: jI
        },
        a = {
            method: "POST",
            headers: i,
            body: JSON.stringify(o)
        },
        u = await KI(() => fetch(r, a));
    if (u.ok) {
        const c = await u.json();
        return {
            fid: c.fid || n,
            registrationStatus: 2,
            refreshToken: c.refreshToken,
            authToken: WI(c.authToken)
        }
    } else throw await qI("Create Installation", u)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function GI(t) {
    return new Promise(e => {
        setTimeout(e, t)
    })
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function tN(t) {
    return btoa(String.fromCharCode(...t)).replace(/\+/g, "-").replace(/\//g, "_")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nN = /^[cdef][\w-]{21}$/,
    Bf = "";

function rN() {
    try {
        const t = new Uint8Array(17);
        (self.crypto || self.msCrypto).getRandomValues(t), t[0] = 112 + t[0] % 16;
        const n = iN(t);
        return nN.test(n) ? n : Bf
    } catch {
        return Bf
    }
}

function iN(t) {
    return tN(t).substr(0, 22)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $c(t) {
    return `${t.appName}!${t.appId}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const QI = new Map;

function YI(t, e) {
    const n = $c(t);
    XI(n, e), sN(n, e)
}

function XI(t, e) {
    const n = QI.get(t);
    if (n)
        for (const r of n) r(e)
}

function sN(t, e) {
    const n = oN();
    n && n.postMessage({
        key: t,
        fid: e
    }), aN()
}
let yi = null;

function oN() {
    return !yi && "BroadcastChannel" in self && (yi = new BroadcastChannel("[Firebase] FID Change"), yi.onmessage = t => {
        XI(t.data.key, t.data.fid)
    }), yi
}

function aN() {
    QI.size === 0 && yi && (yi.close(), yi = null)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const lN = "firebase-installations-database",
    uN = 1,
    bi = "firebase-installations-store";
let gd = null;

function Am() {
    return gd || (gd = Bc(lN, uN, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    t.createObjectStore(bi)
            }
        }
    })), gd
}
async function Ku(t, e) {
    const n = $c(t),
        i = (await Am()).transaction(bi, "readwrite"),
        s = i.objectStore(bi),
        o = await s.get(n);
    return await s.put(e, n), await i.done, (!o || o.fid !== e.fid) && YI(t, e.fid), e
}
async function JI(t) {
    const e = $c(t),
        r = (await Am()).transaction(bi, "readwrite");
    await r.objectStore(bi).delete(e), await r.done
}
async function zc(t, e) {
    const n = $c(t),
        i = (await Am()).transaction(bi, "readwrite"),
        s = i.objectStore(bi),
        o = await s.get(n),
        a = e(o);
    return a === void 0 ? await s.delete(n) : await s.put(a, n), await i.done, a && (!o || o.fid !== a.fid) && YI(t, a.fid), a
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Pm(t) {
    let e;
    const n = await zc(t.appConfig, r => {
        const i = cN(r),
            s = hN(t, i);
        return e = s.registrationPromise, s.installationEntry
    });
    return n.fid === Bf ? {
        installationEntry: await e
    } : {
        installationEntry: n,
        registrationPromise: e
    }
}

function cN(t) {
    const e = t || {
        fid: rN(),
        registrationStatus: 0
    };
    return ZI(e)
}

function hN(t, e) {
    if (e.registrationStatus === 0) {
        if (!navigator.onLine) {
            const i = Promise.reject(xi.create("app-offline"));
            return {
                installationEntry: e,
                registrationPromise: i
            }
        }
        const n = {
                fid: e.fid,
                registrationStatus: 1,
                registrationTime: Date.now()
            },
            r = dN(t, n);
        return {
            installationEntry: n,
            registrationPromise: r
        }
    } else return e.registrationStatus === 1 ? {
        installationEntry: e,
        registrationPromise: fN(t)
    } : {
        installationEntry: e
    }
}
async function dN(t, e) {
    try {
        const n = await eN(t, e);
        return Ku(t.appConfig, n)
    } catch (n) {
        throw $I(n) && n.customData.serverCode === 409 ? await JI(t.appConfig) : await Ku(t.appConfig, {
            fid: e.fid,
            registrationStatus: 0
        }), n
    }
}
async function fN(t) {
    let e = await T_(t.appConfig);
    for (; e.registrationStatus === 1;) await GI(100), e = await T_(t.appConfig);
    if (e.registrationStatus === 0) {
        const {
            installationEntry: n,
            registrationPromise: r
        } = await Pm(t);
        return r || n
    }
    return e
}

function T_(t) {
    return zc(t, e => {
        if (!e) throw xi.create("installation-not-found");
        return ZI(e)
    })
}

function ZI(t) {
    return pN(t) ? {
        fid: t.fid,
        registrationStatus: 0
    } : t
}

function pN(t) {
    return t.registrationStatus === 1 && t.registrationTime + UI < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function mN({
    appConfig: t,
    heartbeatServiceProvider: e
}, n) {
    const r = gN(t, n),
        i = Xb(t, n),
        s = e.getImmediate({
            optional: !0
        });
    if (s) {
        const c = await s.getHeartbeatsHeader();
        c && i.append("x-firebase-client", c)
    }
    const o = {
            installation: {
                sdkVersion: jI,
                appId: t.appId
            }
        },
        a = {
            method: "POST",
            headers: i,
            body: JSON.stringify(o)
        },
        u = await KI(() => fetch(r, a));
    if (u.ok) {
        const c = await u.json();
        return WI(c)
    } else throw await qI("Generate Auth Token", u)
}

function gN(t, {
    fid: e
}) {
    return `${zI(t)}/${e}/authTokens:generate`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Rm(t, e = !1) {
    let n;
    const r = await zc(t.appConfig, s => {
        if (!eS(s)) throw xi.create("not-registered");
        const o = s.authToken;
        if (!e && _N(o)) return s;
        if (o.requestStatus === 1) return n = yN(t, e), s; {
            if (!navigator.onLine) throw xi.create("app-offline");
            const a = TN(s);
            return n = vN(t, a), a
        }
    });
    return n ? await n : r.authToken
}
async function yN(t, e) {
    let n = await E_(t.appConfig);
    for (; n.authToken.requestStatus === 1;) await GI(100), n = await E_(t.appConfig);
    const r = n.authToken;
    return r.requestStatus === 0 ? Rm(t, e) : r
}

function E_(t) {
    return zc(t, e => {
        if (!eS(e)) throw xi.create("not-registered");
        const n = e.authToken;
        return EN(n) ? Object.assign(Object.assign({}, e), {
            authToken: {
                requestStatus: 0
            }
        }) : e
    })
}
async function vN(t, e) {
    try {
        const n = await mN(t, e),
            r = Object.assign(Object.assign({}, e), {
                authToken: n
            });
        return await Ku(t.appConfig, r), n
    } catch (n) {
        if ($I(n) && (n.customData.serverCode === 401 || n.customData.serverCode === 404)) await JI(t.appConfig);
        else {
            const r = Object.assign(Object.assign({}, e), {
                authToken: {
                    requestStatus: 0
                }
            });
            await Ku(t.appConfig, r)
        }
        throw n
    }
}

function eS(t) {
    return t !== void 0 && t.registrationStatus === 2
}

function _N(t) {
    return t.requestStatus === 2 && !wN(t)
}

function wN(t) {
    const e = Date.now();
    return e < t.creationTime || t.creationTime + t.expiresIn < e + Kb
}

function TN(t) {
    const e = {
        requestStatus: 1,
        requestTime: Date.now()
    };
    return Object.assign(Object.assign({}, t), {
        authToken: e
    })
}

function EN(t) {
    return t.requestStatus === 1 && t.requestTime + UI < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function IN(t) {
    const e = t,
        {
            installationEntry: n,
            registrationPromise: r
        } = await Pm(e);
    return r ? r.catch(console.error) : Rm(e).catch(console.error), n.fid
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function SN(t, e = !1) {
    const n = t;
    return await AN(n), (await Rm(n, e)).token
}
async function AN(t) {
    const {
        registrationPromise: e
    } = await Pm(t);
    e && await e
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function PN(t) {
    if (!t || !t.options) throw yd("App Configuration");
    if (!t.name) throw yd("App Name");
    const e = ["projectId", "apiKey", "appId"];
    for (const n of e)
        if (!t.options[n]) throw yd(n);
    return {
        appName: t.name,
        projectId: t.options.projectId,
        apiKey: t.options.apiKey,
        appId: t.options.appId
    }
}

function yd(t) {
    return xi.create("missing-app-config-values", {
        valueName: t
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tS = "installations",
    RN = "installations-internal",
    CN = t => {
        const e = t.getProvider("app").getImmediate(),
            n = PN(e),
            r = ir(e, "heartbeat");
        return {
            app: e,
            appConfig: n,
            heartbeatServiceProvider: r,
            _delete: () => Promise.resolve()
        }
    },
    kN = t => {
        const e = t.getProvider("app").getImmediate(),
            n = ir(e, tS).getImmediate();
        return {
            getId: () => IN(n),
            getToken: i => SN(n, i)
        }
    };

function xN() {
    jt(new Nt(tS, CN, "PUBLIC")), jt(new Nt(RN, kN, "PRIVATE"))
}
xN();
ct(FI, Sm);
ct(FI, Sm, "esm2017");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Gu = "analytics",
    bN = "firebase_id",
    NN = "origin",
    DN = 60 * 1e3,
    VN = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig",
    Cm = "https://www.googletagmanager.com/gtag/js";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xt = new jc("@firebase/analytics");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ON = {
        "already-exists": "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.",
        "already-initialized": "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-initialized instance.",
        "already-initialized-settings": "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.",
        "interop-component-reg-failed": "Firebase Analytics Interop Component failed to instantiate: {$reason}",
        "invalid-analytics-context": "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
        "indexeddb-unavailable": "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
        "fetch-throttle": "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.",
        "config-fetch-failed": "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}",
        "no-api-key": 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',
        "no-app-id": 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.',
        "no-client-id": 'The "client_id" field is empty.',
        "invalid-gtag-resource": "Trusted Types detected an invalid gtag resource: {$gtagURL}."
    },
    Ft = new Xr("analytics", "Analytics", ON);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function LN(t) {
    if (!t.startsWith(Cm)) {
        const e = Ft.create("invalid-gtag-resource", {
            gtagURL: t
        });
        return xt.warn(e.message), ""
    }
    return t
}

function nS(t) {
    return Promise.all(t.map(e => e.catch(n => n)))
}

function MN(t, e) {
    let n;
    return window.trustedTypes && (n = window.trustedTypes.createPolicy(t, e)), n
}

function FN(t, e) {
    const n = MN("firebase-js-sdk-policy", {
            createScriptURL: LN
        }),
        r = document.createElement("script"),
        i = `${Cm}?l=${t}&id=${e}`;
    r.src = n ? n == null ? void 0 : n.createScriptURL(i) : i, r.async = !0, document.head.appendChild(r)
}

function UN(t) {
    let e = [];
    return Array.isArray(window[t]) ? e = window[t] : window[t] = e, e
}
async function jN(t, e, n, r, i, s) {
    const o = r[i];
    try {
        if (o) await e[o];
        else {
            const u = (await nS(n)).find(c => c.measurementId === i);
            u && await e[u.appId]
        }
    } catch (a) {
        xt.error(a)
    }
    t("config", i, s)
}
async function BN(t, e, n, r, i) {
    try {
        let s = [];
        if (i && i.send_to) {
            let o = i.send_to;
            Array.isArray(o) || (o = [o]);
            const a = await nS(n);
            for (const u of o) {
                const c = a.find(f => f.measurementId === u),
                    h = c && e[c.appId];
                if (h) s.push(h);
                else {
                    s = [];
                    break
                }
            }
        }
        s.length === 0 && (s = Object.values(e)), await Promise.all(s), t("event", r, i || {})
    } catch (s) {
        xt.error(s)
    }
}

function $N(t, e, n, r) {
    async function i(s, ...o) {
        try {
            if (s === "event") {
                const [a, u] = o;
                await BN(t, e, n, a, u)
            } else if (s === "config") {
                const [a, u] = o;
                await jN(t, e, n, r, a, u)
            } else if (s === "consent") {
                const [a, u] = o;
                t("consent", a, u)
            } else if (s === "get") {
                const [a, u, c] = o;
                t("get", a, u, c)
            } else if (s === "set") {
                const [a] = o;
                t("set", a)
            } else t(s, ...o)
        } catch (a) {
            xt.error(a)
        }
    }
    return i
}

function zN(t, e, n, r, i) {
    let s = function(...o) {
        window[r].push(arguments)
    };
    return window[i] && typeof window[i] == "function" && (s = window[i]), window[i] = $N(s, t, e, n), {
        gtagCore: s,
        wrappedGtag: window[i]
    }
}

function WN(t) {
    const e = window.document.getElementsByTagName("script");
    for (const n of Object.values(e))
        if (n.src && n.src.includes(Cm) && n.src.includes(t)) return n;
    return null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const qN = 30,
    HN = 1e3;
class KN {
    constructor(e = {}, n = HN) {
        this.throttleMetadata = e, this.intervalMillis = n
    }
    getThrottleMetadata(e) {
        return this.throttleMetadata[e]
    }
    setThrottleMetadata(e, n) {
        this.throttleMetadata[e] = n
    }
    deleteThrottleMetadata(e) {
        delete this.throttleMetadata[e]
    }
}
const rS = new KN;

function GN(t) {
    return new Headers({
        Accept: "application/json",
        "x-goog-api-key": t
    })
}
async function QN(t) {
    var e;
    const {
        appId: n,
        apiKey: r
    } = t, i = {
        method: "GET",
        headers: GN(r)
    }, s = VN.replace("{app-id}", n), o = await fetch(s, i);
    if (o.status !== 200 && o.status !== 304) {
        let a = "";
        try {
            const u = await o.json();
            !((e = u.error) === null || e === void 0) && e.message && (a = u.error.message)
        } catch {}
        throw Ft.create("config-fetch-failed", {
            httpStatus: o.status,
            responseMessage: a
        })
    }
    return o.json()
}
async function YN(t, e = rS, n) {
    const {
        appId: r,
        apiKey: i,
        measurementId: s
    } = t.options;
    if (!r) throw Ft.create("no-app-id");
    if (!i) {
        if (s) return {
            measurementId: s,
            appId: r
        };
        throw Ft.create("no-api-key")
    }
    const o = e.getThrottleMetadata(r) || {
            backoffCount: 0,
            throttleEndTimeMillis: Date.now()
        },
        a = new ZN;
    return setTimeout(async () => {
        a.abort()
    }, DN), iS({
        appId: r,
        apiKey: i,
        measurementId: s
    }, o, a, e)
}
async function iS(t, {
    throttleEndTimeMillis: e,
    backoffCount: n
}, r, i = rS) {
    var s;
    const {
        appId: o,
        measurementId: a
    } = t;
    try {
        await XN(r, e)
    } catch (u) {
        if (a) return xt.warn(`Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${a} provided in the "measurementId" field in the local Firebase config. [${u==null?void 0:u.message}]`), {
            appId: o,
            measurementId: a
        };
        throw u
    }
    try {
        const u = await QN(t);
        return i.deleteThrottleMetadata(o), u
    } catch (u) {
        const c = u;
        if (!JN(c)) {
            if (i.deleteThrottleMetadata(o), a) return xt.warn(`Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${a} provided in the "measurementId" field in the local Firebase config. [${c==null?void 0:c.message}]`), {
                appId: o,
                measurementId: a
            };
            throw u
        }
        const h = Number((s = c == null ? void 0 : c.customData) === null || s === void 0 ? void 0 : s.httpStatus) === 503 ? d_(n, i.intervalMillis, qN) : d_(n, i.intervalMillis),
            f = {
                throttleEndTimeMillis: Date.now() + h,
                backoffCount: n + 1
            };
        return i.setThrottleMetadata(o, f), xt.debug(`Calling attemptFetch again in ${h} millis`), iS(t, f, r, i)
    }
}

function XN(t, e) {
    return new Promise((n, r) => {
        const i = Math.max(e - Date.now(), 0),
            s = setTimeout(n, i);
        t.addEventListener(() => {
            clearTimeout(s), r(Ft.create("fetch-throttle", {
                throttleEndTimeMillis: e
            }))
        })
    })
}

function JN(t) {
    if (!(t instanceof en) || !t.customData) return !1;
    const e = Number(t.customData.httpStatus);
    return e === 429 || e === 500 || e === 503 || e === 504
}
class ZN {
    constructor() {
        this.listeners = []
    }
    addEventListener(e) {
        this.listeners.push(e)
    }
    abort() {
        this.listeners.forEach(e => e())
    }
}
async function eD(t, e, n, r, i) {
    if (i && i.global) {
        t("event", n, r);
        return
    } else {
        const s = await e,
            o = Object.assign(Object.assign({}, r), {
                send_to: s
            });
        t("event", n, o)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function tD() {
    if (Tm()) try {
        await Em()
    } catch (t) {
        return xt.warn(Ft.create("indexeddb-unavailable", {
            errorInfo: t == null ? void 0 : t.toString()
        }).message), !1
    } else return xt.warn(Ft.create("indexeddb-unavailable", {
        errorInfo: "IndexedDB is not available in this environment."
    }).message), !1;
    return !0
}
async function nD(t, e, n, r, i, s, o) {
    var a;
    const u = YN(t);
    u.then(_ => {
        n[_.measurementId] = _.appId, t.options.measurementId && _.measurementId !== t.options.measurementId && xt.warn(`The measurement ID in the local Firebase config (${t.options.measurementId}) does not match the measurement ID fetched from the server (${_.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`)
    }).catch(_ => xt.error(_)), e.push(u);
    const c = tD().then(_ => {
            if (_) return r.getId()
        }),
        [h, f] = await Promise.all([u, c]);
    WN(s) || FN(s, h.measurementId), i("js", new Date);
    const m = (a = o == null ? void 0 : o.config) !== null && a !== void 0 ? a : {};
    return m[NN] = "firebase", m.update = !0, f != null && (m[bN] = f), i("config", h.measurementId, m), h.measurementId
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class rD {
    constructor(e) {
        this.app = e
    }
    _delete() {
        return delete Qo[this.app.options.appId], Promise.resolve()
    }
}
let Qo = {},
    I_ = [];
const S_ = {};
let vd = "dataLayer",
    iD = "gtag",
    A_, sS, P_ = !1;

function sD() {
    const t = [];
    if (bI() && t.push("This is a browser extension environment."), NI() || t.push("Cookies are not available."), t.length > 0) {
        const e = t.map((r, i) => `(${i+1}) ${r}`).join(" "),
            n = Ft.create("invalid-analytics-context", {
                errorInfo: e
            });
        xt.warn(n.message)
    }
}

function oD(t, e, n) {
    sD();
    const r = t.options.appId;
    if (!r) throw Ft.create("no-app-id");
    if (!t.options.apiKey)
        if (t.options.measurementId) xt.warn(`The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${t.options.measurementId} provided in the "measurementId" field in the local Firebase config.`);
        else throw Ft.create("no-api-key");
    if (Qo[r] != null) throw Ft.create("already-exists", {
        id: r
    });
    if (!P_) {
        UN(vd);
        const {
            wrappedGtag: s,
            gtagCore: o
        } = zN(Qo, I_, S_, vd, iD);
        sS = s, A_ = o, P_ = !0
    }
    return Qo[r] = nD(t, I_, S_, e, A_, vd, n), new rD(t)
}

function aD(t = qa()) {
    t = Ce(t);
    const e = ir(t, Gu);
    return e.isInitialized() ? e.getImmediate() : lD(t)
}

function lD(t, e = {}) {
    const n = ir(t, Gu);
    if (n.isInitialized()) {
        const i = n.getImmediate();
        if (Ia(e, n.getOptions())) return i;
        throw Ft.create("already-initialized")
    }
    return n.initialize({
        options: e
    })
}

function $f(t, e, n, r) {
    t = Ce(t), eD(sS, Qo[t.app.options.appId], e, n, r).catch(i => xt.error(i))
}
const R_ = "@firebase/analytics",
    C_ = "0.10.10";

function uD() {
    jt(new Nt(Gu, (e, {
        options: n
    }) => {
        const r = e.getProvider("app").getImmediate(),
            i = e.getProvider("installations-internal").getImmediate();
        return oD(r, i, n)
    }, "PUBLIC")), jt(new Nt("analytics-internal", t, "PRIVATE")), ct(R_, C_), ct(R_, C_, "esm2017");

    function t(e) {
        try {
            const n = e.getProvider(Gu).getImmediate();
            return {
                logEvent: (r, i, s) => $f(n, r, i, s)
            }
        } catch (n) {
            throw Ft.create("interop-component-reg-failed", {
                reason: n
            })
        }
    }
}
uD();
var k_ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var Ei, oS;
(function() {
    var t;
    /** @license

     Copyright The Closure Library Authors.
     SPDX-License-Identifier: Apache-2.0
    */
    function e(S, g) {
        function E() {}
        E.prototype = g.prototype, S.D = g.prototype, S.prototype = new E, S.prototype.constructor = S, S.C = function(A, C, b) {
            for (var P = Array(arguments.length - 2), ze = 2; ze < arguments.length; ze++) P[ze - 2] = arguments[ze];
            return g.prototype[C].apply(A, P)
        }
    }

    function n() {
        this.blockSize = -1
    }

    function r() {
        this.blockSize = -1, this.blockSize = 64, this.g = Array(4), this.B = Array(this.blockSize), this.o = this.h = 0, this.s()
    }
    e(r, n), r.prototype.s = function() {
        this.g[0] = 1732584193, this.g[1] = 4023233417, this.g[2] = 2562383102, this.g[3] = 271733878, this.o = this.h = 0
    };

    function i(S, g, E) {
        E || (E = 0);
        var A = Array(16);
        if (typeof g == "string")
            for (var C = 0; 16 > C; ++C) A[C] = g.charCodeAt(E++) | g.charCodeAt(E++) << 8 | g.charCodeAt(E++) << 16 | g.charCodeAt(E++) << 24;
        else
            for (C = 0; 16 > C; ++C) A[C] = g[E++] | g[E++] << 8 | g[E++] << 16 | g[E++] << 24;
        g = S.g[0], E = S.g[1], C = S.g[2];
        var b = S.g[3],
            P = g + (b ^ E & (C ^ b)) + A[0] + 3614090360 & 4294967295;
        g = E + (P << 7 & 4294967295 | P >>> 25), P = b + (C ^ g & (E ^ C)) + A[1] + 3905402710 & 4294967295, b = g + (P << 12 & 4294967295 | P >>> 20), P = C + (E ^ b & (g ^ E)) + A[2] + 606105819 & 4294967295, C = b + (P << 17 & 4294967295 | P >>> 15), P = E + (g ^ C & (b ^ g)) + A[3] + 3250441966 & 4294967295, E = C + (P << 22 & 4294967295 | P >>> 10), P = g + (b ^ E & (C ^ b)) + A[4] + 4118548399 & 4294967295, g = E + (P << 7 & 4294967295 | P >>> 25), P = b + (C ^ g & (E ^ C)) + A[5] + 1200080426 & 4294967295, b = g + (P << 12 & 4294967295 | P >>> 20), P = C + (E ^ b & (g ^ E)) + A[6] + 2821735955 & 4294967295, C = b + (P << 17 & 4294967295 | P >>> 15), P = E + (g ^ C & (b ^ g)) + A[7] + 4249261313 & 4294967295, E = C + (P << 22 & 4294967295 | P >>> 10), P = g + (b ^ E & (C ^ b)) + A[8] + 1770035416 & 4294967295, g = E + (P << 7 & 4294967295 | P >>> 25), P = b + (C ^ g & (E ^ C)) + A[9] + 2336552879 & 4294967295, b = g + (P << 12 & 4294967295 | P >>> 20), P = C + (E ^ b & (g ^ E)) + A[10] + 4294925233 & 4294967295, C = b + (P << 17 & 4294967295 | P >>> 15), P = E + (g ^ C & (b ^ g)) + A[11] + 2304563134 & 4294967295, E = C + (P << 22 & 4294967295 | P >>> 10), P = g + (b ^ E & (C ^ b)) + A[12] + 1804603682 & 4294967295, g = E + (P << 7 & 4294967295 | P >>> 25), P = b + (C ^ g & (E ^ C)) + A[13] + 4254626195 & 4294967295, b = g + (P << 12 & 4294967295 | P >>> 20), P = C + (E ^ b & (g ^ E)) + A[14] + 2792965006 & 4294967295, C = b + (P << 17 & 4294967295 | P >>> 15), P = E + (g ^ C & (b ^ g)) + A[15] + 1236535329 & 4294967295, E = C + (P << 22 & 4294967295 | P >>> 10), P = g + (C ^ b & (E ^ C)) + A[1] + 4129170786 & 4294967295, g = E + (P << 5 & 4294967295 | P >>> 27), P = b + (E ^ C & (g ^ E)) + A[6] + 3225465664 & 4294967295, b = g + (P << 9 & 4294967295 | P >>> 23), P = C + (g ^ E & (b ^ g)) + A[11] + 643717713 & 4294967295, C = b + (P << 14 & 4294967295 | P >>> 18), P = E + (b ^ g & (C ^ b)) + A[0] + 3921069994 & 4294967295, E = C + (P << 20 & 4294967295 | P >>> 12), P = g + (C ^ b & (E ^ C)) + A[5] + 3593408605 & 4294967295, g = E + (P << 5 & 4294967295 | P >>> 27), P = b + (E ^ C & (g ^ E)) + A[10] + 38016083 & 4294967295, b = g + (P << 9 & 4294967295 | P >>> 23), P = C + (g ^ E & (b ^ g)) + A[15] + 3634488961 & 4294967295, C = b + (P << 14 & 4294967295 | P >>> 18), P = E + (b ^ g & (C ^ b)) + A[4] + 3889429448 & 4294967295, E = C + (P << 20 & 4294967295 | P >>> 12), P = g + (C ^ b & (E ^ C)) + A[9] + 568446438 & 4294967295, g = E + (P << 5 & 4294967295 | P >>> 27), P = b + (E ^ C & (g ^ E)) + A[14] + 3275163606 & 4294967295, b = g + (P << 9 & 4294967295 | P >>> 23), P = C + (g ^ E & (b ^ g)) + A[3] + 4107603335 & 4294967295, C = b + (P << 14 & 4294967295 | P >>> 18), P = E + (b ^ g & (C ^ b)) + A[8] + 1163531501 & 4294967295, E = C + (P << 20 & 4294967295 | P >>> 12), P = g + (C ^ b & (E ^ C)) + A[13] + 2850285829 & 4294967295, g = E + (P << 5 & 4294967295 | P >>> 27), P = b + (E ^ C & (g ^ E)) + A[2] + 4243563512 & 4294967295, b = g + (P << 9 & 4294967295 | P >>> 23), P = C + (g ^ E & (b ^ g)) + A[7] + 1735328473 & 4294967295, C = b + (P << 14 & 4294967295 | P >>> 18), P = E + (b ^ g & (C ^ b)) + A[12] + 2368359562 & 4294967295, E = C + (P << 20 & 4294967295 | P >>> 12), P = g + (E ^ C ^ b) + A[5] + 4294588738 & 4294967295, g = E + (P << 4 & 4294967295 | P >>> 28), P = b + (g ^ E ^ C) + A[8] + 2272392833 & 4294967295, b = g + (P << 11 & 4294967295 | P >>> 21), P = C + (b ^ g ^ E) + A[11] + 1839030562 & 4294967295, C = b + (P << 16 & 4294967295 | P >>> 16), P = E + (C ^ b ^ g) + A[14] + 4259657740 & 4294967295, E = C + (P << 23 & 4294967295 | P >>> 9), P = g + (E ^ C ^ b) + A[1] + 2763975236 & 4294967295, g = E + (P << 4 & 4294967295 | P >>> 28), P = b + (g ^ E ^ C) + A[4] + 1272893353 & 4294967295, b = g + (P << 11 & 4294967295 | P >>> 21), P = C + (b ^ g ^ E) + A[7] + 4139469664 & 4294967295, C = b + (P << 16 & 4294967295 | P >>> 16), P = E + (C ^ b ^ g) + A[10] + 3200236656 & 4294967295, E = C + (P << 23 & 4294967295 | P >>> 9), P = g + (E ^ C ^ b) + A[13] + 681279174 & 4294967295, g = E + (P << 4 & 4294967295 | P >>> 28), P = b + (g ^ E ^ C) + A[0] + 3936430074 & 4294967295, b = g + (P << 11 & 4294967295 | P >>> 21), P = C + (b ^ g ^ E) + A[3] + 3572445317 & 4294967295, C = b + (P << 16 & 4294967295 | P >>> 16), P = E + (C ^ b ^ g) + A[6] + 76029189 & 4294967295, E = C + (P << 23 & 4294967295 | P >>> 9), P = g + (E ^ C ^ b) + A[9] + 3654602809 & 4294967295, g = E + (P << 4 & 4294967295 | P >>> 28), P = b + (g ^ E ^ C) + A[12] + 3873151461 & 4294967295, b = g + (P << 11 & 4294967295 | P >>> 21), P = C + (b ^ g ^ E) + A[15] + 530742520 & 4294967295, C = b + (P << 16 & 4294967295 | P >>> 16), P = E + (C ^ b ^ g) + A[2] + 3299628645 & 4294967295, E = C + (P << 23 & 4294967295 | P >>> 9), P = g + (C ^ (E | ~b)) + A[0] + 4096336452 & 4294967295, g = E + (P << 6 & 4294967295 | P >>> 26), P = b + (E ^ (g | ~C)) + A[7] + 1126891415 & 4294967295, b = g + (P << 10 & 4294967295 | P >>> 22), P = C + (g ^ (b | ~E)) + A[14] + 2878612391 & 4294967295, C = b + (P << 15 & 4294967295 | P >>> 17), P = E + (b ^ (C | ~g)) + A[5] + 4237533241 & 4294967295, E = C + (P << 21 & 4294967295 | P >>> 11), P = g + (C ^ (E | ~b)) + A[12] + 1700485571 & 4294967295, g = E + (P << 6 & 4294967295 | P >>> 26), P = b + (E ^ (g | ~C)) + A[3] + 2399980690 & 4294967295, b = g + (P << 10 & 4294967295 | P >>> 22), P = C + (g ^ (b | ~E)) + A[10] + 4293915773 & 4294967295, C = b + (P << 15 & 4294967295 | P >>> 17), P = E + (b ^ (C | ~g)) + A[1] + 2240044497 & 4294967295, E = C + (P << 21 & 4294967295 | P >>> 11), P = g + (C ^ (E | ~b)) + A[8] + 1873313359 & 4294967295, g = E + (P << 6 & 4294967295 | P >>> 26), P = b + (E ^ (g | ~C)) + A[15] + 4264355552 & 4294967295, b = g + (P << 10 & 4294967295 | P >>> 22), P = C + (g ^ (b | ~E)) + A[6] + 2734768916 & 4294967295, C = b + (P << 15 & 4294967295 | P >>> 17), P = E + (b ^ (C | ~g)) + A[13] + 1309151649 & 4294967295, E = C + (P << 21 & 4294967295 | P >>> 11), P = g + (C ^ (E | ~b)) + A[4] + 4149444226 & 4294967295, g = E + (P << 6 & 4294967295 | P >>> 26), P = b + (E ^ (g | ~C)) + A[11] + 3174756917 & 4294967295, b = g + (P << 10 & 4294967295 | P >>> 22), P = C + (g ^ (b | ~E)) + A[2] + 718787259 & 4294967295, C = b + (P << 15 & 4294967295 | P >>> 17), P = E + (b ^ (C | ~g)) + A[9] + 3951481745 & 4294967295, S.g[0] = S.g[0] + g & 4294967295, S.g[1] = S.g[1] + (C + (P << 21 & 4294967295 | P >>> 11)) & 4294967295, S.g[2] = S.g[2] + C & 4294967295, S.g[3] = S.g[3] + b & 4294967295
    }
    r.prototype.u = function(S, g) {
        g === void 0 && (g = S.length);
        for (var E = g - this.blockSize, A = this.B, C = this.h, b = 0; b < g;) {
            if (C == 0)
                for (; b <= E;) i(this, S, b), b += this.blockSize;
            if (typeof S == "string") {
                for (; b < g;)
                    if (A[C++] = S.charCodeAt(b++), C == this.blockSize) {
                        i(this, A), C = 0;
                        break
                    }
            } else
                for (; b < g;)
                    if (A[C++] = S[b++], C == this.blockSize) {
                        i(this, A), C = 0;
                        break
                    }
        }
        this.h = C, this.o += g
    }, r.prototype.v = function() {
        var S = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
        S[0] = 128;
        for (var g = 1; g < S.length - 8; ++g) S[g] = 0;
        var E = 8 * this.o;
        for (g = S.length - 8; g < S.length; ++g) S[g] = E & 255, E /= 256;
        for (this.u(S), S = Array(16), g = E = 0; 4 > g; ++g)
            for (var A = 0; 32 > A; A += 8) S[E++] = this.g[g] >>> A & 255;
        return S
    };

    function s(S, g) {
        var E = a;
        return Object.prototype.hasOwnProperty.call(E, S) ? E[S] : E[S] = g(S)
    }

    function o(S, g) {
        this.h = g;
        for (var E = [], A = !0, C = S.length - 1; 0 <= C; C--) {
            var b = S[C] | 0;
            A && b == g || (E[C] = b, A = !1)
        }
        this.g = E
    }
    var a = {};

    function u(S) {
        return -128 <= S && 128 > S ? s(S, function(g) {
            return new o([g | 0], 0 > g ? -1 : 0)
        }) : new o([S | 0], 0 > S ? -1 : 0)
    }

    function c(S) {
        if (isNaN(S) || !isFinite(S)) return f;
        if (0 > S) return k(c(-S));
        for (var g = [], E = 1, A = 0; S >= E; A++) g[A] = S / E | 0, E *= 4294967296;
        return new o(g, 0)
    }

    function h(S, g) {
        if (S.length == 0) throw Error("number format error: empty string");
        if (g = g || 10, 2 > g || 36 < g) throw Error("radix out of range: " + g);
        if (S.charAt(0) == "-") return k(h(S.substring(1), g));
        if (0 <= S.indexOf("-")) throw Error('number format error: interior "-" character');
        for (var E = c(Math.pow(g, 8)), A = f, C = 0; C < S.length; C += 8) {
            var b = Math.min(8, S.length - C),
                P = parseInt(S.substring(C, C + b), g);
            8 > b ? (b = c(Math.pow(g, b)), A = A.j(b).add(c(P))) : (A = A.j(E), A = A.add(c(P)))
        }
        return A
    }
    var f = u(0),
        m = u(1),
        _ = u(16777216);
    t = o.prototype, t.m = function() {
        if (R(this)) return -k(this).m();
        for (var S = 0, g = 1, E = 0; E < this.g.length; E++) {
            var A = this.i(E);
            S += (0 <= A ? A : 4294967296 + A) * g, g *= 4294967296
        }
        return S
    }, t.toString = function(S) {
        if (S = S || 10, 2 > S || 36 < S) throw Error("radix out of range: " + S);
        if (I(this)) return "0";
        if (R(this)) return "-" + k(this).toString(S);
        for (var g = c(Math.pow(S, 6)), E = this, A = "";;) {
            var C = x(E, g).g;
            E = w(E, C.j(g));
            var b = ((0 < E.g.length ? E.g[0] : E.h) >>> 0).toString(S);
            if (E = C, I(E)) return b + A;
            for (; 6 > b.length;) b = "0" + b;
            A = b + A
        }
    }, t.i = function(S) {
        return 0 > S ? 0 : S < this.g.length ? this.g[S] : this.h
    };

    function I(S) {
        if (S.h != 0) return !1;
        for (var g = 0; g < S.g.length; g++)
            if (S.g[g] != 0) return !1;
        return !0
    }

    function R(S) {
        return S.h == -1
    }
    t.l = function(S) {
        return S = w(this, S), R(S) ? -1 : I(S) ? 0 : 1
    };

    function k(S) {
        for (var g = S.g.length, E = [], A = 0; A < g; A++) E[A] = ~S.g[A];
        return new o(E, ~S.h).add(m)
    }
    t.abs = function() {
        return R(this) ? k(this) : this
    }, t.add = function(S) {
        for (var g = Math.max(this.g.length, S.g.length), E = [], A = 0, C = 0; C <= g; C++) {
            var b = A + (this.i(C) & 65535) + (S.i(C) & 65535),
                P = (b >>> 16) + (this.i(C) >>> 16) + (S.i(C) >>> 16);
            A = P >>> 16, b &= 65535, P &= 65535, E[C] = P << 16 | b
        }
        return new o(E, E[E.length - 1] & -2147483648 ? -1 : 0)
    };

    function w(S, g) {
        return S.add(k(g))
    }
    t.j = function(S) {
        if (I(this) || I(S)) return f;
        if (R(this)) return R(S) ? k(this).j(k(S)) : k(k(this).j(S));
        if (R(S)) return k(this.j(k(S)));
        if (0 > this.l(_) && 0 > S.l(_)) return c(this.m() * S.m());
        for (var g = this.g.length + S.g.length, E = [], A = 0; A < 2 * g; A++) E[A] = 0;
        for (A = 0; A < this.g.length; A++)
            for (var C = 0; C < S.g.length; C++) {
                var b = this.i(A) >>> 16,
                    P = this.i(A) & 65535,
                    ze = S.i(C) >>> 16,
                    dn = S.i(C) & 65535;
                E[2 * A + 2 * C] += P * dn, v(E, 2 * A + 2 * C), E[2 * A + 2 * C + 1] += b * dn, v(E, 2 * A + 2 * C + 1), E[2 * A + 2 * C + 1] += P * ze, v(E, 2 * A + 2 * C + 1), E[2 * A + 2 * C + 2] += b * ze, v(E, 2 * A + 2 * C + 2)
            }
        for (A = 0; A < g; A++) E[A] = E[2 * A + 1] << 16 | E[2 * A];
        for (A = g; A < 2 * g; A++) E[A] = 0;
        return new o(E, 0)
    };

    function v(S, g) {
        for (;
            (S[g] & 65535) != S[g];) S[g + 1] += S[g] >>> 16, S[g] &= 65535, g++
    }

    function T(S, g) {
        this.g = S, this.h = g
    }

    function x(S, g) {
        if (I(g)) throw Error("division by zero");
        if (I(S)) return new T(f, f);
        if (R(S)) return g = x(k(S), g), new T(k(g.g), k(g.h));
        if (R(g)) return g = x(S, k(g)), new T(k(g.g), g.h);
        if (30 < S.g.length) {
            if (R(S) || R(g)) throw Error("slowDivide_ only works with positive integers.");
            for (var E = m, A = g; 0 >= A.l(S);) E = O(E), A = O(A);
            var C = U(E, 1),
                b = U(A, 1);
            for (A = U(A, 2), E = U(E, 2); !I(A);) {
                var P = b.add(A);
                0 >= P.l(S) && (C = C.add(E), b = P), A = U(A, 1), E = U(E, 1)
            }
            return g = w(S, C.j(g)), new T(C, g)
        }
        for (C = f; 0 <= S.l(g);) {
            for (E = Math.max(1, Math.floor(S.m() / g.m())), A = Math.ceil(Math.log(E) / Math.LN2), A = 48 >= A ? 1 : Math.pow(2, A - 48), b = c(E), P = b.j(g); R(P) || 0 < P.l(S);) E -= A, b = c(E), P = b.j(g);
            I(b) && (b = m), C = C.add(b), S = w(S, P)
        }
        return new T(C, S)
    }
    t.A = function(S) {
        return x(this, S).h
    }, t.and = function(S) {
        for (var g = Math.max(this.g.length, S.g.length), E = [], A = 0; A < g; A++) E[A] = this.i(A) & S.i(A);
        return new o(E, this.h & S.h)
    }, t.or = function(S) {
        for (var g = Math.max(this.g.length, S.g.length), E = [], A = 0; A < g; A++) E[A] = this.i(A) | S.i(A);
        return new o(E, this.h | S.h)
    }, t.xor = function(S) {
        for (var g = Math.max(this.g.length, S.g.length), E = [], A = 0; A < g; A++) E[A] = this.i(A) ^ S.i(A);
        return new o(E, this.h ^ S.h)
    };

    function O(S) {
        for (var g = S.g.length + 1, E = [], A = 0; A < g; A++) E[A] = S.i(A) << 1 | S.i(A - 1) >>> 31;
        return new o(E, S.h)
    }

    function U(S, g) {
        var E = g >> 5;
        g %= 32;
        for (var A = S.g.length - E, C = [], b = 0; b < A; b++) C[b] = 0 < g ? S.i(b + E) >>> g | S.i(b + E + 1) << 32 - g : S.i(b + E);
        return new o(C, S.h)
    }
    r.prototype.digest = r.prototype.v, r.prototype.reset = r.prototype.s, r.prototype.update = r.prototype.u, oS = r, o.prototype.add = o.prototype.add, o.prototype.multiply = o.prototype.j, o.prototype.modulo = o.prototype.A, o.prototype.compare = o.prototype.l, o.prototype.toNumber = o.prototype.m, o.prototype.toString = o.prototype.toString, o.prototype.getBits = o.prototype.i, o.fromNumber = c, o.fromString = h, Ei = o
}).apply(typeof k_ < "u" ? k_ : typeof self < "u" ? self : typeof window < "u" ? window : {});
var Fl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var aS, Do, lS, au, zf, uS, cS, hS;
(function() {
    var t, e = typeof Object.defineProperties == "function" ? Object.defineProperty : function(l, d, p) {
        return l == Array.prototype || l == Object.prototype || (l[d] = p.value), l
    };

    function n(l) {
        l = [typeof globalThis == "object" && globalThis, l, typeof window == "object" && window, typeof self == "object" && self, typeof Fl == "object" && Fl];
        for (var d = 0; d < l.length; ++d) {
            var p = l[d];
            if (p && p.Math == Math) return p
        }
        throw Error("Cannot find global object")
    }
    var r = n(this);

    function i(l, d) {
        if (d) e: {
            var p = r;l = l.split(".");
            for (var y = 0; y < l.length - 1; y++) {
                var N = l[y];
                if (!(N in p)) break e;
                p = p[N]
            }
            l = l[l.length - 1],
            y = p[l],
            d = d(y),
            d != y && d != null && e(p, l, {
                configurable: !0,
                writable: !0,
                value: d
            })
        }
    }

    function s(l, d) {
        l instanceof String && (l += "");
        var p = 0,
            y = !1,
            N = {
                next: function() {
                    if (!y && p < l.length) {
                        var V = p++;
                        return {
                            value: d(V, l[V]),
                            done: !1
                        }
                    }
                    return y = !0, {
                        done: !0,
                        value: void 0
                    }
                }
            };
        return N[Symbol.iterator] = function() {
            return N
        }, N
    }
    i("Array.prototype.values", function(l) {
        return l || function() {
            return s(this, function(d, p) {
                return p
            })
        }
    });
    /** @license

     Copyright The Closure Library Authors.
     SPDX-License-Identifier: Apache-2.0
    */
    var o = o || {},
        a = this || self;

    function u(l) {
        var d = typeof l;
        return d = d != "object" ? d : l ? Array.isArray(l) ? "array" : d : "null", d == "array" || d == "object" && typeof l.length == "number"
    }

    function c(l) {
        var d = typeof l;
        return d == "object" && l != null || d == "function"
    }

    function h(l, d, p) {
        return l.call.apply(l.bind, arguments)
    }

    function f(l, d, p) {
        if (!l) throw Error();
        if (2 < arguments.length) {
            var y = Array.prototype.slice.call(arguments, 2);
            return function() {
                var N = Array.prototype.slice.call(arguments);
                return Array.prototype.unshift.apply(N, y), l.apply(d, N)
            }
        }
        return function() {
            return l.apply(d, arguments)
        }
    }

    function m(l, d, p) {
        return m = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? h : f, m.apply(null, arguments)
    }

    function _(l, d) {
        var p = Array.prototype.slice.call(arguments, 1);
        return function() {
            var y = p.slice();
            return y.push.apply(y, arguments), l.apply(this, y)
        }
    }

    function I(l, d) {
        function p() {}
        p.prototype = d.prototype, l.aa = d.prototype, l.prototype = new p, l.prototype.constructor = l, l.Qb = function(y, N, V) {
            for (var $ = Array(arguments.length - 2), de = 2; de < arguments.length; de++) $[de - 2] = arguments[de];
            return d.prototype[N].apply(y, $)
        }
    }

    function R(l) {
        const d = l.length;
        if (0 < d) {
            const p = Array(d);
            for (let y = 0; y < d; y++) p[y] = l[y];
            return p
        }
        return []
    }

    function k(l, d) {
        for (let p = 1; p < arguments.length; p++) {
            const y = arguments[p];
            if (u(y)) {
                const N = l.length || 0,
                    V = y.length || 0;
                l.length = N + V;
                for (let $ = 0; $ < V; $++) l[N + $] = y[$]
            } else l.push(y)
        }
    }
    class w {
        constructor(d, p) {
            this.i = d, this.j = p, this.h = 0, this.g = null
        }
        get() {
            let d;
            return 0 < this.h ? (this.h--, d = this.g, this.g = d.next, d.next = null) : d = this.i(), d
        }
    }

    function v(l) {
        return /^[\s\xa0]*$/.test(l)
    }

    function T() {
        var l = a.navigator;
        return l && (l = l.userAgent) ? l : ""
    }

    function x(l) {
        return x[" "](l), l
    }
    x[" "] = function() {};
    var O = T().indexOf("Gecko") != -1 && !(T().toLowerCase().indexOf("webkit") != -1 && T().indexOf("Edge") == -1) && !(T().indexOf("Trident") != -1 || T().indexOf("MSIE") != -1) && T().indexOf("Edge") == -1;

    function U(l, d, p) {
        for (const y in l) d.call(p, l[y], y, l)
    }

    function S(l, d) {
        for (const p in l) d.call(void 0, l[p], p, l)
    }

    function g(l) {
        const d = {};
        for (const p in l) d[p] = l[p];
        return d
    }
    const E = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");

    function A(l, d) {
        let p, y;
        for (let N = 1; N < arguments.length; N++) {
            y = arguments[N];
            for (p in y) l[p] = y[p];
            for (let V = 0; V < E.length; V++) p = E[V], Object.prototype.hasOwnProperty.call(y, p) && (l[p] = y[p])
        }
    }

    function C(l) {
        var d = 1;
        l = l.split(":");
        const p = [];
        for (; 0 < d && l.length;) p.push(l.shift()), d--;
        return l.length && p.push(l.join(":")), p
    }

    function b(l) {
        a.setTimeout(() => {
            throw l
        }, 0)
    }

    function P() {
        var l = K;
        let d = null;
        return l.g && (d = l.g, l.g = l.g.next, l.g || (l.h = null), d.next = null), d
    }
    class ze {
        constructor() {
            this.h = this.g = null
        }
        add(d, p) {
            const y = dn.get();
            y.set(d, p), this.h ? this.h.next = y : this.g = y, this.h = y
        }
    }
    var dn = new w(() => new sr, l => l.reset());
    class sr {
        constructor() {
            this.next = this.g = this.h = null
        }
        set(d, p) {
            this.h = d, this.g = p, this.next = null
        }
        reset() {
            this.next = this.g = this.h = null
        }
    }
    let le, B = !1,
        K = new ze,
        Q = () => {
            const l = a.Promise.resolve(void 0);
            le = () => {
                l.then(pe)
            }
        };
    var pe = () => {
        for (var l; l = P();) {
            try {
                l.h.call(l.g)
            } catch (p) {
                b(p)
            }
            var d = dn;
            d.j(l), 100 > d.h && (d.h++, l.next = d.g, d.g = l)
        }
        B = !1
    };

    function ue() {
        this.s = this.s, this.C = this.C
    }
    ue.prototype.s = !1, ue.prototype.ma = function() {
        this.s || (this.s = !0, this.N())
    }, ue.prototype.N = function() {
        if (this.C)
            for (; this.C.length;) this.C.shift()()
    };

    function _e(l, d) {
        this.type = l, this.g = this.target = d, this.defaultPrevented = !1
    }
    _e.prototype.h = function() {
        this.defaultPrevented = !0
    };
    var Tt = function() {
        if (!a.addEventListener || !Object.defineProperty) return !1;
        var l = !1,
            d = Object.defineProperty({}, "passive", {
                get: function() {
                    l = !0
                }
            });
        try {
            const p = () => {};
            a.addEventListener("test", p, d), a.removeEventListener("test", p, d)
        } catch {}
        return l
    }();

    function Je(l, d) {
        if (_e.call(this, l ? l.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, l) {
            var p = this.type = l.type,
                y = l.changedTouches && l.changedTouches.length ? l.changedTouches[0] : null;
            if (this.target = l.target || l.srcElement, this.g = d, d = l.relatedTarget) {
                if (O) {
                    e: {
                        try {
                            x(d.nodeName);
                            var N = !0;
                            break e
                        } catch {}
                        N = !1
                    }
                    N || (d = null)
                }
            } else p == "mouseover" ? d = l.fromElement : p == "mouseout" && (d = l.toElement);
            this.relatedTarget = d, y ? (this.clientX = y.clientX !== void 0 ? y.clientX : y.pageX, this.clientY = y.clientY !== void 0 ? y.clientY : y.pageY, this.screenX = y.screenX || 0, this.screenY = y.screenY || 0) : (this.clientX = l.clientX !== void 0 ? l.clientX : l.pageX, this.clientY = l.clientY !== void 0 ? l.clientY : l.pageY, this.screenX = l.screenX || 0, this.screenY = l.screenY || 0), this.button = l.button, this.key = l.key || "", this.ctrlKey = l.ctrlKey, this.altKey = l.altKey, this.shiftKey = l.shiftKey, this.metaKey = l.metaKey, this.pointerId = l.pointerId || 0, this.pointerType = typeof l.pointerType == "string" ? l.pointerType : Oe[l.pointerType] || "", this.state = l.state, this.i = l, l.defaultPrevented && Je.aa.h.call(this)
        }
    }
    I(Je, _e);
    var Oe = {
        2: "touch",
        3: "pen",
        4: "mouse"
    };
    Je.prototype.h = function() {
        Je.aa.h.call(this);
        var l = this.i;
        l.preventDefault ? l.preventDefault() : l.returnValue = !1
    };
    var Wt = "closure_listenable_" + (1e6 * Math.random() | 0),
        ni = 0;

    function il(l, d, p, y, N) {
        this.listener = l, this.proxy = null, this.src = d, this.type = p, this.capture = !!y, this.ha = N, this.key = ++ni, this.da = this.fa = !1
    }

    function ji(l) {
        l.da = !0, l.listener = null, l.proxy = null, l.src = null, l.ha = null
    }

    function Bi(l) {
        this.src = l, this.g = {}, this.h = 0
    }
    Bi.prototype.add = function(l, d, p, y, N) {
        var V = l.toString();
        l = this.g[V], l || (l = this.g[V] = [], this.h++);
        var $ = ro(l, d, y, N);
        return -1 < $ ? (d = l[$], p || (d.fa = !1)) : (d = new il(d, this.src, V, !!y, N), d.fa = p, l.push(d)), d
    };

    function $i(l, d) {
        var p = d.type;
        if (p in l.g) {
            var y = l.g[p],
                N = Array.prototype.indexOf.call(y, d, void 0),
                V;
            (V = 0 <= N) && Array.prototype.splice.call(y, N, 1), V && (ji(d), l.g[p].length == 0 && (delete l.g[p], l.h--))
        }
    }

    function ro(l, d, p, y) {
        for (var N = 0; N < l.length; ++N) {
            var V = l[N];
            if (!V.da && V.listener == d && V.capture == !!p && V.ha == y) return N
        }
        return -1
    }
    var ri = "closure_lm_" + (1e6 * Math.random() | 0),
        io = {};

    function so(l, d, p, y, N) {
        if (Array.isArray(d)) {
            for (var V = 0; V < d.length; V++) so(l, d[V], p, y, N);
            return null
        }
        return p = iy(p), l && l[Wt] ? l.K(d, p, c(y) ? !!y.capture : !!y, N) : vh(l, d, p, !1, y, N)
    }

    function vh(l, d, p, y, N, V) {
        if (!d) throw Error("Invalid event type");
        var $ = c(N) ? !!N.capture : !!N,
            de = wh(l);
        if (de || (l[ri] = de = new Bi(l)), p = de.add(d, p, y, $, V), p.proxy) return p;
        if (y = _h(), p.proxy = y, y.src = l, y.listener = p, l.addEventListener) Tt || (N = $), N === void 0 && (N = !1), l.addEventListener(d.toString(), y, N);
        else if (l.attachEvent) l.attachEvent(ry(d.toString()), y);
        else if (l.addListener && l.removeListener) l.addListener(y);
        else throw Error("addEventListener and attachEvent are unavailable.");
        return p
    }

    function _h() {
        function l(p) {
            return d.call(l.src, l.listener, p)
        }
        const d = nR;
        return l
    }

    function or(l, d, p, y, N) {
        if (Array.isArray(d))
            for (var V = 0; V < d.length; V++) or(l, d[V], p, y, N);
        else y = c(y) ? !!y.capture : !!y, p = iy(p), l && l[Wt] ? (l = l.i, d = String(d).toString(), d in l.g && (V = l.g[d], p = ro(V, p, y, N), -1 < p && (ji(V[p]), Array.prototype.splice.call(V, p, 1), V.length == 0 && (delete l.g[d], l.h--)))) : l && (l = wh(l)) && (d = l.g[d.toString()], l = -1, d && (l = ro(d, p, y, N)), (p = -1 < l ? d[l] : null) && ar(p))
    }

    function ar(l) {
        if (typeof l != "number" && l && !l.da) {
            var d = l.src;
            if (d && d[Wt]) $i(d.i, l);
            else {
                var p = l.type,
                    y = l.proxy;
                d.removeEventListener ? d.removeEventListener(p, y, l.capture) : d.detachEvent ? d.detachEvent(ry(p), y) : d.addListener && d.removeListener && d.removeListener(y), (p = wh(d)) ? ($i(p, l), p.h == 0 && (p.src = null, d[ri] = null)) : ji(l)
            }
        }
    }

    function ry(l) {
        return l in io ? io[l] : io[l] = "on" + l
    }

    function nR(l, d) {
        if (l.da) l = !0;
        else {
            d = new Je(d, this);
            var p = l.listener,
                y = l.ha || l.src;
            l.fa && ar(l), l = p.call(y, d)
        }
        return l
    }

    function wh(l) {
        return l = l[ri], l instanceof Bi ? l : null
    }
    var Th = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);

    function iy(l) {
        return typeof l == "function" ? l : (l[Th] || (l[Th] = function(d) {
            return l.handleEvent(d)
        }), l[Th])
    }

    function Ze() {
        ue.call(this), this.i = new Bi(this), this.M = this, this.F = null
    }
    I(Ze, ue), Ze.prototype[Wt] = !0, Ze.prototype.removeEventListener = function(l, d, p, y) {
        or(this, l, d, p, y)
    };

    function mt(l, d) {
        var p, y = l.F;
        if (y)
            for (p = []; y; y = y.F) p.push(y);
        if (l = l.M, y = d.type || d, typeof d == "string") d = new _e(d, l);
        else if (d instanceof _e) d.target = d.target || l;
        else {
            var N = d;
            d = new _e(y, l), A(d, N)
        }
        if (N = !0, p)
            for (var V = p.length - 1; 0 <= V; V--) {
                var $ = d.g = p[V];
                N = sl($, y, !0, d) && N
            }
        if ($ = d.g = l, N = sl($, y, !0, d) && N, N = sl($, y, !1, d) && N, p)
            for (V = 0; V < p.length; V++) $ = d.g = p[V], N = sl($, y, !1, d) && N
    }
    Ze.prototype.N = function() {
        if (Ze.aa.N.call(this), this.i) {
            var l = this.i,
                d;
            for (d in l.g) {
                for (var p = l.g[d], y = 0; y < p.length; y++) ji(p[y]);
                delete l.g[d], l.h--
            }
        }
        this.F = null
    }, Ze.prototype.K = function(l, d, p, y) {
        return this.i.add(String(l), d, !1, p, y)
    }, Ze.prototype.L = function(l, d, p, y) {
        return this.i.add(String(l), d, !0, p, y)
    };

    function sl(l, d, p, y) {
        if (d = l.i.g[String(d)], !d) return !0;
        d = d.concat();
        for (var N = !0, V = 0; V < d.length; ++V) {
            var $ = d[V];
            if ($ && !$.da && $.capture == p) {
                var de = $.listener,
                    We = $.ha || $.src;
                $.fa && $i(l.i, $), N = de.call(We, y) !== !1 && N
            }
        }
        return N && !y.defaultPrevented
    }

    function sy(l, d, p) {
        if (typeof l == "function") p && (l = m(l, p));
        else if (l && typeof l.handleEvent == "function") l = m(l.handleEvent, l);
        else throw Error("Invalid listener argument");
        return 2147483647 < Number(d) ? -1 : a.setTimeout(l, d || 0)
    }

    function oy(l) {
        l.g = sy(() => {
            l.g = null, l.i && (l.i = !1, oy(l))
        }, l.l);
        const d = l.h;
        l.h = null, l.m.apply(null, d)
    }
    class rR extends ue {
        constructor(d, p) {
            super(), this.m = d, this.l = p, this.h = null, this.i = !1, this.g = null
        }
        j(d) {
            this.h = arguments, this.g ? this.i = !0 : oy(this)
        }
        N() {
            super.N(), this.g && (a.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null)
        }
    }

    function oo(l) {
        ue.call(this), this.h = l, this.g = {}
    }
    I(oo, ue);
    var ay = [];

    function ly(l) {
        U(l.g, function(d, p) {
            this.g.hasOwnProperty(p) && ar(d)
        }, l), l.g = {}
    }
    oo.prototype.N = function() {
        oo.aa.N.call(this), ly(this)
    }, oo.prototype.handleEvent = function() {
        throw Error("EventHandler.handleEvent not implemented")
    };
    var Eh = a.JSON.stringify,
        iR = a.JSON.parse,
        sR = class {
            stringify(l) {
                return a.JSON.stringify(l, void 0)
            }
            parse(l) {
                return a.JSON.parse(l, void 0)
            }
        };

    function Ih() {}
    Ih.prototype.h = null;

    function uy(l) {
        return l.h || (l.h = l.i())
    }

    function cy() {}
    var ao = {
        OPEN: "a",
        kb: "b",
        Ja: "c",
        wb: "d"
    };

    function Sh() {
        _e.call(this, "d")
    }
    I(Sh, _e);

    function Ah() {
        _e.call(this, "c")
    }
    I(Ah, _e);
    var ii = {},
        hy = null;

    function ol() {
        return hy = hy || new Ze
    }
    ii.La = "serverreachability";

    function dy(l) {
        _e.call(this, ii.La, l)
    }
    I(dy, _e);

    function lo(l) {
        const d = ol();
        mt(d, new dy(d))
    }
    ii.STAT_EVENT = "statevent";

    function fy(l, d) {
        _e.call(this, ii.STAT_EVENT, l), this.stat = d
    }
    I(fy, _e);

    function gt(l) {
        const d = ol();
        mt(d, new fy(d, l))
    }
    ii.Ma = "timingevent";

    function py(l, d) {
        _e.call(this, ii.Ma, l), this.size = d
    }
    I(py, _e);

    function uo(l, d) {
        if (typeof l != "function") throw Error("Fn must not be null and must be a function");
        return a.setTimeout(function() {
            l()
        }, d)
    }

    function co() {
        this.g = !0
    }
    co.prototype.xa = function() {
        this.g = !1
    };

    function oR(l, d, p, y, N, V) {
        l.info(function() {
            if (l.g)
                if (V)
                    for (var $ = "", de = V.split("&"), We = 0; We < de.length; We++) {
                        var oe = de[We].split("=");
                        if (1 < oe.length) {
                            var et = oe[0];
                            oe = oe[1];
                            var tt = et.split("_");
                            $ = 2 <= tt.length && tt[1] == "type" ? $ + (et + "=" + oe + "&") : $ + (et + "=redacted&")
                        }
                    } else $ = null;
                else $ = V;
            return "XMLHTTP REQ (" + y + ") [attempt " + N + "]: " + d + `
` + p + `
` + $
        })
    }

    function aR(l, d, p, y, N, V, $) {
        l.info(function() {
            return "XMLHTTP RESP (" + y + ") [ attempt " + N + "]: " + d + `
` + p + `
` + V + " " + $
        })
    }

    function zi(l, d, p, y) {
        l.info(function() {
            return "XMLHTTP TEXT (" + d + "): " + uR(l, p) + (y ? " " + y : "")
        })
    }

    function lR(l, d) {
        l.info(function() {
            return "TIMEOUT: " + d
        })
    }
    co.prototype.info = function() {};

    function uR(l, d) {
        if (!l.g) return d;
        if (!d) return null;
        try {
            var p = JSON.parse(d);
            if (p) {
                for (l = 0; l < p.length; l++)
                    if (Array.isArray(p[l])) {
                        var y = p[l];
                        if (!(2 > y.length)) {
                            var N = y[1];
                            if (Array.isArray(N) && !(1 > N.length)) {
                                var V = N[0];
                                if (V != "noop" && V != "stop" && V != "close")
                                    for (var $ = 1; $ < N.length; $++) N[$] = ""
                            }
                        }
                    }
            }
            return Eh(p)
        } catch {
            return d
        }
    }
    var al = {
            NO_ERROR: 0,
            gb: 1,
            tb: 2,
            sb: 3,
            nb: 4,
            rb: 5,
            ub: 6,
            Ia: 7,
            TIMEOUT: 8,
            xb: 9
        },
        my = {
            lb: "complete",
            Hb: "success",
            Ja: "error",
            Ia: "abort",
            zb: "ready",
            Ab: "readystatechange",
            TIMEOUT: "timeout",
            vb: "incrementaldata",
            yb: "progress",
            ob: "downloadprogress",
            Pb: "uploadprogress"
        },
        Ph;

    function ll() {}
    I(ll, Ih), ll.prototype.g = function() {
        return new XMLHttpRequest
    }, ll.prototype.i = function() {
        return {}
    }, Ph = new ll;

    function lr(l, d, p, y) {
        this.j = l, this.i = d, this.l = p, this.R = y || 1, this.U = new oo(this), this.I = 45e3, this.H = null, this.o = !1, this.m = this.A = this.v = this.L = this.F = this.S = this.B = null, this.D = [], this.g = null, this.C = 0, this.s = this.u = null, this.X = -1, this.J = !1, this.O = 0, this.M = null, this.W = this.K = this.T = this.P = !1, this.h = new gy
    }

    function gy() {
        this.i = null, this.g = "", this.h = !1
    }
    var yy = {},
        Rh = {};

    function Ch(l, d, p) {
        l.L = 1, l.v = dl(kn(d)), l.m = p, l.P = !0, vy(l, null)
    }

    function vy(l, d) {
        l.F = Date.now(), ul(l), l.A = kn(l.v);
        var p = l.A,
            y = l.R;
        Array.isArray(y) || (y = [String(y)]), Ny(p.i, "t", y), l.C = 0, p = l.j.J, l.h = new gy, l.g = Yy(l.j, p ? d : null, !l.m), 0 < l.O && (l.M = new rR(m(l.Y, l, l.g), l.O)), d = l.U, p = l.g, y = l.ca;
        var N = "readystatechange";
        Array.isArray(N) || (N && (ay[0] = N.toString()), N = ay);
        for (var V = 0; V < N.length; V++) {
            var $ = so(p, N[V], y || d.handleEvent, !1, d.h || d);
            if (!$) break;
            d.g[$.key] = $
        }
        d = l.H ? g(l.H) : {}, l.m ? (l.u || (l.u = "POST"), d["Content-Type"] = "application/x-www-form-urlencoded", l.g.ea(l.A, l.u, l.m, d)) : (l.u = "GET", l.g.ea(l.A, l.u, null, d)), lo(), oR(l.i, l.u, l.A, l.l, l.R, l.m)
    }
    lr.prototype.ca = function(l) {
        l = l.target;
        const d = this.M;
        d && xn(l) == 3 ? d.j() : this.Y(l)
    }, lr.prototype.Y = function(l) {
        try {
            if (l == this.g) e: {
                const tt = xn(this.g);
                var d = this.g.Ba();
                const Hi = this.g.Z();
                if (!(3 > tt) && (tt != 3 || this.g && (this.h.h || this.g.oa() || Uy(this.g)))) {
                    this.J || tt != 4 || d == 7 || (d == 8 || 0 >= Hi ? lo(3) : lo(2)), kh(this);
                    var p = this.g.Z();
                    this.X = p;
                    t: if (_y(this)) {
                        var y = Uy(this.g);
                        l = "";
                        var N = y.length,
                            V = xn(this.g) == 4;
                        if (!this.h.i) {
                            if (typeof TextDecoder > "u") {
                                si(this), ho(this);
                                var $ = "";
                                break t
                            }
                            this.h.i = new a.TextDecoder
                        }
                        for (d = 0; d < N; d++) this.h.h = !0, l += this.h.i.decode(y[d], {
                            stream: !(V && d == N - 1)
                        });
                        y.length = 0, this.h.g += l, this.C = 0, $ = this.h.g
                    } else $ = this.g.oa();
                    if (this.o = p == 200, aR(this.i, this.u, this.A, this.l, this.R, tt, p), this.o) {
                        if (this.T && !this.K) {
                            t: {
                                if (this.g) {
                                    var de, We = this.g;
                                    if ((de = We.g ? We.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !v(de)) {
                                        var oe = de;
                                        break t
                                    }
                                }
                                oe = null
                            }
                            if (p = oe) zi(this.i, this.l, p, "Initial handshake response via X-HTTP-Initial-Response"),
                            this.K = !0,
                            xh(this, p);
                            else {
                                this.o = !1, this.s = 3, gt(12), si(this), ho(this);
                                break e
                            }
                        }
                        if (this.P) {
                            p = !0;
                            let tn;
                            for (; !this.J && this.C < $.length;)
                                if (tn = cR(this, $), tn == Rh) {
                                    tt == 4 && (this.s = 4, gt(14), p = !1), zi(this.i, this.l, null, "[Incomplete Response]");
                                    break
                                } else if (tn == yy) {
                                this.s = 4, gt(15), zi(this.i, this.l, $, "[Invalid Chunk]"), p = !1;
                                break
                            } else zi(this.i, this.l, tn, null), xh(this, tn);
                            if (_y(this) && this.C != 0 && (this.h.g = this.h.g.slice(this.C), this.C = 0), tt != 4 || $.length != 0 || this.h.h || (this.s = 1, gt(16), p = !1), this.o = this.o && p, !p) zi(this.i, this.l, $, "[Invalid Chunked Response]"), si(this), ho(this);
                            else if (0 < $.length && !this.W) {
                                this.W = !0;
                                var et = this.j;
                                et.g == this && et.ba && !et.M && (et.j.info("Great, no buffering proxy detected. Bytes received: " + $.length), Lh(et), et.M = !0, gt(11))
                            }
                        } else zi(this.i, this.l, $, null), xh(this, $);
                        tt == 4 && si(this), this.o && !this.J && (tt == 4 ? Hy(this.j, this) : (this.o = !1, ul(this)))
                    } else RR(this.g), p == 400 && 0 < $.indexOf("Unknown SID") ? (this.s = 3, gt(12)) : (this.s = 0, gt(13)), si(this), ho(this)
                }
            }
        } catch {} finally {}
    };

    function _y(l) {
        return l.g ? l.u == "GET" && l.L != 2 && l.j.Ca : !1
    }

    function cR(l, d) {
        var p = l.C,
            y = d.indexOf(`
`, p);
        return y == -1 ? Rh : (p = Number(d.substring(p, y)), isNaN(p) ? yy : (y += 1, y + p > d.length ? Rh : (d = d.slice(y, y + p), l.C = y + p, d)))
    }
    lr.prototype.cancel = function() {
        this.J = !0, si(this)
    };

    function ul(l) {
        l.S = Date.now() + l.I, wy(l, l.I)
    }

    function wy(l, d) {
        if (l.B != null) throw Error("WatchDog timer not null");
        l.B = uo(m(l.ba, l), d)
    }

    function kh(l) {
        l.B && (a.clearTimeout(l.B), l.B = null)
    }
    lr.prototype.ba = function() {
        this.B = null;
        const l = Date.now();
        0 <= l - this.S ? (lR(this.i, this.A), this.L != 2 && (lo(), gt(17)), si(this), this.s = 2, ho(this)) : wy(this, this.S - l)
    };

    function ho(l) {
        l.j.G == 0 || l.J || Hy(l.j, l)
    }

    function si(l) {
        kh(l);
        var d = l.M;
        d && typeof d.ma == "function" && d.ma(), l.M = null, ly(l.U), l.g && (d = l.g, l.g = null, d.abort(), d.ma())
    }

    function xh(l, d) {
        try {
            var p = l.j;
            if (p.G != 0 && (p.g == l || bh(p.h, l))) {
                if (!l.K && bh(p.h, l) && p.G == 3) {
                    try {
                        var y = p.Da.g.parse(d)
                    } catch {
                        y = null
                    }
                    if (Array.isArray(y) && y.length == 3) {
                        var N = y;
                        if (N[0] == 0) {
                            e: if (!p.u) {
                                if (p.g)
                                    if (p.g.F + 3e3 < l.F) vl(p), gl(p);
                                    else break e;
                                Oh(p), gt(18)
                            }
                        }
                        else p.za = N[1], 0 < p.za - p.T && 37500 > N[2] && p.F && p.v == 0 && !p.C && (p.C = uo(m(p.Za, p), 6e3));
                        if (1 >= Iy(p.h) && p.ca) {
                            try {
                                p.ca()
                            } catch {}
                            p.ca = void 0
                        }
                    } else ai(p, 11)
                } else if ((l.K || p.g == l) && vl(p), !v(d))
                    for (N = p.Da.g.parse(d), d = 0; d < N.length; d++) {
                        let oe = N[d];
                        if (p.T = oe[0], oe = oe[1], p.G == 2)
                            if (oe[0] == "c") {
                                p.K = oe[1], p.ia = oe[2];
                                const et = oe[3];
                                et != null && (p.la = et, p.j.info("VER=" + p.la));
                                const tt = oe[4];
                                tt != null && (p.Aa = tt, p.j.info("SVER=" + p.Aa));
                                const Hi = oe[5];
                                Hi != null && typeof Hi == "number" && 0 < Hi && (y = 1.5 * Hi, p.L = y, p.j.info("backChannelRequestTimeoutMs_=" + y)), y = p;
                                const tn = l.g;
                                if (tn) {
                                    const wl = tn.g ? tn.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                                    if (wl) {
                                        var V = y.h;
                                        V.g || wl.indexOf("spdy") == -1 && wl.indexOf("quic") == -1 && wl.indexOf("h2") == -1 || (V.j = V.l, V.g = new Set, V.h && (Nh(V, V.h), V.h = null))
                                    }
                                    if (y.D) {
                                        const Mh = tn.g ? tn.g.getResponseHeader("X-HTTP-Session-Id") : null;
                                        Mh && (y.ya = Mh, me(y.I, y.D, Mh))
                                    }
                                }
                                p.G = 3, p.l && p.l.ua(), p.ba && (p.R = Date.now() - l.F, p.j.info("Handshake RTT: " + p.R + "ms")), y = p;
                                var $ = l;
                                if (y.qa = Qy(y, y.J ? y.ia : null, y.W), $.K) {
                                    Sy(y.h, $);
                                    var de = $,
                                        We = y.L;
                                    We && (de.I = We), de.B && (kh(de), ul(de)), y.g = $
                                } else Wy(y);
                                0 < p.i.length && yl(p)
                            } else oe[0] != "stop" && oe[0] != "close" || ai(p, 7);
                        else p.G == 3 && (oe[0] == "stop" || oe[0] == "close" ? oe[0] == "stop" ? ai(p, 7) : Vh(p) : oe[0] != "noop" && p.l && p.l.ta(oe), p.v = 0)
                    }
            }
            lo(4)
        } catch {}
    }
    var hR = class {
        constructor(l, d) {
            this.g = l, this.map = d
        }
    };

    function Ty(l) {
        this.l = l || 10, a.PerformanceNavigationTiming ? (l = a.performance.getEntriesByType("navigation"), l = 0 < l.length && (l[0].nextHopProtocol == "hq" || l[0].nextHopProtocol == "h2")) : l = !!(a.chrome && a.chrome.loadTimes && a.chrome.loadTimes() && a.chrome.loadTimes().wasFetchedViaSpdy), this.j = l ? this.l : 1, this.g = null, 1 < this.j && (this.g = new Set), this.h = null, this.i = []
    }

    function Ey(l) {
        return l.h ? !0 : l.g ? l.g.size >= l.j : !1
    }

    function Iy(l) {
        return l.h ? 1 : l.g ? l.g.size : 0
    }

    function bh(l, d) {
        return l.h ? l.h == d : l.g ? l.g.has(d) : !1
    }

    function Nh(l, d) {
        l.g ? l.g.add(d) : l.h = d
    }

    function Sy(l, d) {
        l.h && l.h == d ? l.h = null : l.g && l.g.has(d) && l.g.delete(d)
    }
    Ty.prototype.cancel = function() {
        if (this.i = Ay(this), this.h) this.h.cancel(), this.h = null;
        else if (this.g && this.g.size !== 0) {
            for (const l of this.g.values()) l.cancel();
            this.g.clear()
        }
    };

    function Ay(l) {
        if (l.h != null) return l.i.concat(l.h.D);
        if (l.g != null && l.g.size !== 0) {
            let d = l.i;
            for (const p of l.g.values()) d = d.concat(p.D);
            return d
        }
        return R(l.i)
    }

    function dR(l) {
        if (l.V && typeof l.V == "function") return l.V();
        if (typeof Map < "u" && l instanceof Map || typeof Set < "u" && l instanceof Set) return Array.from(l.values());
        if (typeof l == "string") return l.split("");
        if (u(l)) {
            for (var d = [], p = l.length, y = 0; y < p; y++) d.push(l[y]);
            return d
        }
        d = [], p = 0;
        for (y in l) d[p++] = l[y];
        return d
    }

    function fR(l) {
        if (l.na && typeof l.na == "function") return l.na();
        if (!l.V || typeof l.V != "function") {
            if (typeof Map < "u" && l instanceof Map) return Array.from(l.keys());
            if (!(typeof Set < "u" && l instanceof Set)) {
                if (u(l) || typeof l == "string") {
                    var d = [];
                    l = l.length;
                    for (var p = 0; p < l; p++) d.push(p);
                    return d
                }
                d = [], p = 0;
                for (const y in l) d[p++] = y;
                return d
            }
        }
    }

    function Py(l, d) {
        if (l.forEach && typeof l.forEach == "function") l.forEach(d, void 0);
        else if (u(l) || typeof l == "string") Array.prototype.forEach.call(l, d, void 0);
        else
            for (var p = fR(l), y = dR(l), N = y.length, V = 0; V < N; V++) d.call(void 0, y[V], p && p[V], l)
    }
    var Ry = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");

    function pR(l, d) {
        if (l) {
            l = l.split("&");
            for (var p = 0; p < l.length; p++) {
                var y = l[p].indexOf("="),
                    N = null;
                if (0 <= y) {
                    var V = l[p].substring(0, y);
                    N = l[p].substring(y + 1)
                } else V = l[p];
                d(V, N ? decodeURIComponent(N.replace(/\+/g, " ")) : "")
            }
        }
    }

    function oi(l) {
        if (this.g = this.o = this.j = "", this.s = null, this.m = this.l = "", this.h = !1, l instanceof oi) {
            this.h = l.h, cl(this, l.j), this.o = l.o, this.g = l.g, hl(this, l.s), this.l = l.l;
            var d = l.i,
                p = new mo;
            p.i = d.i, d.g && (p.g = new Map(d.g), p.h = d.h), Cy(this, p), this.m = l.m
        } else l && (d = String(l).match(Ry)) ? (this.h = !1, cl(this, d[1] || "", !0), this.o = fo(d[2] || ""), this.g = fo(d[3] || "", !0), hl(this, d[4]), this.l = fo(d[5] || "", !0), Cy(this, d[6] || "", !0), this.m = fo(d[7] || "")) : (this.h = !1, this.i = new mo(null, this.h))
    }
    oi.prototype.toString = function() {
        var l = [],
            d = this.j;
        d && l.push(po(d, ky, !0), ":");
        var p = this.g;
        return (p || d == "file") && (l.push("//"), (d = this.o) && l.push(po(d, ky, !0), "@"), l.push(encodeURIComponent(String(p)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), p = this.s, p != null && l.push(":", String(p))), (p = this.l) && (this.g && p.charAt(0) != "/" && l.push("/"), l.push(po(p, p.charAt(0) == "/" ? yR : gR, !0))), (p = this.i.toString()) && l.push("?", p), (p = this.m) && l.push("#", po(p, _R)), l.join("")
    };

    function kn(l) {
        return new oi(l)
    }

    function cl(l, d, p) {
        l.j = p ? fo(d, !0) : d, l.j && (l.j = l.j.replace(/:$/, ""))
    }

    function hl(l, d) {
        if (d) {
            if (d = Number(d), isNaN(d) || 0 > d) throw Error("Bad port number " + d);
            l.s = d
        } else l.s = null
    }

    function Cy(l, d, p) {
        d instanceof mo ? (l.i = d, wR(l.i, l.h)) : (p || (d = po(d, vR)), l.i = new mo(d, l.h))
    }

    function me(l, d, p) {
        l.i.set(d, p)
    }

    function dl(l) {
        return me(l, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), l
    }

    function fo(l, d) {
        return l ? d ? decodeURI(l.replace(/%25/g, "%2525")) : decodeURIComponent(l) : ""
    }

    function po(l, d, p) {
        return typeof l == "string" ? (l = encodeURI(l).replace(d, mR), p && (l = l.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), l) : null
    }

    function mR(l) {
        return l = l.charCodeAt(0), "%" + (l >> 4 & 15).toString(16) + (l & 15).toString(16)
    }
    var ky = /[#\/\?@]/g,
        gR = /[#\?:]/g,
        yR = /[#\?]/g,
        vR = /[#\?@]/g,
        _R = /#/g;

    function mo(l, d) {
        this.h = this.g = null, this.i = l || null, this.j = !!d
    }

    function ur(l) {
        l.g || (l.g = new Map, l.h = 0, l.i && pR(l.i, function(d, p) {
            l.add(decodeURIComponent(d.replace(/\+/g, " ")), p)
        }))
    }
    t = mo.prototype, t.add = function(l, d) {
        ur(this), this.i = null, l = Wi(this, l);
        var p = this.g.get(l);
        return p || this.g.set(l, p = []), p.push(d), this.h += 1, this
    };

    function xy(l, d) {
        ur(l), d = Wi(l, d), l.g.has(d) && (l.i = null, l.h -= l.g.get(d).length, l.g.delete(d))
    }

    function by(l, d) {
        return ur(l), d = Wi(l, d), l.g.has(d)
    }
    t.forEach = function(l, d) {
        ur(this), this.g.forEach(function(p, y) {
            p.forEach(function(N) {
                l.call(d, N, y, this)
            }, this)
        }, this)
    }, t.na = function() {
        ur(this);
        const l = Array.from(this.g.values()),
            d = Array.from(this.g.keys()),
            p = [];
        for (let y = 0; y < d.length; y++) {
            const N = l[y];
            for (let V = 0; V < N.length; V++) p.push(d[y])
        }
        return p
    }, t.V = function(l) {
        ur(this);
        let d = [];
        if (typeof l == "string") by(this, l) && (d = d.concat(this.g.get(Wi(this, l))));
        else {
            l = Array.from(this.g.values());
            for (let p = 0; p < l.length; p++) d = d.concat(l[p])
        }
        return d
    }, t.set = function(l, d) {
        return ur(this), this.i = null, l = Wi(this, l), by(this, l) && (this.h -= this.g.get(l).length), this.g.set(l, [d]), this.h += 1, this
    }, t.get = function(l, d) {
        return l ? (l = this.V(l), 0 < l.length ? String(l[0]) : d) : d
    };

    function Ny(l, d, p) {
        xy(l, d), 0 < p.length && (l.i = null, l.g.set(Wi(l, d), R(p)), l.h += p.length)
    }
    t.toString = function() {
        if (this.i) return this.i;
        if (!this.g) return "";
        const l = [],
            d = Array.from(this.g.keys());
        for (var p = 0; p < d.length; p++) {
            var y = d[p];
            const V = encodeURIComponent(String(y)),
                $ = this.V(y);
            for (y = 0; y < $.length; y++) {
                var N = V;
                $[y] !== "" && (N += "=" + encodeURIComponent(String($[y]))), l.push(N)
            }
        }
        return this.i = l.join("&")
    };

    function Wi(l, d) {
        return d = String(d), l.j && (d = d.toLowerCase()), d
    }

    function wR(l, d) {
        d && !l.j && (ur(l), l.i = null, l.g.forEach(function(p, y) {
            var N = y.toLowerCase();
            y != N && (xy(this, y), Ny(this, N, p))
        }, l)), l.j = d
    }

    function TR(l, d) {
        const p = new co;
        if (a.Image) {
            const y = new Image;
            y.onload = _(cr, p, "TestLoadImage: loaded", !0, d, y), y.onerror = _(cr, p, "TestLoadImage: error", !1, d, y), y.onabort = _(cr, p, "TestLoadImage: abort", !1, d, y), y.ontimeout = _(cr, p, "TestLoadImage: timeout", !1, d, y), a.setTimeout(function() {
                y.ontimeout && y.ontimeout()
            }, 1e4), y.src = l
        } else d(!1)
    }

    function ER(l, d) {
        const p = new co,
            y = new AbortController,
            N = setTimeout(() => {
                y.abort(), cr(p, "TestPingServer: timeout", !1, d)
            }, 1e4);
        fetch(l, {
            signal: y.signal
        }).then(V => {
            clearTimeout(N), V.ok ? cr(p, "TestPingServer: ok", !0, d) : cr(p, "TestPingServer: server error", !1, d)
        }).catch(() => {
            clearTimeout(N), cr(p, "TestPingServer: error", !1, d)
        })
    }

    function cr(l, d, p, y, N) {
        try {
            N && (N.onload = null, N.onerror = null, N.onabort = null, N.ontimeout = null), y(p)
        } catch {}
    }

    function IR() {
        this.g = new sR
    }

    function SR(l, d, p) {
        const y = p || "";
        try {
            Py(l, function(N, V) {
                let $ = N;
                c(N) && ($ = Eh(N)), d.push(y + V + "=" + encodeURIComponent($))
            })
        } catch (N) {
            throw d.push(y + "type=" + encodeURIComponent("_badmap")), N
        }
    }

    function fl(l) {
        this.l = l.Ub || null, this.j = l.eb || !1
    }
    I(fl, Ih), fl.prototype.g = function() {
        return new pl(this.l, this.j)
    }, fl.prototype.i = function(l) {
        return function() {
            return l
        }
    }({});

    function pl(l, d) {
        Ze.call(this), this.D = l, this.o = d, this.m = void 0, this.status = this.readyState = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.u = new Headers, this.h = null, this.B = "GET", this.A = "", this.g = !1, this.v = this.j = this.l = null
    }
    I(pl, Ze), t = pl.prototype, t.open = function(l, d) {
        if (this.readyState != 0) throw this.abort(), Error("Error reopening a connection");
        this.B = l, this.A = d, this.readyState = 1, yo(this)
    }, t.send = function(l) {
        if (this.readyState != 1) throw this.abort(), Error("need to call open() first. ");
        this.g = !0;
        const d = {
            headers: this.u,
            method: this.B,
            credentials: this.m,
            cache: void 0
        };
        l && (d.body = l), (this.D || a).fetch(new Request(this.A, d)).then(this.Sa.bind(this), this.ga.bind(this))
    }, t.abort = function() {
        this.response = this.responseText = "", this.u = new Headers, this.status = 0, this.j && this.j.cancel("Request was aborted.").catch(() => {}), 1 <= this.readyState && this.g && this.readyState != 4 && (this.g = !1, go(this)), this.readyState = 0
    }, t.Sa = function(l) {
        if (this.g && (this.l = l, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = l.headers, this.readyState = 2, yo(this)), this.g && (this.readyState = 3, yo(this), this.g)))
            if (this.responseType === "arraybuffer") l.arrayBuffer().then(this.Qa.bind(this), this.ga.bind(this));
            else if (typeof a.ReadableStream < "u" && "body" in l) {
            if (this.j = l.body.getReader(), this.o) {
                if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
                this.response = []
            } else this.response = this.responseText = "", this.v = new TextDecoder;
            Dy(this)
        } else l.text().then(this.Ra.bind(this), this.ga.bind(this))
    };

    function Dy(l) {
        l.j.read().then(l.Pa.bind(l)).catch(l.ga.bind(l))
    }
    t.Pa = function(l) {
        if (this.g) {
            if (this.o && l.value) this.response.push(l.value);
            else if (!this.o) {
                var d = l.value ? l.value : new Uint8Array(0);
                (d = this.v.decode(d, {
                    stream: !l.done
                })) && (this.response = this.responseText += d)
            }
            l.done ? go(this) : yo(this), this.readyState == 3 && Dy(this)
        }
    }, t.Ra = function(l) {
        this.g && (this.response = this.responseText = l, go(this))
    }, t.Qa = function(l) {
        this.g && (this.response = l, go(this))
    }, t.ga = function() {
        this.g && go(this)
    };

    function go(l) {
        l.readyState = 4, l.l = null, l.j = null, l.v = null, yo(l)
    }
    t.setRequestHeader = function(l, d) {
        this.u.append(l, d)
    }, t.getResponseHeader = function(l) {
        return this.h && this.h.get(l.toLowerCase()) || ""
    }, t.getAllResponseHeaders = function() {
        if (!this.h) return "";
        const l = [],
            d = this.h.entries();
        for (var p = d.next(); !p.done;) p = p.value, l.push(p[0] + ": " + p[1]), p = d.next();
        return l.join(`\r
`)
    };

    function yo(l) {
        l.onreadystatechange && l.onreadystatechange.call(l)
    }
    Object.defineProperty(pl.prototype, "withCredentials", {
        get: function() {
            return this.m === "include"
        },
        set: function(l) {
            this.m = l ? "include" : "same-origin"
        }
    });

    function Vy(l) {
        let d = "";
        return U(l, function(p, y) {
            d += y, d += ":", d += p, d += `\r
`
        }), d
    }

    function Dh(l, d, p) {
        e: {
            for (y in p) {
                var y = !1;
                break e
            }
            y = !0
        }
        y || (p = Vy(p), typeof l == "string" ? p != null && encodeURIComponent(String(p)) : me(l, d, p))
    }

    function Pe(l) {
        Ze.call(this), this.headers = new Map, this.o = l || null, this.h = !1, this.v = this.g = null, this.D = "", this.m = 0, this.l = "", this.j = this.B = this.u = this.A = !1, this.I = null, this.H = "", this.J = !1
    }
    I(Pe, Ze);
    var AR = /^https?$/i,
        PR = ["POST", "PUT"];
    t = Pe.prototype, t.Ha = function(l) {
        this.J = l
    }, t.ea = function(l, d, p, y) {
        if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.D + "; newUri=" + l);
        d = d ? d.toUpperCase() : "GET", this.D = l, this.l = "", this.m = 0, this.A = !1, this.h = !0, this.g = this.o ? this.o.g() : Ph.g(), this.v = this.o ? uy(this.o) : uy(Ph), this.g.onreadystatechange = m(this.Ea, this);
        try {
            this.B = !0, this.g.open(d, String(l), !0), this.B = !1
        } catch (V) {
            Oy(this, V);
            return
        }
        if (l = p || "", p = new Map(this.headers), y)
            if (Object.getPrototypeOf(y) === Object.prototype)
                for (var N in y) p.set(N, y[N]);
            else if (typeof y.keys == "function" && typeof y.get == "function")
            for (const V of y.keys()) p.set(V, y.get(V));
        else throw Error("Unknown input type for opt_headers: " + String(y));
        y = Array.from(p.keys()).find(V => V.toLowerCase() == "content-type"), N = a.FormData && l instanceof a.FormData, !(0 <= Array.prototype.indexOf.call(PR, d, void 0)) || y || N || p.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
        for (const [V, $] of p) this.g.setRequestHeader(V, $);
        this.H && (this.g.responseType = this.H), "withCredentials" in this.g && this.g.withCredentials !== this.J && (this.g.withCredentials = this.J);
        try {
            Fy(this), this.u = !0, this.g.send(l), this.u = !1
        } catch (V) {
            Oy(this, V)
        }
    };

    function Oy(l, d) {
        l.h = !1, l.g && (l.j = !0, l.g.abort(), l.j = !1), l.l = d, l.m = 5, Ly(l), ml(l)
    }

    function Ly(l) {
        l.A || (l.A = !0, mt(l, "complete"), mt(l, "error"))
    }
    t.abort = function(l) {
        this.g && this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1, this.m = l || 7, mt(this, "complete"), mt(this, "abort"), ml(this))
    }, t.N = function() {
        this.g && (this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1), ml(this, !0)), Pe.aa.N.call(this)
    }, t.Ea = function() {
        this.s || (this.B || this.u || this.j ? My(this) : this.bb())
    }, t.bb = function() {
        My(this)
    };

    function My(l) {
        if (l.h && typeof o < "u" && (!l.v[1] || xn(l) != 4 || l.Z() != 2)) {
            if (l.u && xn(l) == 4) sy(l.Ea, 0, l);
            else if (mt(l, "readystatechange"), xn(l) == 4) {
                l.h = !1;
                try {
                    const $ = l.Z();
                    e: switch ($) {
                        case 200:
                        case 201:
                        case 202:
                        case 204:
                        case 206:
                        case 304:
                        case 1223:
                            var d = !0;
                            break e;
                        default:
                            d = !1
                    }
                    var p;
                    if (!(p = d)) {
                        var y;
                        if (y = $ === 0) {
                            var N = String(l.D).match(Ry)[1] || null;
                            !N && a.self && a.self.location && (N = a.self.location.protocol.slice(0, -1)), y = !AR.test(N ? N.toLowerCase() : "")
                        }
                        p = y
                    }
                    if (p) mt(l, "complete"), mt(l, "success");
                    else {
                        l.m = 6;
                        try {
                            var V = 2 < xn(l) ? l.g.statusText : ""
                        } catch {
                            V = ""
                        }
                        l.l = V + " [" + l.Z() + "]", Ly(l)
                    }
                } finally {
                    ml(l)
                }
            }
        }
    }

    function ml(l, d) {
        if (l.g) {
            Fy(l);
            const p = l.g,
                y = l.v[0] ? () => {} : null;
            l.g = null, l.v = null, d || mt(l, "ready");
            try {
                p.onreadystatechange = y
            } catch {}
        }
    }

    function Fy(l) {
        l.I && (a.clearTimeout(l.I), l.I = null)
    }
    t.isActive = function() {
        return !!this.g
    };

    function xn(l) {
        return l.g ? l.g.readyState : 0
    }
    t.Z = function() {
        try {
            return 2 < xn(this) ? this.g.status : -1
        } catch {
            return -1
        }
    }, t.oa = function() {
        try {
            return this.g ? this.g.responseText : ""
        } catch {
            return ""
        }
    }, t.Oa = function(l) {
        if (this.g) {
            var d = this.g.responseText;
            return l && d.indexOf(l) == 0 && (d = d.substring(l.length)), iR(d)
        }
    };

    function Uy(l) {
        try {
            if (!l.g) return null;
            if ("response" in l.g) return l.g.response;
            switch (l.H) {
                case "":
                case "text":
                    return l.g.responseText;
                case "arraybuffer":
                    if ("mozResponseArrayBuffer" in l.g) return l.g.mozResponseArrayBuffer
            }
            return null
        } catch {
            return null
        }
    }

    function RR(l) {
        const d = {};
        l = (l.g && 2 <= xn(l) && l.g.getAllResponseHeaders() || "").split(`\r
`);
        for (let y = 0; y < l.length; y++) {
            if (v(l[y])) continue;
            var p = C(l[y]);
            const N = p[0];
            if (p = p[1], typeof p != "string") continue;
            p = p.trim();
            const V = d[N] || [];
            d[N] = V, V.push(p)
        }
        S(d, function(y) {
            return y.join(", ")
        })
    }
    t.Ba = function() {
        return this.m
    }, t.Ka = function() {
        return typeof this.l == "string" ? this.l : String(this.l)
    };

    function vo(l, d, p) {
        return p && p.internalChannelParams && p.internalChannelParams[l] || d
    }

    function jy(l) {
        this.Aa = 0, this.i = [], this.j = new co, this.ia = this.qa = this.I = this.W = this.g = this.ya = this.D = this.H = this.m = this.S = this.o = null, this.Ya = this.U = 0, this.Va = vo("failFast", !1, l), this.F = this.C = this.u = this.s = this.l = null, this.X = !0, this.za = this.T = -1, this.Y = this.v = this.B = 0, this.Ta = vo("baseRetryDelayMs", 5e3, l), this.cb = vo("retryDelaySeedMs", 1e4, l), this.Wa = vo("forwardChannelMaxRetries", 2, l), this.wa = vo("forwardChannelRequestTimeoutMs", 2e4, l), this.pa = l && l.xmlHttpFactory || void 0, this.Xa = l && l.Tb || void 0, this.Ca = l && l.useFetchStreams || !1, this.L = void 0, this.J = l && l.supportsCrossDomainXhr || !1, this.K = "", this.h = new Ty(l && l.concurrentRequestLimit), this.Da = new IR, this.P = l && l.fastHandshake || !1, this.O = l && l.encodeInitMessageHeaders || !1, this.P && this.O && (this.O = !1), this.Ua = l && l.Rb || !1, l && l.xa && this.j.xa(), l && l.forceLongPolling && (this.X = !1), this.ba = !this.P && this.X && l && l.detectBufferingProxy || !1, this.ja = void 0, l && l.longPollingTimeout && 0 < l.longPollingTimeout && (this.ja = l.longPollingTimeout), this.ca = void 0, this.R = 0, this.M = !1, this.ka = this.A = null
    }
    t = jy.prototype, t.la = 8, t.G = 1, t.connect = function(l, d, p, y) {
        gt(0), this.W = l, this.H = d || {}, p && y !== void 0 && (this.H.OSID = p, this.H.OAID = y), this.F = this.X, this.I = Qy(this, null, this.W), yl(this)
    };

    function Vh(l) {
        if (By(l), l.G == 3) {
            var d = l.U++,
                p = kn(l.I);
            if (me(p, "SID", l.K), me(p, "RID", d), me(p, "TYPE", "terminate"), _o(l, p), d = new lr(l, l.j, d), d.L = 2, d.v = dl(kn(p)), p = !1, a.navigator && a.navigator.sendBeacon) try {
                p = a.navigator.sendBeacon(d.v.toString(), "")
            } catch {}!p && a.Image && (new Image().src = d.v, p = !0), p || (d.g = Yy(d.j, null), d.g.ea(d.v)), d.F = Date.now(), ul(d)
        }
        Gy(l)
    }

    function gl(l) {
        l.g && (Lh(l), l.g.cancel(), l.g = null)
    }

    function By(l) {
        gl(l), l.u && (a.clearTimeout(l.u), l.u = null), vl(l), l.h.cancel(), l.s && (typeof l.s == "number" && a.clearTimeout(l.s), l.s = null)
    }

    function yl(l) {
        if (!Ey(l.h) && !l.s) {
            l.s = !0;
            var d = l.Ga;
            le || Q(), B || (le(), B = !0), K.add(d, l), l.B = 0
        }
    }

    function CR(l, d) {
        return Iy(l.h) >= l.h.j - (l.s ? 1 : 0) ? !1 : l.s ? (l.i = d.D.concat(l.i), !0) : l.G == 1 || l.G == 2 || l.B >= (l.Va ? 0 : l.Wa) ? !1 : (l.s = uo(m(l.Ga, l, d), Ky(l, l.B)), l.B++, !0)
    }
    t.Ga = function(l) {
        if (this.s)
            if (this.s = null, this.G == 1) {
                if (!l) {
                    this.U = Math.floor(1e5 * Math.random()), l = this.U++;
                    const N = new lr(this, this.j, l);
                    let V = this.o;
                    if (this.S && (V ? (V = g(V), A(V, this.S)) : V = this.S), this.m !== null || this.O || (N.H = V, V = null), this.P) e: {
                        for (var d = 0, p = 0; p < this.i.length; p++) {
                            t: {
                                var y = this.i[p];
                                if ("__data__" in y.map && (y = y.map.__data__, typeof y == "string")) {
                                    y = y.length;
                                    break t
                                }
                                y = void 0
                            }
                            if (y === void 0) break;
                            if (d += y, 4096 < d) {
                                d = p;
                                break e
                            }
                            if (d === 4096 || p === this.i.length - 1) {
                                d = p + 1;
                                break e
                            }
                        }
                        d = 1e3
                    }
                    else d = 1e3;
                    d = zy(this, N, d), p = kn(this.I), me(p, "RID", l), me(p, "CVER", 22), this.D && me(p, "X-HTTP-Session-Id", this.D), _o(this, p), V && (this.O ? d = "headers=" + encodeURIComponent(String(Vy(V))) + "&" + d : this.m && Dh(p, this.m, V)), Nh(this.h, N), this.Ua && me(p, "TYPE", "init"), this.P ? (me(p, "$req", d), me(p, "SID", "null"), N.T = !0, Ch(N, p, null)) : Ch(N, p, d), this.G = 2
                }
            } else this.G == 3 && (l ? $y(this, l) : this.i.length == 0 || Ey(this.h) || $y(this))
    };

    function $y(l, d) {
        var p;
        d ? p = d.l : p = l.U++;
        const y = kn(l.I);
        me(y, "SID", l.K), me(y, "RID", p), me(y, "AID", l.T), _o(l, y), l.m && l.o && Dh(y, l.m, l.o), p = new lr(l, l.j, p, l.B + 1), l.m === null && (p.H = l.o), d && (l.i = d.D.concat(l.i)), d = zy(l, p, 1e3), p.I = Math.round(.5 * l.wa) + Math.round(.5 * l.wa * Math.random()), Nh(l.h, p), Ch(p, y, d)
    }

    function _o(l, d) {
        l.H && U(l.H, function(p, y) {
            me(d, y, p)
        }), l.l && Py({}, function(p, y) {
            me(d, y, p)
        })
    }

    function zy(l, d, p) {
        p = Math.min(l.i.length, p);
        var y = l.l ? m(l.l.Na, l.l, l) : null;
        e: {
            var N = l.i;
            let V = -1;
            for (;;) {
                const $ = ["count=" + p];
                V == -1 ? 0 < p ? (V = N[0].g, $.push("ofs=" + V)) : V = 0 : $.push("ofs=" + V);
                let de = !0;
                for (let We = 0; We < p; We++) {
                    let oe = N[We].g;
                    const et = N[We].map;
                    if (oe -= V, 0 > oe) V = Math.max(0, N[We].g - 100), de = !1;
                    else try {
                        SR(et, $, "req" + oe + "_")
                    } catch {
                        y && y(et)
                    }
                }
                if (de) {
                    y = $.join("&");
                    break e
                }
            }
        }
        return l = l.i.splice(0, p), d.D = l, y
    }

    function Wy(l) {
        if (!l.g && !l.u) {
            l.Y = 1;
            var d = l.Fa;
            le || Q(), B || (le(), B = !0), K.add(d, l), l.v = 0
        }
    }

    function Oh(l) {
        return l.g || l.u || 3 <= l.v ? !1 : (l.Y++, l.u = uo(m(l.Fa, l), Ky(l, l.v)), l.v++, !0)
    }
    t.Fa = function() {
        if (this.u = null, qy(this), this.ba && !(this.M || this.g == null || 0 >= this.R)) {
            var l = 2 * this.R;
            this.j.info("BP detection timer enabled: " + l), this.A = uo(m(this.ab, this), l)
        }
    }, t.ab = function() {
        this.A && (this.A = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.F = !1, this.M = !0, gt(10), gl(this), qy(this))
    };

    function Lh(l) {
        l.A != null && (a.clearTimeout(l.A), l.A = null)
    }

    function qy(l) {
        l.g = new lr(l, l.j, "rpc", l.Y), l.m === null && (l.g.H = l.o), l.g.O = 0;
        var d = kn(l.qa);
        me(d, "RID", "rpc"), me(d, "SID", l.K), me(d, "AID", l.T), me(d, "CI", l.F ? "0" : "1"), !l.F && l.ja && me(d, "TO", l.ja), me(d, "TYPE", "xmlhttp"), _o(l, d), l.m && l.o && Dh(d, l.m, l.o), l.L && (l.g.I = l.L);
        var p = l.g;
        l = l.ia, p.L = 1, p.v = dl(kn(d)), p.m = null, p.P = !0, vy(p, l)
    }
    t.Za = function() {
        this.C != null && (this.C = null, gl(this), Oh(this), gt(19))
    };

    function vl(l) {
        l.C != null && (a.clearTimeout(l.C), l.C = null)
    }

    function Hy(l, d) {
        var p = null;
        if (l.g == d) {
            vl(l), Lh(l), l.g = null;
            var y = 2
        } else if (bh(l.h, d)) p = d.D, Sy(l.h, d), y = 1;
        else return;
        if (l.G != 0) {
            if (d.o)
                if (y == 1) {
                    p = d.m ? d.m.length : 0, d = Date.now() - d.F;
                    var N = l.B;
                    y = ol(), mt(y, new py(y, p)), yl(l)
                } else Wy(l);
            else if (N = d.s, N == 3 || N == 0 && 0 < d.X || !(y == 1 && CR(l, d) || y == 2 && Oh(l))) switch (p && 0 < p.length && (d = l.h, d.i = d.i.concat(p)), N) {
                case 1:
                    ai(l, 5);
                    break;
                case 4:
                    ai(l, 10);
                    break;
                case 3:
                    ai(l, 6);
                    break;
                default:
                    ai(l, 2)
            }
        }
    }

    function Ky(l, d) {
        let p = l.Ta + Math.floor(Math.random() * l.cb);
        return l.isActive() || (p *= 2), p * d
    }

    function ai(l, d) {
        if (l.j.info("Error code " + d), d == 2) {
            var p = m(l.fb, l),
                y = l.Xa;
            const N = !y;
            y = new oi(y || "//www.google.com/images/cleardot.gif"), a.location && a.location.protocol == "http" || cl(y, "https"), dl(y), N ? TR(y.toString(), p) : ER(y.toString(), p)
        } else gt(2);
        l.G = 0, l.l && l.l.sa(d), Gy(l), By(l)
    }
    t.fb = function(l) {
        l ? (this.j.info("Successfully pinged google.com"), gt(2)) : (this.j.info("Failed to ping google.com"), gt(1))
    };

    function Gy(l) {
        if (l.G = 0, l.ka = [], l.l) {
            const d = Ay(l.h);
            (d.length != 0 || l.i.length != 0) && (k(l.ka, d), k(l.ka, l.i), l.h.i.length = 0, R(l.i), l.i.length = 0), l.l.ra()
        }
    }

    function Qy(l, d, p) {
        var y = p instanceof oi ? kn(p) : new oi(p);
        if (y.g != "") d && (y.g = d + "." + y.g), hl(y, y.s);
        else {
            var N = a.location;
            y = N.protocol, d = d ? d + "." + N.hostname : N.hostname, N = +N.port;
            var V = new oi(null);
            y && cl(V, y), d && (V.g = d), N && hl(V, N), p && (V.l = p), y = V
        }
        return p = l.D, d = l.ya, p && d && me(y, p, d), me(y, "VER", l.la), _o(l, y), y
    }

    function Yy(l, d, p) {
        if (d && !l.J) throw Error("Can't create secondary domain capable XhrIo object.");
        return d = l.Ca && !l.pa ? new Pe(new fl({
            eb: p
        })) : new Pe(l.pa), d.Ha(l.J), d
    }
    t.isActive = function() {
        return !!this.l && this.l.isActive(this)
    };

    function Xy() {}
    t = Xy.prototype, t.ua = function() {}, t.ta = function() {}, t.sa = function() {}, t.ra = function() {}, t.isActive = function() {
        return !0
    }, t.Na = function() {};

    function _l() {}
    _l.prototype.g = function(l, d) {
        return new Dt(l, d)
    };

    function Dt(l, d) {
        Ze.call(this), this.g = new jy(d), this.l = l, this.h = d && d.messageUrlParams || null, l = d && d.messageHeaders || null, d && d.clientProtocolHeaderRequired && (l ? l["X-Client-Protocol"] = "webchannel" : l = {
            "X-Client-Protocol": "webchannel"
        }), this.g.o = l, l = d && d.initMessageHeaders || null, d && d.messageContentType && (l ? l["X-WebChannel-Content-Type"] = d.messageContentType : l = {
            "X-WebChannel-Content-Type": d.messageContentType
        }), d && d.va && (l ? l["X-WebChannel-Client-Profile"] = d.va : l = {
            "X-WebChannel-Client-Profile": d.va
        }), this.g.S = l, (l = d && d.Sb) && !v(l) && (this.g.m = l), this.v = d && d.supportsCrossDomainXhr || !1, this.u = d && d.sendRawJson || !1, (d = d && d.httpSessionIdParam) && !v(d) && (this.g.D = d, l = this.h, l !== null && d in l && (l = this.h, d in l && delete l[d])), this.j = new qi(this)
    }
    I(Dt, Ze), Dt.prototype.m = function() {
        this.g.l = this.j, this.v && (this.g.J = !0), this.g.connect(this.l, this.h || void 0)
    }, Dt.prototype.close = function() {
        Vh(this.g)
    }, Dt.prototype.o = function(l) {
        var d = this.g;
        if (typeof l == "string") {
            var p = {};
            p.__data__ = l, l = p
        } else this.u && (p = {}, p.__data__ = Eh(l), l = p);
        d.i.push(new hR(d.Ya++, l)), d.G == 3 && yl(d)
    }, Dt.prototype.N = function() {
        this.g.l = null, delete this.j, Vh(this.g), delete this.g, Dt.aa.N.call(this)
    };

    function Jy(l) {
        Sh.call(this), l.__headers__ && (this.headers = l.__headers__, this.statusCode = l.__status__, delete l.__headers__, delete l.__status__);
        var d = l.__sm__;
        if (d) {
            e: {
                for (const p in d) {
                    l = p;
                    break e
                }
                l = void 0
            }(this.i = l) && (l = this.i, d = d !== null && l in d ? d[l] : void 0),
            this.data = d
        }
        else this.data = l
    }
    I(Jy, Sh);

    function Zy() {
        Ah.call(this), this.status = 1
    }
    I(Zy, Ah);

    function qi(l) {
        this.g = l
    }
    I(qi, Xy), qi.prototype.ua = function() {
        mt(this.g, "a")
    }, qi.prototype.ta = function(l) {
        mt(this.g, new Jy(l))
    }, qi.prototype.sa = function(l) {
        mt(this.g, new Zy)
    }, qi.prototype.ra = function() {
        mt(this.g, "b")
    }, _l.prototype.createWebChannel = _l.prototype.g, Dt.prototype.send = Dt.prototype.o, Dt.prototype.open = Dt.prototype.m, Dt.prototype.close = Dt.prototype.close, hS = function() {
        return new _l
    }, cS = function() {
        return ol()
    }, uS = ii, zf = {
        mb: 0,
        pb: 1,
        qb: 2,
        Jb: 3,
        Ob: 4,
        Lb: 5,
        Mb: 6,
        Kb: 7,
        Ib: 8,
        Nb: 9,
        PROXY: 10,
        NOPROXY: 11,
        Gb: 12,
        Cb: 13,
        Db: 14,
        Bb: 15,
        Eb: 16,
        Fb: 17,
        ib: 18,
        hb: 19,
        jb: 20
    }, al.NO_ERROR = 0, al.TIMEOUT = 8, al.HTTP_ERROR = 6, au = al, my.COMPLETE = "complete", lS = my, cy.EventType = ao, ao.OPEN = "a", ao.CLOSE = "b", ao.ERROR = "c", ao.MESSAGE = "d", Ze.prototype.listen = Ze.prototype.K, Do = cy, Pe.prototype.listenOnce = Pe.prototype.L, Pe.prototype.getLastError = Pe.prototype.Ka, Pe.prototype.getLastErrorCode = Pe.prototype.Ba, Pe.prototype.getStatus = Pe.prototype.Z, Pe.prototype.getResponseJson = Pe.prototype.Oa, Pe.prototype.getResponseText = Pe.prototype.oa, Pe.prototype.send = Pe.prototype.ea, Pe.prototype.setWithCredentials = Pe.prototype.Ha, aS = Pe
}).apply(typeof Fl < "u" ? Fl : typeof self < "u" ? self : typeof window < "u" ? window : {});
const x_ = "@firebase/firestore";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ot {
    constructor(e) {
        this.uid = e
    }
    isAuthenticated() {
        return this.uid != null
    }
    toKey() {
        return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user"
    }
    isEqual(e) {
        return e.uid === this.uid
    }
}
ot.UNAUTHENTICATED = new ot(null), ot.GOOGLE_CREDENTIALS = new ot("google-credentials-uid"), ot.FIRST_PARTY = new ot("first-party-uid"), ot.MOCK_USER = new ot("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Gs = "11.0.2";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ni = new jc("@firebase/firestore");

function Qi() {
    return Ni.logLevel
}

function W(t, ...e) {
    if (Ni.logLevel <= te.DEBUG) {
        const n = e.map(km);
        Ni.debug(`Firestore (${Gs}): ${t}`, ...n)
    }
}

function Zn(t, ...e) {
    if (Ni.logLevel <= te.ERROR) {
        const n = e.map(km);
        Ni.error(`Firestore (${Gs}): ${t}`, ...n)
    }
}

function Vs(t, ...e) {
    if (Ni.logLevel <= te.WARN) {
        const n = e.map(km);
        Ni.warn(`Firestore (${Gs}): ${t}`, ...n)
    }
}

function km(t) {
    if (typeof t == "string") return t;
    try {
        /**
         * @license
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        return function(n) {
            return JSON.stringify(n)
        }(t)
    } catch {
        return t
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Y(t = "Unexpected state") {
    const e = `FIRESTORE (${Gs}) INTERNAL ASSERTION FAILED: ` + t;
    throw Zn(e), new Error(e)
}

function ae(t, e) {
    t || Y()
}

function Z(t, e) {
    return t
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const L = {
    OK: "ok",
    CANCELLED: "cancelled",
    UNKNOWN: "unknown",
    INVALID_ARGUMENT: "invalid-argument",
    DEADLINE_EXCEEDED: "deadline-exceeded",
    NOT_FOUND: "not-found",
    ALREADY_EXISTS: "already-exists",
    PERMISSION_DENIED: "permission-denied",
    UNAUTHENTICATED: "unauthenticated",
    RESOURCE_EXHAUSTED: "resource-exhausted",
    FAILED_PRECONDITION: "failed-precondition",
    ABORTED: "aborted",
    OUT_OF_RANGE: "out-of-range",
    UNIMPLEMENTED: "unimplemented",
    INTERNAL: "internal",
    UNAVAILABLE: "unavailable",
    DATA_LOSS: "data-loss"
};
class z extends en {
    constructor(e, n) {
        super(e, n), this.code = e, this.message = n, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zn {
    constructor() {
        this.promise = new Promise((e, n) => {
            this.resolve = e, this.reject = n
        })
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dS {
    constructor(e, n) {
        this.user = n, this.type = "OAuth", this.headers = new Map, this.headers.set("Authorization", `Bearer ${e}`)
    }
}
class cD {
    getToken() {
        return Promise.resolve(null)
    }
    invalidateToken() {}
    start(e, n) {
        e.enqueueRetryable(() => n(ot.UNAUTHENTICATED))
    }
    shutdown() {}
}
class hD {
    constructor(e) {
        this.token = e, this.changeListener = null
    }
    getToken() {
        return Promise.resolve(this.token)
    }
    invalidateToken() {}
    start(e, n) {
        this.changeListener = n, e.enqueueRetryable(() => n(this.token.user))
    }
    shutdown() {
        this.changeListener = null
    }
}
class dD {
    constructor(e) {
        this.t = e, this.currentUser = ot.UNAUTHENTICATED, this.i = 0, this.forceRefresh = !1, this.auth = null
    }
    start(e, n) {
        ae(this.o === void 0);
        let r = this.i;
        const i = u => this.i !== r ? (r = this.i, n(u)) : Promise.resolve();
        let s = new zn;
        this.o = () => {
            this.i++, this.currentUser = this.u(), s.resolve(), s = new zn, e.enqueueRetryable(() => i(this.currentUser))
        };
        const o = () => {
                const u = s;
                e.enqueueRetryable(async () => {
                    await u.promise, await i(this.currentUser)
                })
            },
            a = u => {
                W("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = u, this.o && (this.auth.addAuthTokenListener(this.o), o())
            };
        this.t.onInit(u => a(u)), setTimeout(() => {
            if (!this.auth) {
                const u = this.t.getImmediate({
                    optional: !0
                });
                u ? a(u) : (W("FirebaseAuthCredentialsProvider", "Auth not yet detected"), s.resolve(), s = new zn)
            }
        }, 0), o()
    }
    getToken() {
        const e = this.i,
            n = this.forceRefresh;
        return this.forceRefresh = !1, this.auth ? this.auth.getToken(n).then(r => this.i !== e ? (W("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : r ? (ae(typeof r.accessToken == "string"), new dS(r.accessToken, this.currentUser)) : null) : Promise.resolve(null)
    }
    invalidateToken() {
        this.forceRefresh = !0
    }
    shutdown() {
        this.auth && this.o && this.auth.removeAuthTokenListener(this.o), this.o = void 0
    }
    u() {
        const e = this.auth && this.auth.getUid();
        return ae(e === null || typeof e == "string"), new ot(e)
    }
}
class fD {
    constructor(e, n, r) {
        this.l = e, this.h = n, this.P = r, this.type = "FirstParty", this.user = ot.FIRST_PARTY, this.T = new Map
    }
    I() {
        return this.P ? this.P() : null
    }
    get headers() {
        this.T.set("X-Goog-AuthUser", this.l);
        const e = this.I();
        return e && this.T.set("Authorization", e), this.h && this.T.set("X-Goog-Iam-Authorization-Token", this.h), this.T
    }
}
class pD {
    constructor(e, n, r) {
        this.l = e, this.h = n, this.P = r
    }
    getToken() {
        return Promise.resolve(new fD(this.l, this.h, this.P))
    }
    start(e, n) {
        e.enqueueRetryable(() => n(ot.FIRST_PARTY))
    }
    shutdown() {}
    invalidateToken() {}
}
class mD {
    constructor(e) {
        this.value = e, this.type = "AppCheck", this.headers = new Map, e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value)
    }
}
class gD {
    constructor(e) {
        this.A = e, this.forceRefresh = !1, this.appCheck = null, this.R = null
    }
    start(e, n) {
        ae(this.o === void 0);
        const r = s => {
            s.error != null && W("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${s.error.message}`);
            const o = s.token !== this.R;
            return this.R = s.token, W("FirebaseAppCheckTokenProvider", `Received ${o?"new":"existing"} token.`), o ? n(s.token) : Promise.resolve()
        };
        this.o = s => {
            e.enqueueRetryable(() => r(s))
        };
        const i = s => {
            W("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = s, this.o && this.appCheck.addTokenListener(this.o)
        };
        this.A.onInit(s => i(s)), setTimeout(() => {
            if (!this.appCheck) {
                const s = this.A.getImmediate({
                    optional: !0
                });
                s ? i(s) : W("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
            }
        }, 0)
    }
    getToken() {
        const e = this.forceRefresh;
        return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(e).then(n => n ? (ae(typeof n.token == "string"), this.R = n.token, new mD(n.token)) : null) : Promise.resolve(null)
    }
    invalidateToken() {
        this.forceRefresh = !0
    }
    shutdown() {
        this.appCheck && this.o && this.appCheck.removeTokenListener(this.o), this.o = void 0
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function yD(t) {
    const e = typeof self < "u" && (self.crypto || self.msCrypto),
        n = new Uint8Array(t);
    if (e && typeof e.getRandomValues == "function") e.getRandomValues(n);
    else
        for (let r = 0; r < t; r++) n[r] = Math.floor(256 * Math.random());
    return n
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fS {
    static newId() {
        const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
            n = Math.floor(256 / e.length) * e.length;
        let r = "";
        for (; r.length < 20;) {
            const i = yD(40);
            for (let s = 0; s < i.length; ++s) r.length < 20 && i[s] < n && (r += e.charAt(i[s] % e.length))
        }
        return r
    }
}

function re(t, e) {
    return t < e ? -1 : t > e ? 1 : 0
}

function Os(t, e, n) {
    return t.length === e.length && t.every((r, i) => n(r, e[i]))
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fe {
    static now() {
        return Fe.fromMillis(Date.now())
    }
    static fromDate(e) {
        return Fe.fromMillis(e.getTime())
    }
    static fromMillis(e) {
        const n = Math.floor(e / 1e3),
            r = Math.floor(1e6 * (e - 1e3 * n));
        return new Fe(n, r)
    }
    constructor(e, n) {
        if (this.seconds = e, this.nanoseconds = n, n < 0) throw new z(L.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + n);
        if (n >= 1e9) throw new z(L.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + n);
        if (e < -62135596800) throw new z(L.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e);
        if (e >= 253402300800) throw new z(L.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e)
    }
    toDate() {
        return new Date(this.toMillis())
    }
    toMillis() {
        return 1e3 * this.seconds + this.nanoseconds / 1e6
    }
    _compareTo(e) {
        return this.seconds === e.seconds ? re(this.nanoseconds, e.nanoseconds) : re(this.seconds, e.seconds)
    }
    isEqual(e) {
        return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds
    }
    toString() {
        return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")"
    }
    toJSON() {
        return {
            seconds: this.seconds,
            nanoseconds: this.nanoseconds
        }
    }
    valueOf() {
        const e = this.seconds - -62135596800;
        return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0")
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class J {
    static fromTimestamp(e) {
        return new J(e)
    }
    static min() {
        return new J(new Fe(0, 0))
    }
    static max() {
        return new J(new Fe(253402300799, 999999999))
    }
    constructor(e) {
        this.timestamp = e
    }
    compareTo(e) {
        return this.timestamp._compareTo(e.timestamp)
    }
    isEqual(e) {
        return this.timestamp.isEqual(e.timestamp)
    }
    toMicroseconds() {
        return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3
    }
    toString() {
        return "SnapshotVersion(" + this.timestamp.toString() + ")"
    }
    toTimestamp() {
        return this.timestamp
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Aa {
    constructor(e, n, r) {
        n === void 0 ? n = 0 : n > e.length && Y(), r === void 0 ? r = e.length - n : r > e.length - n && Y(), this.segments = e, this.offset = n, this.len = r
    }
    get length() {
        return this.len
    }
    isEqual(e) {
        return Aa.comparator(this, e) === 0
    }
    child(e) {
        const n = this.segments.slice(this.offset, this.limit());
        return e instanceof Aa ? e.forEach(r => {
            n.push(r)
        }) : n.push(e), this.construct(n)
    }
    limit() {
        return this.offset + this.length
    }
    popFirst(e) {
        return e = e === void 0 ? 1 : e, this.construct(this.segments, this.offset + e, this.length - e)
    }
    popLast() {
        return this.construct(this.segments, this.offset, this.length - 1)
    }
    firstSegment() {
        return this.segments[this.offset]
    }
    lastSegment() {
        return this.get(this.length - 1)
    }
    get(e) {
        return this.segments[this.offset + e]
    }
    isEmpty() {
        return this.length === 0
    }
    isPrefixOf(e) {
        if (e.length < this.length) return !1;
        for (let n = 0; n < this.length; n++)
            if (this.get(n) !== e.get(n)) return !1;
        return !0
    }
    isImmediateParentOf(e) {
        if (this.length + 1 !== e.length) return !1;
        for (let n = 0; n < this.length; n++)
            if (this.get(n) !== e.get(n)) return !1;
        return !0
    }
    forEach(e) {
        for (let n = this.offset, r = this.limit(); n < r; n++) e(this.segments[n])
    }
    toArray() {
        return this.segments.slice(this.offset, this.limit())
    }
    static comparator(e, n) {
        const r = Math.min(e.length, n.length);
        for (let i = 0; i < r; i++) {
            const s = e.get(i),
                o = n.get(i);
            if (s < o) return -1;
            if (s > o) return 1
        }
        return e.length < n.length ? -1 : e.length > n.length ? 1 : 0
    }
}
class ye extends Aa {
    construct(e, n, r) {
        return new ye(e, n, r)
    }
    canonicalString() {
        return this.toArray().join("/")
    }
    toString() {
        return this.canonicalString()
    }
    toUriEncodedString() {
        return this.toArray().map(encodeURIComponent).join("/")
    }
    static fromString(...e) {
        const n = [];
        for (const r of e) {
            if (r.indexOf("//") >= 0) throw new z(L.INVALID_ARGUMENT, `Invalid segment (${r}). Paths must not contain // in them.`);
            n.push(...r.split("/").filter(i => i.length > 0))
        }
        return new ye(n)
    }
    static emptyPath() {
        return new ye([])
    }
}
const vD = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class Ge extends Aa {
    construct(e, n, r) {
        return new Ge(e, n, r)
    }
    static isValidIdentifier(e) {
        return vD.test(e)
    }
    canonicalString() {
        return this.toArray().map(e => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), Ge.isValidIdentifier(e) || (e = "`" + e + "`"), e)).join(".")
    }
    toString() {
        return this.canonicalString()
    }
    isKeyField() {
        return this.length === 1 && this.get(0) === "__name__"
    }
    static keyField() {
        return new Ge(["__name__"])
    }
    static fromServerFormat(e) {
        const n = [];
        let r = "",
            i = 0;
        const s = () => {
            if (r.length === 0) throw new z(L.INVALID_ARGUMENT, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
            n.push(r), r = ""
        };
        let o = !1;
        for (; i < e.length;) {
            const a = e[i];
            if (a === "\\") {
                if (i + 1 === e.length) throw new z(L.INVALID_ARGUMENT, "Path has trailing escape character: " + e);
                const u = e[i + 1];
                if (u !== "\\" && u !== "." && u !== "`") throw new z(L.INVALID_ARGUMENT, "Path has invalid escape sequence: " + e);
                r += u, i += 2
            } else a === "`" ? (o = !o, i++) : a !== "." || o ? (r += a, i++) : (s(), i++)
        }
        if (s(), o) throw new z(L.INVALID_ARGUMENT, "Unterminated ` in path: " + e);
        return new Ge(n)
    }
    static emptyPath() {
        return new Ge([])
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class H {
    constructor(e) {
        this.path = e
    }
    static fromPath(e) {
        return new H(ye.fromString(e))
    }
    static fromName(e) {
        return new H(ye.fromString(e).popFirst(5))
    }
    static empty() {
        return new H(ye.emptyPath())
    }
    get collectionGroup() {
        return this.path.popLast().lastSegment()
    }
    hasCollectionId(e) {
        return this.path.length >= 2 && this.path.get(this.path.length - 2) === e
    }
    getCollectionGroup() {
        return this.path.get(this.path.length - 2)
    }
    getCollectionPath() {
        return this.path.popLast()
    }
    isEqual(e) {
        return e !== null && ye.comparator(this.path, e.path) === 0
    }
    toString() {
        return this.path.toString()
    }
    static comparator(e, n) {
        return ye.comparator(e.path, n.path)
    }
    static isDocumentKey(e) {
        return e.length % 2 == 0
    }
    static fromSegments(e) {
        return new H(new ye(e.slice()))
    }
}

function _D(t, e) {
    const n = t.toTimestamp().seconds,
        r = t.toTimestamp().nanoseconds + 1,
        i = J.fromTimestamp(r === 1e9 ? new Fe(n + 1, 0) : new Fe(n, r));
    return new Ur(i, H.empty(), e)
}

function wD(t) {
    return new Ur(t.readTime, t.key, -1)
}
class Ur {
    constructor(e, n, r) {
        this.readTime = e, this.documentKey = n, this.largestBatchId = r
    }
    static min() {
        return new Ur(J.min(), H.empty(), -1)
    }
    static max() {
        return new Ur(J.max(), H.empty(), -1)
    }
}

function TD(t, e) {
    let n = t.readTime.compareTo(e.readTime);
    return n !== 0 ? n : (n = H.comparator(t.documentKey, e.documentKey), n !== 0 ? n : re(t.largestBatchId, e.largestBatchId))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ED = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
class ID {
    constructor() {
        this.onCommittedListeners = []
    }
    addOnCommittedListener(e) {
        this.onCommittedListeners.push(e)
    }
    raiseOnCommittedEvent() {
        this.onCommittedListeners.forEach(e => e())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Qs(t) {
    if (t.code !== L.FAILED_PRECONDITION || t.message !== ED) throw t;
    W("LocalStore", "Unexpectedly lost primary lease")
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class F {
    constructor(e) {
        this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, e(n => {
            this.isDone = !0, this.result = n, this.nextCallback && this.nextCallback(n)
        }, n => {
            this.isDone = !0, this.error = n, this.catchCallback && this.catchCallback(n)
        })
    } catch (e) {
        return this.next(void 0, e)
    }
    next(e, n) {
        return this.callbackAttached && Y(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(n, this.error) : this.wrapSuccess(e, this.result) : new F((r, i) => {
            this.nextCallback = s => {
                this.wrapSuccess(e, s).next(r, i)
            }, this.catchCallback = s => {
                this.wrapFailure(n, s).next(r, i)
            }
        })
    }
    toPromise() {
        return new Promise((e, n) => {
            this.next(e, n)
        })
    }
    wrapUserFunction(e) {
        try {
            const n = e();
            return n instanceof F ? n : F.resolve(n)
        } catch (n) {
            return F.reject(n)
        }
    }
    wrapSuccess(e, n) {
        return e ? this.wrapUserFunction(() => e(n)) : F.resolve(n)
    }
    wrapFailure(e, n) {
        return e ? this.wrapUserFunction(() => e(n)) : F.reject(n)
    }
    static resolve(e) {
        return new F((n, r) => {
            n(e)
        })
    }
    static reject(e) {
        return new F((n, r) => {
            r(e)
        })
    }
    static waitFor(e) {
        return new F((n, r) => {
            let i = 0,
                s = 0,
                o = !1;
            e.forEach(a => {
                ++i, a.next(() => {
                    ++s, o && s === i && n()
                }, u => r(u))
            }), o = !0, s === i && n()
        })
    }
    static or(e) {
        let n = F.resolve(!1);
        for (const r of e) n = n.next(i => i ? F.resolve(i) : r());
        return n
    }
    static forEach(e, n) {
        const r = [];
        return e.forEach((i, s) => {
            r.push(n.call(this, i, s))
        }), this.waitFor(r)
    }
    static mapArray(e, n) {
        return new F((r, i) => {
            const s = e.length,
                o = new Array(s);
            let a = 0;
            for (let u = 0; u < s; u++) {
                const c = u;
                n(e[c]).next(h => {
                    o[c] = h, ++a, a === s && r(o)
                }, h => i(h))
            }
        })
    }
    static doWhile(e, n) {
        return new F((r, i) => {
            const s = () => {
                e() === !0 ? n().next(() => {
                    s()
                }, i) : r()
            };
            s()
        })
    }
}

function SD(t) {
    const e = t.match(/Android ([\d.]+)/i),
        n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n)
}

function Ys(t) {
    return t.name === "IndexedDbTransactionError"
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Wc {
    constructor(e, n) {
        this.previousValue = e, n && (n.sequenceNumberHandler = r => this.ie(r), this.se = r => n.writeSequenceNumber(r))
    }
    ie(e) {
        return this.previousValue = Math.max(e, this.previousValue), this.previousValue
    }
    next() {
        const e = ++this.previousValue;
        return this.se && this.se(e), e
    }
}
Wc.oe = -1;

function qc(t) {
    return t == null
}

function Qu(t) {
    return t === 0 && 1 / t == -1 / 0
}

function AD(t) {
    return typeof t == "number" && Number.isInteger(t) && !Qu(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function PD(t) {
    let e = "";
    for (let n = 0; n < t.length; n++) e.length > 0 && (e = b_(e)), e = RD(t.get(n), e);
    return b_(e)
}

function RD(t, e) {
    let n = e;
    const r = t.length;
    for (let i = 0; i < r; i++) {
        const s = t.charAt(i);
        switch (s) {
            case "\0":
                n += "";
                break;
            case "":
                n += "";
                break;
            default:
                n += s
        }
    }
    return n
}

function b_(t) {
    return t + ""
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function N_(t) {
    let e = 0;
    for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && e++;
    return e
}

function Jr(t, e) {
    for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n])
}

function pS(t) {
    for (const e in t)
        if (Object.prototype.hasOwnProperty.call(t, e)) return !1;
    return !0
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ae {
    constructor(e, n) {
        this.comparator = e, this.root = n || Ke.EMPTY
    }
    insert(e, n) {
        return new Ae(this.comparator, this.root.insert(e, n, this.comparator).copy(null, null, Ke.BLACK, null, null))
    }
    remove(e) {
        return new Ae(this.comparator, this.root.remove(e, this.comparator).copy(null, null, Ke.BLACK, null, null))
    }
    get(e) {
        let n = this.root;
        for (; !n.isEmpty();) {
            const r = this.comparator(e, n.key);
            if (r === 0) return n.value;
            r < 0 ? n = n.left : r > 0 && (n = n.right)
        }
        return null
    }
    indexOf(e) {
        let n = 0,
            r = this.root;
        for (; !r.isEmpty();) {
            const i = this.comparator(e, r.key);
            if (i === 0) return n + r.left.size;
            i < 0 ? r = r.left : (n += r.left.size + 1, r = r.right)
        }
        return -1
    }
    isEmpty() {
        return this.root.isEmpty()
    }
    get size() {
        return this.root.size
    }
    minKey() {
        return this.root.minKey()
    }
    maxKey() {
        return this.root.maxKey()
    }
    inorderTraversal(e) {
        return this.root.inorderTraversal(e)
    }
    forEach(e) {
        this.inorderTraversal((n, r) => (e(n, r), !1))
    }
    toString() {
        const e = [];
        return this.inorderTraversal((n, r) => (e.push(`${n}:${r}`), !1)), `{${e.join(", ")}}`
    }
    reverseTraversal(e) {
        return this.root.reverseTraversal(e)
    }
    getIterator() {
        return new Ul(this.root, null, this.comparator, !1)
    }
    getIteratorFrom(e) {
        return new Ul(this.root, e, this.comparator, !1)
    }
    getReverseIterator() {
        return new Ul(this.root, null, this.comparator, !0)
    }
    getReverseIteratorFrom(e) {
        return new Ul(this.root, e, this.comparator, !0)
    }
}
class Ul {
    constructor(e, n, r, i) {
        this.isReverse = i, this.nodeStack = [];
        let s = 1;
        for (; !e.isEmpty();)
            if (s = n ? r(e.key, n) : 1, n && i && (s *= -1), s < 0) e = this.isReverse ? e.left : e.right;
            else {
                if (s === 0) {
                    this.nodeStack.push(e);
                    break
                }
                this.nodeStack.push(e), e = this.isReverse ? e.right : e.left
            }
    }
    getNext() {
        let e = this.nodeStack.pop();
        const n = {
            key: e.key,
            value: e.value
        };
        if (this.isReverse)
            for (e = e.left; !e.isEmpty();) this.nodeStack.push(e), e = e.right;
        else
            for (e = e.right; !e.isEmpty();) this.nodeStack.push(e), e = e.left;
        return n
    }
    hasNext() {
        return this.nodeStack.length > 0
    }
    peek() {
        if (this.nodeStack.length === 0) return null;
        const e = this.nodeStack[this.nodeStack.length - 1];
        return {
            key: e.key,
            value: e.value
        }
    }
}
class Ke {
    constructor(e, n, r, i, s) {
        this.key = e, this.value = n, this.color = r ? ? Ke.RED, this.left = i ? ? Ke.EMPTY, this.right = s ? ? Ke.EMPTY, this.size = this.left.size + 1 + this.right.size
    }
    copy(e, n, r, i, s) {
        return new Ke(e ? ? this.key, n ? ? this.value, r ? ? this.color, i ? ? this.left, s ? ? this.right)
    }
    isEmpty() {
        return !1
    }
    inorderTraversal(e) {
        return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e)
    }
    reverseTraversal(e) {
        return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e)
    }
    min() {
        return this.left.isEmpty() ? this : this.left.min()
    }
    minKey() {
        return this.min().key
    }
    maxKey() {
        return this.right.isEmpty() ? this.key : this.right.maxKey()
    }
    insert(e, n, r) {
        let i = this;
        const s = r(e, i.key);
        return i = s < 0 ? i.copy(null, null, null, i.left.insert(e, n, r), null) : s === 0 ? i.copy(null, n, null, null, null) : i.copy(null, null, null, null, i.right.insert(e, n, r)), i.fixUp()
    }
    removeMin() {
        if (this.left.isEmpty()) return Ke.EMPTY;
        let e = this;
        return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp()
    }
    remove(e, n) {
        let r, i = this;
        if (n(e, i.key) < 0) i.left.isEmpty() || i.left.isRed() || i.left.left.isRed() || (i = i.moveRedLeft()), i = i.copy(null, null, null, i.left.remove(e, n), null);
        else {
            if (i.left.isRed() && (i = i.rotateRight()), i.right.isEmpty() || i.right.isRed() || i.right.left.isRed() || (i = i.moveRedRight()), n(e, i.key) === 0) {
                if (i.right.isEmpty()) return Ke.EMPTY;
                r = i.right.min(), i = i.copy(r.key, r.value, null, null, i.right.removeMin())
            }
            i = i.copy(null, null, null, null, i.right.remove(e, n))
        }
        return i.fixUp()
    }
    isRed() {
        return this.color
    }
    fixUp() {
        let e = this;
        return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e
    }
    moveRedLeft() {
        let e = this.colorFlip();
        return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e
    }
    moveRedRight() {
        let e = this.colorFlip();
        return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e
    }
    rotateLeft() {
        const e = this.copy(null, null, Ke.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, e, null)
    }
    rotateRight() {
        const e = this.copy(null, null, Ke.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, e)
    }
    colorFlip() {
        const e = this.left.copy(null, null, !this.left.color, null, null),
            n = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, e, n)
    }
    checkMaxDepth() {
        const e = this.check();
        return Math.pow(2, e) <= this.size + 1
    }
    check() {
        if (this.isRed() && this.left.isRed() || this.right.isRed()) throw Y();
        const e = this.left.check();
        if (e !== this.right.check()) throw Y();
        return e + (this.isRed() ? 0 : 1)
    }
}
Ke.EMPTY = null, Ke.RED = !0, Ke.BLACK = !1;
Ke.EMPTY = new class {
    constructor() {
        this.size = 0
    }
    get key() {
        throw Y()
    }
    get value() {
        throw Y()
    }
    get color() {
        throw Y()
    }
    get left() {
        throw Y()
    }
    get right() {
        throw Y()
    }
    copy(e, n, r, i, s) {
        return this
    }
    insert(e, n, r) {
        return new Ke(e, n)
    }
    remove(e, n) {
        return this
    }
    isEmpty() {
        return !0
    }
    inorderTraversal(e) {
        return !1
    }
    reverseTraversal(e) {
        return !1
    }
    minKey() {
        return null
    }
    maxKey() {
        return null
    }
    isRed() {
        return !1
    }
    checkMaxDepth() {
        return !0
    }
    check() {
        return 0
    }
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ue {
    constructor(e) {
        this.comparator = e, this.data = new Ae(this.comparator)
    }
    has(e) {
        return this.data.get(e) !== null
    }
    first() {
        return this.data.minKey()
    }
    last() {
        return this.data.maxKey()
    }
    get size() {
        return this.data.size
    }
    indexOf(e) {
        return this.data.indexOf(e)
    }
    forEach(e) {
        this.data.inorderTraversal((n, r) => (e(n), !1))
    }
    forEachInRange(e, n) {
        const r = this.data.getIteratorFrom(e[0]);
        for (; r.hasNext();) {
            const i = r.getNext();
            if (this.comparator(i.key, e[1]) >= 0) return;
            n(i.key)
        }
    }
    forEachWhile(e, n) {
        let r;
        for (r = n !== void 0 ? this.data.getIteratorFrom(n) : this.data.getIterator(); r.hasNext();)
            if (!e(r.getNext().key)) return
    }
    firstAfterOrEqual(e) {
        const n = this.data.getIteratorFrom(e);
        return n.hasNext() ? n.getNext().key : null
    }
    getIterator() {
        return new D_(this.data.getIterator())
    }
    getIteratorFrom(e) {
        return new D_(this.data.getIteratorFrom(e))
    }
    add(e) {
        return this.copy(this.data.remove(e).insert(e, !0))
    }
    delete(e) {
        return this.has(e) ? this.copy(this.data.remove(e)) : this
    }
    isEmpty() {
        return this.data.isEmpty()
    }
    unionWith(e) {
        let n = this;
        return n.size < e.size && (n = e, e = this), e.forEach(r => {
            n = n.add(r)
        }), n
    }
    isEqual(e) {
        if (!(e instanceof Ue) || this.size !== e.size) return !1;
        const n = this.data.getIterator(),
            r = e.data.getIterator();
        for (; n.hasNext();) {
            const i = n.getNext().key,
                s = r.getNext().key;
            if (this.comparator(i, s) !== 0) return !1
        }
        return !0
    }
    toArray() {
        const e = [];
        return this.forEach(n => {
            e.push(n)
        }), e
    }
    toString() {
        const e = [];
        return this.forEach(n => e.push(n)), "SortedSet(" + e.toString() + ")"
    }
    copy(e) {
        const n = new Ue(this.comparator);
        return n.data = e, n
    }
}
class D_ {
    constructor(e) {
        this.iter = e
    }
    getNext() {
        return this.iter.getNext().key
    }
    hasNext() {
        return this.iter.hasNext()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Lt {
    constructor(e) {
        this.fields = e, e.sort(Ge.comparator)
    }
    static empty() {
        return new Lt([])
    }
    unionWith(e) {
        let n = new Ue(Ge.comparator);
        for (const r of this.fields) n = n.add(r);
        for (const r of e) n = n.add(r);
        return new Lt(n.toArray())
    }
    covers(e) {
        for (const n of this.fields)
            if (n.isPrefixOf(e)) return !0;
        return !1
    }
    isEqual(e) {
        return Os(this.fields, e.fields, (n, r) => n.isEqual(r))
    }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mS extends Error {
    constructor() {
        super(...arguments), this.name = "Base64DecodeError"
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xe {
    constructor(e) {
        this.binaryString = e
    }
    static fromBase64String(e) {
        const n = function(i) {
            try {
                return atob(i)
            } catch (s) {
                throw typeof DOMException < "u" && s instanceof DOMException ? new mS("Invalid base64 string: " + s) : s
            }
        }(e);
        return new Xe(n)
    }
    static fromUint8Array(e) {
        const n = function(i) {
            let s = "";
            for (let o = 0; o < i.length; ++o) s += String.fromCharCode(i[o]);
            return s
        }(e);
        return new Xe(n)
    }[Symbol.iterator]() {
        let e = 0;
        return {
            next: () => e < this.binaryString.length ? {
                value: this.binaryString.charCodeAt(e++),
                done: !1
            } : {
                value: void 0,
                done: !0
            }
        }
    }
    toBase64() {
        return function(n) {
            return btoa(n)
        }(this.binaryString)
    }
    toUint8Array() {
        return function(n) {
            const r = new Uint8Array(n.length);
            for (let i = 0; i < n.length; i++) r[i] = n.charCodeAt(i);
            return r
        }(this.binaryString)
    }
    approximateByteSize() {
        return 2 * this.binaryString.length
    }
    compareTo(e) {
        return re(this.binaryString, e.binaryString)
    }
    isEqual(e) {
        return this.binaryString === e.binaryString
    }
}
Xe.EMPTY_BYTE_STRING = new Xe("");
const CD = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);

function jr(t) {
    if (ae(!!t), typeof t == "string") {
        let e = 0;
        const n = CD.exec(t);
        if (ae(!!n), n[1]) {
            let i = n[1];
            i = (i + "000000000").substr(0, 9), e = Number(i)
        }
        const r = new Date(t);
        return {
            seconds: Math.floor(r.getTime() / 1e3),
            nanos: e
        }
    }
    return {
        seconds: xe(t.seconds),
        nanos: xe(t.nanos)
    }
}

function xe(t) {
    return typeof t == "number" ? t : typeof t == "string" ? Number(t) : 0
}

function Br(t) {
    return typeof t == "string" ? Xe.fromBase64String(t) : Xe.fromUint8Array(t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function xm(t) {
    var e, n;
    return ((n = (((e = t == null ? void 0 : t.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp"
}

function Hc(t) {
    const e = t.mapValue.fields.__previous_value__;
    return xm(e) ? Hc(e) : e
}

function Pa(t) {
    const e = jr(t.mapValue.fields.__local_write_time__.timestampValue);
    return new Fe(e.seconds, e.nanos)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kD {
    constructor(e, n, r, i, s, o, a, u, c) {
        this.databaseId = e, this.appId = n, this.persistenceKey = r, this.host = i, this.ssl = s, this.forceLongPolling = o, this.autoDetectLongPolling = a, this.longPollingOptions = u, this.useFetchStreams = c
    }
}
class Ra {
    constructor(e, n) {
        this.projectId = e, this.database = n || "(default)"
    }
    static empty() {
        return new Ra("", "")
    }
    get isDefaultDatabase() {
        return this.database === "(default)"
    }
    isEqual(e) {
        return e instanceof Ra && e.projectId === this.projectId && e.database === this.database
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const jl = {
    mapValue: {
        fields: {
            __type__: {
                stringValue: "__max__"
            }
        }
    }
};

function $r(t) {
    return "nullValue" in t ? 0 : "booleanValue" in t ? 1 : "integerValue" in t || "doubleValue" in t ? 2 : "timestampValue" in t ? 3 : "stringValue" in t ? 5 : "bytesValue" in t ? 6 : "referenceValue" in t ? 7 : "geoPointValue" in t ? 8 : "arrayValue" in t ? 9 : "mapValue" in t ? xm(t) ? 4 : bD(t) ? 9007199254740991 : xD(t) ? 10 : 11 : Y()
}

function Pn(t, e) {
    if (t === e) return !0;
    const n = $r(t);
    if (n !== $r(e)) return !1;
    switch (n) {
        case 0:
        case 9007199254740991:
            return !0;
        case 1:
            return t.booleanValue === e.booleanValue;
        case 4:
            return Pa(t).isEqual(Pa(e));
        case 3:
            return function(i, s) {
                if (typeof i.timestampValue == "string" && typeof s.timestampValue == "string" && i.timestampValue.length === s.timestampValue.length) return i.timestampValue === s.timestampValue;
                const o = jr(i.timestampValue),
                    a = jr(s.timestampValue);
                return o.seconds === a.seconds && o.nanos === a.nanos
            }(t, e);
        case 5:
            return t.stringValue === e.stringValue;
        case 6:
            return function(i, s) {
                return Br(i.bytesValue).isEqual(Br(s.bytesValue))
            }(t, e);
        case 7:
            return t.referenceValue === e.referenceValue;
        case 8:
            return function(i, s) {
                return xe(i.geoPointValue.latitude) === xe(s.geoPointValue.latitude) && xe(i.geoPointValue.longitude) === xe(s.geoPointValue.longitude)
            }(t, e);
        case 2:
            return function(i, s) {
                if ("integerValue" in i && "integerValue" in s) return xe(i.integerValue) === xe(s.integerValue);
                if ("doubleValue" in i && "doubleValue" in s) {
                    const o = xe(i.doubleValue),
                        a = xe(s.doubleValue);
                    return o === a ? Qu(o) === Qu(a) : isNaN(o) && isNaN(a)
                }
                return !1
            }(t, e);
        case 9:
            return Os(t.arrayValue.values || [], e.arrayValue.values || [], Pn);
        case 10:
        case 11:
            return function(i, s) {
                const o = i.mapValue.fields || {},
                    a = s.mapValue.fields || {};
                if (N_(o) !== N_(a)) return !1;
                for (const u in o)
                    if (o.hasOwnProperty(u) && (a[u] === void 0 || !Pn(o[u], a[u]))) return !1;
                return !0
            }(t, e);
        default:
            return Y()
    }
}

function Ca(t, e) {
    return (t.values || []).find(n => Pn(n, e)) !== void 0
}

function Ls(t, e) {
    if (t === e) return 0;
    const n = $r(t),
        r = $r(e);
    if (n !== r) return re(n, r);
    switch (n) {
        case 0:
        case 9007199254740991:
            return 0;
        case 1:
            return re(t.booleanValue, e.booleanValue);
        case 2:
            return function(s, o) {
                const a = xe(s.integerValue || s.doubleValue),
                    u = xe(o.integerValue || o.doubleValue);
                return a < u ? -1 : a > u ? 1 : a === u ? 0 : isNaN(a) ? isNaN(u) ? 0 : -1 : 1
            }(t, e);
        case 3:
            return V_(t.timestampValue, e.timestampValue);
        case 4:
            return V_(Pa(t), Pa(e));
        case 5:
            return re(t.stringValue, e.stringValue);
        case 6:
            return function(s, o) {
                const a = Br(s),
                    u = Br(o);
                return a.compareTo(u)
            }(t.bytesValue, e.bytesValue);
        case 7:
            return function(s, o) {
                const a = s.split("/"),
                    u = o.split("/");
                for (let c = 0; c < a.length && c < u.length; c++) {
                    const h = re(a[c], u[c]);
                    if (h !== 0) return h
                }
                return re(a.length, u.length)
            }(t.referenceValue, e.referenceValue);
        case 8:
            return function(s, o) {
                const a = re(xe(s.latitude), xe(o.latitude));
                return a !== 0 ? a : re(xe(s.longitude), xe(o.longitude))
            }(t.geoPointValue, e.geoPointValue);
        case 9:
            return O_(t.arrayValue, e.arrayValue);
        case 10:
            return function(s, o) {
                var a, u, c, h;
                const f = s.fields || {},
                    m = o.fields || {},
                    _ = (a = f.value) === null || a === void 0 ? void 0 : a.arrayValue,
                    I = (u = m.value) === null || u === void 0 ? void 0 : u.arrayValue,
                    R = re(((c = _ == null ? void 0 : _.values) === null || c === void 0 ? void 0 : c.length) || 0, ((h = I == null ? void 0 : I.values) === null || h === void 0 ? void 0 : h.length) || 0);
                return R !== 0 ? R : O_(_, I)
            }(t.mapValue, e.mapValue);
        case 11:
            return function(s, o) {
                if (s === jl.mapValue && o === jl.mapValue) return 0;
                if (s === jl.mapValue) return 1;
                if (o === jl.mapValue) return -1;
                const a = s.fields || {},
                    u = Object.keys(a),
                    c = o.fields || {},
                    h = Object.keys(c);
                u.sort(), h.sort();
                for (let f = 0; f < u.length && f < h.length; ++f) {
                    const m = re(u[f], h[f]);
                    if (m !== 0) return m;
                    const _ = Ls(a[u[f]], c[h[f]]);
                    if (_ !== 0) return _
                }
                return re(u.length, h.length)
            }(t.mapValue, e.mapValue);
        default:
            throw Y()
    }
}

function V_(t, e) {
    if (typeof t == "string" && typeof e == "string" && t.length === e.length) return re(t, e);
    const n = jr(t),
        r = jr(e),
        i = re(n.seconds, r.seconds);
    return i !== 0 ? i : re(n.nanos, r.nanos)
}

function O_(t, e) {
    const n = t.values || [],
        r = e.values || [];
    for (let i = 0; i < n.length && i < r.length; ++i) {
        const s = Ls(n[i], r[i]);
        if (s) return s
    }
    return re(n.length, r.length)
}

function Ms(t) {
    return Wf(t)
}

function Wf(t) {
    return "nullValue" in t ? "null" : "booleanValue" in t ? "" + t.booleanValue : "integerValue" in t ? "" + t.integerValue : "doubleValue" in t ? "" + t.doubleValue : "timestampValue" in t ? function(n) {
        const r = jr(n);
        return `time(${r.seconds},${r.nanos})`
    }(t.timestampValue) : "stringValue" in t ? t.stringValue : "bytesValue" in t ? function(n) {
        return Br(n).toBase64()
    }(t.bytesValue) : "referenceValue" in t ? function(n) {
        return H.fromName(n).toString()
    }(t.referenceValue) : "geoPointValue" in t ? function(n) {
        return `geo(${n.latitude},${n.longitude})`
    }(t.geoPointValue) : "arrayValue" in t ? function(n) {
        let r = "[",
            i = !0;
        for (const s of n.values || []) i ? i = !1 : r += ",", r += Wf(s);
        return r + "]"
    }(t.arrayValue) : "mapValue" in t ? function(n) {
        const r = Object.keys(n.fields || {}).sort();
        let i = "{",
            s = !0;
        for (const o of r) s ? s = !1 : i += ",", i += `${o}:${Wf(n.fields[o])}`;
        return i + "}"
    }(t.mapValue) : Y()
}

function lu(t) {
    switch ($r(t)) {
        case 0:
        case 1:
            return 4;
        case 2:
            return 8;
        case 3:
        case 8:
            return 16;
        case 4:
            const e = Hc(t);
            return e ? 16 + lu(e) : 16;
        case 5:
            return 2 * t.stringValue.length;
        case 6:
            return Br(t.bytesValue).approximateByteSize();
        case 7:
            return t.referenceValue.length;
        case 9:
            return function(r) {
                return (r.values || []).reduce((i, s) => i + lu(s), 0)
            }(t.arrayValue);
        case 10:
        case 11:
            return function(r) {
                let i = 0;
                return Jr(r.fields, (s, o) => {
                    i += s.length + lu(o)
                }), i
            }(t.mapValue);
        default:
            throw Y()
    }
}

function L_(t, e) {
    return {
        referenceValue: `projects/${t.projectId}/databases/${t.database}/documents/${e.path.canonicalString()}`
    }
}

function qf(t) {
    return !!t && "integerValue" in t
}

function bm(t) {
    return !!t && "arrayValue" in t
}

function M_(t) {
    return !!t && "nullValue" in t
}

function F_(t) {
    return !!t && "doubleValue" in t && isNaN(Number(t.doubleValue))
}

function uu(t) {
    return !!t && "mapValue" in t
}

function xD(t) {
    var e, n;
    return ((n = (((e = t == null ? void 0 : t.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "__vector__"
}

function Yo(t) {
    if (t.geoPointValue) return {
        geoPointValue: Object.assign({}, t.geoPointValue)
    };
    if (t.timestampValue && typeof t.timestampValue == "object") return {
        timestampValue: Object.assign({}, t.timestampValue)
    };
    if (t.mapValue) {
        const e = {
            mapValue: {
                fields: {}
            }
        };
        return Jr(t.mapValue.fields, (n, r) => e.mapValue.fields[n] = Yo(r)), e
    }
    if (t.arrayValue) {
        const e = {
            arrayValue: {
                values: []
            }
        };
        for (let n = 0; n < (t.arrayValue.values || []).length; ++n) e.arrayValue.values[n] = Yo(t.arrayValue.values[n]);
        return e
    }
    return Object.assign({}, t)
}

function bD(t) {
    return (((t.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class At {
    constructor(e) {
        this.value = e
    }
    static empty() {
        return new At({
            mapValue: {}
        })
    }
    field(e) {
        if (e.isEmpty()) return this.value; {
            let n = this.value;
            for (let r = 0; r < e.length - 1; ++r)
                if (n = (n.mapValue.fields || {})[e.get(r)], !uu(n)) return null;
            return n = (n.mapValue.fields || {})[e.lastSegment()], n || null
        }
    }
    set(e, n) {
        this.getFieldsMap(e.popLast())[e.lastSegment()] = Yo(n)
    }
    setAll(e) {
        let n = Ge.emptyPath(),
            r = {},
            i = [];
        e.forEach((o, a) => {
            if (!n.isImmediateParentOf(a)) {
                const u = this.getFieldsMap(n);
                this.applyChanges(u, r, i), r = {}, i = [], n = a.popLast()
            }
            o ? r[a.lastSegment()] = Yo(o) : i.push(a.lastSegment())
        });
        const s = this.getFieldsMap(n);
        this.applyChanges(s, r, i)
    }
    delete(e) {
        const n = this.field(e.popLast());
        uu(n) && n.mapValue.fields && delete n.mapValue.fields[e.lastSegment()]
    }
    isEqual(e) {
        return Pn(this.value, e.value)
    }
    getFieldsMap(e) {
        let n = this.value;
        n.mapValue.fields || (n.mapValue = {
            fields: {}
        });
        for (let r = 0; r < e.length; ++r) {
            let i = n.mapValue.fields[e.get(r)];
            uu(i) && i.mapValue.fields || (i = {
                mapValue: {
                    fields: {}
                }
            }, n.mapValue.fields[e.get(r)] = i), n = i
        }
        return n.mapValue.fields
    }
    applyChanges(e, n, r) {
        Jr(n, (i, s) => e[i] = s);
        for (const i of r) delete e[i]
    }
    clone() {
        return new At(Yo(this.value))
    }
}

function gS(t) {
    const e = [];
    return Jr(t.fields, (n, r) => {
        const i = new Ge([n]);
        if (uu(r)) {
            const s = gS(r.mapValue).fields;
            if (s.length === 0) e.push(i);
            else
                for (const o of s) e.push(i.child(o))
        } else e.push(i)
    }), new Lt(e)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lt {
    constructor(e, n, r, i, s, o, a) {
        this.key = e, this.documentType = n, this.version = r, this.readTime = i, this.createTime = s, this.data = o, this.documentState = a
    }
    static newInvalidDocument(e) {
        return new lt(e, 0, J.min(), J.min(), J.min(), At.empty(), 0)
    }
    static newFoundDocument(e, n, r, i) {
        return new lt(e, 1, n, J.min(), r, i, 0)
    }
    static newNoDocument(e, n) {
        return new lt(e, 2, n, J.min(), J.min(), At.empty(), 0)
    }
    static newUnknownDocument(e, n) {
        return new lt(e, 3, n, J.min(), J.min(), At.empty(), 2)
    }
    convertToFoundDocument(e, n) {
        return !this.createTime.isEqual(J.min()) || this.documentType !== 2 && this.documentType !== 0 || (this.createTime = e), this.version = e, this.documentType = 1, this.data = n, this.documentState = 0, this
    }
    convertToNoDocument(e) {
        return this.version = e, this.documentType = 2, this.data = At.empty(), this.documentState = 0, this
    }
    convertToUnknownDocument(e) {
        return this.version = e, this.documentType = 3, this.data = At.empty(), this.documentState = 2, this
    }
    setHasCommittedMutations() {
        return this.documentState = 2, this
    }
    setHasLocalMutations() {
        return this.documentState = 1, this.version = J.min(), this
    }
    setReadTime(e) {
        return this.readTime = e, this
    }
    get hasLocalMutations() {
        return this.documentState === 1
    }
    get hasCommittedMutations() {
        return this.documentState === 2
    }
    get hasPendingWrites() {
        return this.hasLocalMutations || this.hasCommittedMutations
    }
    isValidDocument() {
        return this.documentType !== 0
    }
    isFoundDocument() {
        return this.documentType === 1
    }
    isNoDocument() {
        return this.documentType === 2
    }
    isUnknownDocument() {
        return this.documentType === 3
    }
    isEqual(e) {
        return e instanceof lt && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data)
    }
    mutableCopy() {
        return new lt(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState)
    }
    toString() {
        return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`
    }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Yu {
    constructor(e, n) {
        this.position = e, this.inclusive = n
    }
}

function U_(t, e, n) {
    let r = 0;
    for (let i = 0; i < t.position.length; i++) {
        const s = e[i],
            o = t.position[i];
        if (s.field.isKeyField() ? r = H.comparator(H.fromName(o.referenceValue), n.key) : r = Ls(o, n.data.field(s.field)), s.dir === "desc" && (r *= -1), r !== 0) break
    }
    return r
}

function j_(t, e) {
    if (t === null) return e === null;
    if (e === null || t.inclusive !== e.inclusive || t.position.length !== e.position.length) return !1;
    for (let n = 0; n < t.position.length; n++)
        if (!Pn(t.position[n], e.position[n])) return !1;
    return !0
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ka {
    constructor(e, n = "asc") {
        this.field = e, this.dir = n
    }
}

function ND(t, e) {
    return t.dir === e.dir && t.field.isEqual(e.field)
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yS {}
class Ve extends yS {
    constructor(e, n, r) {
        super(), this.field = e, this.op = n, this.value = r
    }
    static create(e, n, r) {
        return e.isKeyField() ? n === "in" || n === "not-in" ? this.createKeyFieldInFilter(e, n, r) : new VD(e, n, r) : n === "array-contains" ? new MD(e, r) : n === "in" ? new FD(e, r) : n === "not-in" ? new UD(e, r) : n === "array-contains-any" ? new jD(e, r) : new Ve(e, n, r)
    }
    static createKeyFieldInFilter(e, n, r) {
        return n === "in" ? new OD(e, r) : new LD(e, r)
    }
    matches(e) {
        const n = e.data.field(this.field);
        return this.op === "!=" ? n !== null && this.matchesComparison(Ls(n, this.value)) : n !== null && $r(this.value) === $r(n) && this.matchesComparison(Ls(n, this.value))
    }
    matchesComparison(e) {
        switch (this.op) {
            case "<":
                return e < 0;
            case "<=":
                return e <= 0;
            case "==":
                return e === 0;
            case "!=":
                return e !== 0;
            case ">":
                return e > 0;
            case ">=":
                return e >= 0;
            default:
                return Y()
        }
    }
    isInequality() {
        return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0
    }
    getFlattenedFilters() {
        return [this]
    }
    getFilters() {
        return [this]
    }
}
class hn extends yS {
    constructor(e, n) {
        super(), this.filters = e, this.op = n, this.ae = null
    }
    static create(e, n) {
        return new hn(e, n)
    }
    matches(e) {
        return vS(this) ? this.filters.find(n => !n.matches(e)) === void 0 : this.filters.find(n => n.matches(e)) !== void 0
    }
    getFlattenedFilters() {
        return this.ae !== null || (this.ae = this.filters.reduce((e, n) => e.concat(n.getFlattenedFilters()), [])), this.ae
    }
    getFilters() {
        return Object.assign([], this.filters)
    }
}

function vS(t) {
    return t.op === "and"
}

function _S(t) {
    return DD(t) && vS(t)
}

function DD(t) {
    for (const e of t.filters)
        if (e instanceof hn) return !1;
    return !0
}

function Hf(t) {
    if (t instanceof Ve) return t.field.canonicalString() + t.op.toString() + Ms(t.value);
    if (_S(t)) return t.filters.map(e => Hf(e)).join(","); {
        const e = t.filters.map(n => Hf(n)).join(",");
        return `${t.op}(${e})`
    }
}

function wS(t, e) {
    return t instanceof Ve ? function(r, i) {
        return i instanceof Ve && r.op === i.op && r.field.isEqual(i.field) && Pn(r.value, i.value)
    }(t, e) : t instanceof hn ? function(r, i) {
        return i instanceof hn && r.op === i.op && r.filters.length === i.filters.length ? r.filters.reduce((s, o, a) => s && wS(o, i.filters[a]), !0) : !1
    }(t, e) : void Y()
}

function TS(t) {
    return t instanceof Ve ? function(n) {
        return `${n.field.canonicalString()} ${n.op} ${Ms(n.value)}`
    }(t) : t instanceof hn ? function(n) {
        return n.op.toString() + " {" + n.getFilters().map(TS).join(" ,") + "}"
    }(t) : "Filter"
}
class VD extends Ve {
    constructor(e, n, r) {
        super(e, n, r), this.key = H.fromName(r.referenceValue)
    }
    matches(e) {
        const n = H.comparator(e.key, this.key);
        return this.matchesComparison(n)
    }
}
class OD extends Ve {
    constructor(e, n) {
        super(e, "in", n), this.keys = ES("in", n)
    }
    matches(e) {
        return this.keys.some(n => n.isEqual(e.key))
    }
}
class LD extends Ve {
    constructor(e, n) {
        super(e, "not-in", n), this.keys = ES("not-in", n)
    }
    matches(e) {
        return !this.keys.some(n => n.isEqual(e.key))
    }
}

function ES(t, e) {
    var n;
    return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map(r => H.fromName(r.referenceValue))
}
class MD extends Ve {
    constructor(e, n) {
        super(e, "array-contains", n)
    }
    matches(e) {
        const n = e.data.field(this.field);
        return bm(n) && Ca(n.arrayValue, this.value)
    }
}
class FD extends Ve {
    constructor(e, n) {
        super(e, "in", n)
    }
    matches(e) {
        const n = e.data.field(this.field);
        return n !== null && Ca(this.value.arrayValue, n)
    }
}
class UD extends Ve {
    constructor(e, n) {
        super(e, "not-in", n)
    }
    matches(e) {
        if (Ca(this.value.arrayValue, {
                nullValue: "NULL_VALUE"
            })) return !1;
        const n = e.data.field(this.field);
        return n !== null && !Ca(this.value.arrayValue, n)
    }
}
class jD extends Ve {
    constructor(e, n) {
        super(e, "array-contains-any", n)
    }
    matches(e) {
        const n = e.data.field(this.field);
        return !(!bm(n) || !n.arrayValue.values) && n.arrayValue.values.some(r => Ca(this.value.arrayValue, r))
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BD {
    constructor(e, n = null, r = [], i = [], s = null, o = null, a = null) {
        this.path = e, this.collectionGroup = n, this.orderBy = r, this.filters = i, this.limit = s, this.startAt = o, this.endAt = a, this.ue = null
    }
}

function B_(t, e = null, n = [], r = [], i = null, s = null, o = null) {
    return new BD(t, e, n, r, i, s, o)
}

function Nm(t) {
    const e = Z(t);
    if (e.ue === null) {
        let n = e.path.canonicalString();
        e.collectionGroup !== null && (n += "|cg:" + e.collectionGroup), n += "|f:", n += e.filters.map(r => Hf(r)).join(","), n += "|ob:", n += e.orderBy.map(r => function(s) {
            return s.field.canonicalString() + s.dir
        }(r)).join(","), qc(e.limit) || (n += "|l:", n += e.limit), e.startAt && (n += "|lb:", n += e.startAt.inclusive ? "b:" : "a:", n += e.startAt.position.map(r => Ms(r)).join(",")), e.endAt && (n += "|ub:", n += e.endAt.inclusive ? "a:" : "b:", n += e.endAt.position.map(r => Ms(r)).join(",")), e.ue = n
    }
    return e.ue
}

function Dm(t, e) {
    if (t.limit !== e.limit || t.orderBy.length !== e.orderBy.length) return !1;
    for (let n = 0; n < t.orderBy.length; n++)
        if (!ND(t.orderBy[n], e.orderBy[n])) return !1;
    if (t.filters.length !== e.filters.length) return !1;
    for (let n = 0; n < t.filters.length; n++)
        if (!wS(t.filters[n], e.filters[n])) return !1;
    return t.collectionGroup === e.collectionGroup && !!t.path.isEqual(e.path) && !!j_(t.startAt, e.startAt) && j_(t.endAt, e.endAt)
}

function Kf(t) {
    return H.isDocumentKey(t.path) && t.collectionGroup === null && t.filters.length === 0
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xs {
    constructor(e, n = null, r = [], i = [], s = null, o = "F", a = null, u = null) {
        this.path = e, this.collectionGroup = n, this.explicitOrderBy = r, this.filters = i, this.limit = s, this.limitType = o, this.startAt = a, this.endAt = u, this.ce = null, this.le = null, this.he = null, this.startAt, this.endAt
    }
}

function $D(t, e, n, r, i, s, o, a) {
    return new Xs(t, e, n, r, i, s, o, a)
}

function Vm(t) {
    return new Xs(t)
}

function $_(t) {
    return t.filters.length === 0 && t.limit === null && t.startAt == null && t.endAt == null && (t.explicitOrderBy.length === 0 || t.explicitOrderBy.length === 1 && t.explicitOrderBy[0].field.isKeyField())
}

function IS(t) {
    return t.collectionGroup !== null
}

function Xo(t) {
    const e = Z(t);
    if (e.ce === null) {
        e.ce = [];
        const n = new Set;
        for (const s of e.explicitOrderBy) e.ce.push(s), n.add(s.field.canonicalString());
        const r = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        (function(o) {
            let a = new Ue(Ge.comparator);
            return o.filters.forEach(u => {
                u.getFlattenedFilters().forEach(c => {
                    c.isInequality() && (a = a.add(c.field))
                })
            }), a
        })(e).forEach(s => {
            n.has(s.canonicalString()) || s.isKeyField() || e.ce.push(new ka(s, r))
        }), n.has(Ge.keyField().canonicalString()) || e.ce.push(new ka(Ge.keyField(), r))
    }
    return e.ce
}

function wn(t) {
    const e = Z(t);
    return e.le || (e.le = zD(e, Xo(t))), e.le
}

function zD(t, e) {
    if (t.limitType === "F") return B_(t.path, t.collectionGroup, e, t.filters, t.limit, t.startAt, t.endAt); {
        e = e.map(i => {
            const s = i.dir === "desc" ? "asc" : "desc";
            return new ka(i.field, s)
        });
        const n = t.endAt ? new Yu(t.endAt.position, t.endAt.inclusive) : null,
            r = t.startAt ? new Yu(t.startAt.position, t.startAt.inclusive) : null;
        return B_(t.path, t.collectionGroup, e, t.filters, t.limit, n, r)
    }
}

function Gf(t, e) {
    const n = t.filters.concat([e]);
    return new Xs(t.path, t.collectionGroup, t.explicitOrderBy.slice(), n, t.limit, t.limitType, t.startAt, t.endAt)
}

function Xu(t, e, n) {
    return new Xs(t.path, t.collectionGroup, t.explicitOrderBy.slice(), t.filters.slice(), e, n, t.startAt, t.endAt)
}

function Kc(t, e) {
    return Dm(wn(t), wn(e)) && t.limitType === e.limitType
}

function SS(t) {
    return `${Nm(wn(t))}|lt:${t.limitType}`
}

function Yi(t) {
    return `Query(target=${function(n){let r=n.path.canonicalString();return n.collectionGroup!==null&&(r+=" collectionGroup="+n.collectionGroup),n.filters.length>0&&(r+=`, filters: [${n.filters.map(i=>TS(i)).join(", ")}]`),qc(n.limit)||(r+=", limit: "+n.limit),n.orderBy.length>0&&(r+=`, orderBy: [${n.orderBy.map(i=>function(o){return`${o.field.canonicalString()} (${o.dir})`}(i)).join(", ")}]`),n.startAt&&(r+=", startAt: ",r+=n.startAt.inclusive?"b:":"a:",r+=n.startAt.position.map(i=>Ms(i)).join(",")),n.endAt&&(r+=", endAt: ",r+=n.endAt.inclusive?"a:":"b:",r+=n.endAt.position.map(i=>Ms(i)).join(",")),`Target(${r})`}(wn(t))}; limitType=${t.limitType})`
}

function Gc(t, e) {
    return e.isFoundDocument() && function(r, i) {
        const s = i.key.path;
        return r.collectionGroup !== null ? i.key.hasCollectionId(r.collectionGroup) && r.path.isPrefixOf(s) : H.isDocumentKey(r.path) ? r.path.isEqual(s) : r.path.isImmediateParentOf(s)
    }(t, e) && function(r, i) {
        for (const s of Xo(r))
            if (!s.field.isKeyField() && i.data.field(s.field) === null) return !1;
        return !0
    }(t, e) && function(r, i) {
        for (const s of r.filters)
            if (!s.matches(i)) return !1;
        return !0
    }(t, e) && function(r, i) {
        return !(r.startAt && ! function(o, a, u) {
            const c = U_(o, a, u);
            return o.inclusive ? c <= 0 : c < 0
        }(r.startAt, Xo(r), i) || r.endAt && ! function(o, a, u) {
            const c = U_(o, a, u);
            return o.inclusive ? c >= 0 : c > 0
        }(r.endAt, Xo(r), i))
    }(t, e)
}

function WD(t) {
    return t.collectionGroup || (t.path.length % 2 == 1 ? t.path.lastSegment() : t.path.get(t.path.length - 2))
}

function AS(t) {
    return (e, n) => {
        let r = !1;
        for (const i of Xo(t)) {
            const s = qD(i, e, n);
            if (s !== 0) return s;
            r = r || i.field.isKeyField()
        }
        return 0
    }
}

function qD(t, e, n) {
    const r = t.field.isKeyField() ? H.comparator(e.key, n.key) : function(s, o, a) {
        const u = o.data.field(s),
            c = a.data.field(s);
        return u !== null && c !== null ? Ls(u, c) : Y()
    }(t.field, e, n);
    switch (t.dir) {
        case "asc":
            return r;
        case "desc":
            return -1 * r;
        default:
            return Y()
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Mi {
    constructor(e, n) {
        this.mapKeyFn = e, this.equalsFn = n, this.inner = {}, this.innerSize = 0
    }
    get(e) {
        const n = this.mapKeyFn(e),
            r = this.inner[n];
        if (r !== void 0) {
            for (const [i, s] of r)
                if (this.equalsFn(i, e)) return s
        }
    }
    has(e) {
        return this.get(e) !== void 0
    }
    set(e, n) {
        const r = this.mapKeyFn(e),
            i = this.inner[r];
        if (i === void 0) return this.inner[r] = [
            [e, n]
        ], void this.innerSize++;
        for (let s = 0; s < i.length; s++)
            if (this.equalsFn(i[s][0], e)) return void(i[s] = [e, n]);
        i.push([e, n]), this.innerSize++
    }
    delete(e) {
        const n = this.mapKeyFn(e),
            r = this.inner[n];
        if (r === void 0) return !1;
        for (let i = 0; i < r.length; i++)
            if (this.equalsFn(r[i][0], e)) return r.length === 1 ? delete this.inner[n] : r.splice(i, 1), this.innerSize--, !0;
        return !1
    }
    forEach(e) {
        Jr(this.inner, (n, r) => {
            for (const [i, s] of r) e(i, s)
        })
    }
    isEmpty() {
        return pS(this.inner)
    }
    size() {
        return this.innerSize
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const HD = new Ae(H.comparator);

function er() {
    return HD
}
const PS = new Ae(H.comparator);

function Vo(...t) {
    let e = PS;
    for (const n of t) e = e.insert(n.key, n);
    return e
}

function RS(t) {
    let e = PS;
    return t.forEach((n, r) => e = e.insert(n, r.overlayedDocument)), e
}

function vi() {
    return Jo()
}

function CS() {
    return Jo()
}

function Jo() {
    return new Mi(t => t.toString(), (t, e) => t.isEqual(e))
}
const KD = new Ae(H.comparator),
    GD = new Ue(H.comparator);

function ne(...t) {
    let e = GD;
    for (const n of t) e = e.add(n);
    return e
}
const QD = new Ue(re);

function YD() {
    return QD
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Om(t, e) {
    if (t.useProto3Json) {
        if (isNaN(e)) return {
            doubleValue: "NaN"
        };
        if (e === 1 / 0) return {
            doubleValue: "Infinity"
        };
        if (e === -1 / 0) return {
            doubleValue: "-Infinity"
        }
    }
    return {
        doubleValue: Qu(e) ? "-0" : e
    }
}

function kS(t) {
    return {
        integerValue: "" + t
    }
}

function XD(t, e) {
    return AD(e) ? kS(e) : Om(t, e)
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qc {
    constructor() {
        this._ = void 0
    }
}

function JD(t, e, n) {
    return t instanceof Ju ? function(i, s) {
        const o = {
            fields: {
                __type__: {
                    stringValue: "server_timestamp"
                },
                __local_write_time__: {
                    timestampValue: {
                        seconds: i.seconds,
                        nanos: i.nanoseconds
                    }
                }
            }
        };
        return s && xm(s) && (s = Hc(s)), s && (o.fields.__previous_value__ = s), {
            mapValue: o
        }
    }(n, e) : t instanceof xa ? bS(t, e) : t instanceof ba ? NS(t, e) : function(i, s) {
        const o = xS(i, s),
            a = z_(o) + z_(i.Pe);
        return qf(o) && qf(i.Pe) ? kS(a) : Om(i.serializer, a)
    }(t, e)
}

function ZD(t, e, n) {
    return t instanceof xa ? bS(t, e) : t instanceof ba ? NS(t, e) : n
}

function xS(t, e) {
    return t instanceof Zu ? function(r) {
        return qf(r) || function(s) {
            return !!s && "doubleValue" in s
        }(r)
    }(e) ? e : {
        integerValue: 0
    } : null
}
class Ju extends Qc {}
class xa extends Qc {
    constructor(e) {
        super(), this.elements = e
    }
}

function bS(t, e) {
    const n = DS(e);
    for (const r of t.elements) n.some(i => Pn(i, r)) || n.push(r);
    return {
        arrayValue: {
            values: n
        }
    }
}
class ba extends Qc {
    constructor(e) {
        super(), this.elements = e
    }
}

function NS(t, e) {
    let n = DS(e);
    for (const r of t.elements) n = n.filter(i => !Pn(i, r));
    return {
        arrayValue: {
            values: n
        }
    }
}
class Zu extends Qc {
    constructor(e, n) {
        super(), this.serializer = e, this.Pe = n
    }
}

function z_(t) {
    return xe(t.integerValue || t.doubleValue)
}

function DS(t) {
    return bm(t) && t.arrayValue.values ? t.arrayValue.values.slice() : []
}

function eV(t, e) {
    return t.field.isEqual(e.field) && function(r, i) {
        return r instanceof xa && i instanceof xa || r instanceof ba && i instanceof ba ? Os(r.elements, i.elements, Pn) : r instanceof Zu && i instanceof Zu ? Pn(r.Pe, i.Pe) : r instanceof Ju && i instanceof Ju
    }(t.transform, e.transform)
}
class tV {
    constructor(e, n) {
        this.version = e, this.transformResults = n
    }
}
class Xt {
    constructor(e, n) {
        this.updateTime = e, this.exists = n
    }
    static none() {
        return new Xt
    }
    static exists(e) {
        return new Xt(void 0, e)
    }
    static updateTime(e) {
        return new Xt(e)
    }
    get isNone() {
        return this.updateTime === void 0 && this.exists === void 0
    }
    isEqual(e) {
        return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime)
    }
}

function cu(t, e) {
    return t.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t.updateTime) : t.exists === void 0 || t.exists === e.isFoundDocument()
}
class Yc {}

function VS(t, e) {
    if (!t.hasLocalMutations || e && e.fields.length === 0) return null;
    if (e === null) return t.isNoDocument() ? new Lm(t.key, Xt.none()) : new Ha(t.key, t.data, Xt.none()); {
        const n = t.data,
            r = At.empty();
        let i = new Ue(Ge.comparator);
        for (let s of e.fields)
            if (!i.has(s)) {
                let o = n.field(s);
                o === null && s.length > 1 && (s = s.popLast(), o = n.field(s)), o === null ? r.delete(s) : r.set(s, o), i = i.add(s)
            }
        return new Zr(t.key, r, new Lt(i.toArray()), Xt.none())
    }
}

function nV(t, e, n) {
    t instanceof Ha ? function(i, s, o) {
        const a = i.value.clone(),
            u = q_(i.fieldTransforms, s, o.transformResults);
        a.setAll(u), s.convertToFoundDocument(o.version, a).setHasCommittedMutations()
    }(t, e, n) : t instanceof Zr ? function(i, s, o) {
        if (!cu(i.precondition, s)) return void s.convertToUnknownDocument(o.version);
        const a = q_(i.fieldTransforms, s, o.transformResults),
            u = s.data;
        u.setAll(OS(i)), u.setAll(a), s.convertToFoundDocument(o.version, u).setHasCommittedMutations()
    }(t, e, n) : function(i, s, o) {
        s.convertToNoDocument(o.version).setHasCommittedMutations()
    }(0, e, n)
}

function Zo(t, e, n, r) {
    return t instanceof Ha ? function(s, o, a, u) {
        if (!cu(s.precondition, o)) return a;
        const c = s.value.clone(),
            h = H_(s.fieldTransforms, u, o);
        return c.setAll(h), o.convertToFoundDocument(o.version, c).setHasLocalMutations(), null
    }(t, e, n, r) : t instanceof Zr ? function(s, o, a, u) {
        if (!cu(s.precondition, o)) return a;
        const c = H_(s.fieldTransforms, u, o),
            h = o.data;
        return h.setAll(OS(s)), h.setAll(c), o.convertToFoundDocument(o.version, h).setHasLocalMutations(), a === null ? null : a.unionWith(s.fieldMask.fields).unionWith(s.fieldTransforms.map(f => f.field))
    }(t, e, n, r) : function(s, o, a) {
        return cu(s.precondition, o) ? (o.convertToNoDocument(o.version).setHasLocalMutations(), null) : a
    }(t, e, n)
}

function rV(t, e) {
    let n = null;
    for (const r of t.fieldTransforms) {
        const i = e.data.field(r.field),
            s = xS(r.transform, i || null);
        s != null && (n === null && (n = At.empty()), n.set(r.field, s))
    }
    return n || null
}

function W_(t, e) {
    return t.type === e.type && !!t.key.isEqual(e.key) && !!t.precondition.isEqual(e.precondition) && !! function(r, i) {
        return r === void 0 && i === void 0 || !(!r || !i) && Os(r, i, (s, o) => eV(s, o))
    }(t.fieldTransforms, e.fieldTransforms) && (t.type === 0 ? t.value.isEqual(e.value) : t.type !== 1 || t.data.isEqual(e.data) && t.fieldMask.isEqual(e.fieldMask))
}
class Ha extends Yc {
    constructor(e, n, r, i = []) {
        super(), this.key = e, this.value = n, this.precondition = r, this.fieldTransforms = i, this.type = 0
    }
    getFieldMask() {
        return null
    }
}
class Zr extends Yc {
    constructor(e, n, r, i, s = []) {
        super(), this.key = e, this.data = n, this.fieldMask = r, this.precondition = i, this.fieldTransforms = s, this.type = 1
    }
    getFieldMask() {
        return this.fieldMask
    }
}

function OS(t) {
    const e = new Map;
    return t.fieldMask.fields.forEach(n => {
        if (!n.isEmpty()) {
            const r = t.data.field(n);
            e.set(n, r)
        }
    }), e
}

function q_(t, e, n) {
    const r = new Map;
    ae(t.length === n.length);
    for (let i = 0; i < n.length; i++) {
        const s = t[i],
            o = s.transform,
            a = e.data.field(s.field);
        r.set(s.field, ZD(o, a, n[i]))
    }
    return r
}

function H_(t, e, n) {
    const r = new Map;
    for (const i of t) {
        const s = i.transform,
            o = n.data.field(i.field);
        r.set(i.field, JD(s, o, e))
    }
    return r
}
class Lm extends Yc {
    constructor(e, n) {
        super(), this.key = e, this.precondition = n, this.type = 2, this.fieldTransforms = []
    }
    getFieldMask() {
        return null
    }
}
class iV extends Yc {
    constructor(e, n) {
        super(), this.key = e, this.precondition = n, this.type = 3, this.fieldTransforms = []
    }
    getFieldMask() {
        return null
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sV {
    constructor(e, n, r, i) {
        this.batchId = e, this.localWriteTime = n, this.baseMutations = r, this.mutations = i
    }
    applyToRemoteDocument(e, n) {
        const r = n.mutationResults;
        for (let i = 0; i < this.mutations.length; i++) {
            const s = this.mutations[i];
            s.key.isEqual(e.key) && nV(s, e, r[i])
        }
    }
    applyToLocalView(e, n) {
        for (const r of this.baseMutations) r.key.isEqual(e.key) && (n = Zo(r, e, n, this.localWriteTime));
        for (const r of this.mutations) r.key.isEqual(e.key) && (n = Zo(r, e, n, this.localWriteTime));
        return n
    }
    applyToLocalDocumentSet(e, n) {
        const r = CS();
        return this.mutations.forEach(i => {
            const s = e.get(i.key),
                o = s.overlayedDocument;
            let a = this.applyToLocalView(o, s.mutatedFields);
            a = n.has(i.key) ? null : a;
            const u = VS(o, a);
            u !== null && r.set(i.key, u), o.isValidDocument() || o.convertToNoDocument(J.min())
        }), r
    }
    keys() {
        return this.mutations.reduce((e, n) => e.add(n.key), ne())
    }
    isEqual(e) {
        return this.batchId === e.batchId && Os(this.mutations, e.mutations, (n, r) => W_(n, r)) && Os(this.baseMutations, e.baseMutations, (n, r) => W_(n, r))
    }
}
class Mm {
    constructor(e, n, r, i) {
        this.batch = e, this.commitVersion = n, this.mutationResults = r, this.docVersions = i
    }
    static from(e, n, r) {
        ae(e.mutations.length === r.length);
        let i = function() {
            return KD
        }();
        const s = e.mutations;
        for (let o = 0; o < s.length; o++) i = i.insert(s[o].key, r[o].version);
        return new Mm(e, n, r, i)
    }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oV {
    constructor(e, n) {
        this.largestBatchId = e, this.mutation = n
    }
    getKey() {
        return this.mutation.key
    }
    isEqual(e) {
        return e !== null && this.mutation === e.mutation
    }
    toString() {
        return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class aV {
    constructor(e, n) {
        this.count = e, this.unchangedNames = n
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Ne, ie;

function lV(t) {
    switch (t) {
        default: return Y();
        case L.CANCELLED:
                case L.UNKNOWN:
                case L.DEADLINE_EXCEEDED:
                case L.RESOURCE_EXHAUSTED:
                case L.INTERNAL:
                case L.UNAVAILABLE:
                case L.UNAUTHENTICATED:
                return !1;
        case L.INVALID_ARGUMENT:
                case L.NOT_FOUND:
                case L.ALREADY_EXISTS:
                case L.PERMISSION_DENIED:
                case L.FAILED_PRECONDITION:
                case L.ABORTED:
                case L.OUT_OF_RANGE:
                case L.UNIMPLEMENTED:
                case L.DATA_LOSS:
                return !0
    }
}

function LS(t) {
    if (t === void 0) return Zn("GRPC error has no .code"), L.UNKNOWN;
    switch (t) {
        case Ne.OK:
            return L.OK;
        case Ne.CANCELLED:
            return L.CANCELLED;
        case Ne.UNKNOWN:
            return L.UNKNOWN;
        case Ne.DEADLINE_EXCEEDED:
            return L.DEADLINE_EXCEEDED;
        case Ne.RESOURCE_EXHAUSTED:
            return L.RESOURCE_EXHAUSTED;
        case Ne.INTERNAL:
            return L.INTERNAL;
        case Ne.UNAVAILABLE:
            return L.UNAVAILABLE;
        case Ne.UNAUTHENTICATED:
            return L.UNAUTHENTICATED;
        case Ne.INVALID_ARGUMENT:
            return L.INVALID_ARGUMENT;
        case Ne.NOT_FOUND:
            return L.NOT_FOUND;
        case Ne.ALREADY_EXISTS:
            return L.ALREADY_EXISTS;
        case Ne.PERMISSION_DENIED:
            return L.PERMISSION_DENIED;
        case Ne.FAILED_PRECONDITION:
            return L.FAILED_PRECONDITION;
        case Ne.ABORTED:
            return L.ABORTED;
        case Ne.OUT_OF_RANGE:
            return L.OUT_OF_RANGE;
        case Ne.UNIMPLEMENTED:
            return L.UNIMPLEMENTED;
        case Ne.DATA_LOSS:
            return L.DATA_LOSS;
        default:
            return Y()
    }
}(ie = Ne || (Ne = {}))[ie.OK = 0] = "OK", ie[ie.CANCELLED = 1] = "CANCELLED", ie[ie.UNKNOWN = 2] = "UNKNOWN", ie[ie.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", ie[ie.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", ie[ie.NOT_FOUND = 5] = "NOT_FOUND", ie[ie.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", ie[ie.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", ie[ie.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", ie[ie.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", ie[ie.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", ie[ie.ABORTED = 10] = "ABORTED", ie[ie.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", ie[ie.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", ie[ie.INTERNAL = 13] = "INTERNAL", ie[ie.UNAVAILABLE = 14] = "UNAVAILABLE", ie[ie.DATA_LOSS = 15] = "DATA_LOSS";
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function uV() {
    return new TextEncoder
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cV = new Ei([4294967295, 4294967295], 0);

function K_(t) {
    const e = uV().encode(t),
        n = new oS;
    return n.update(e), new Uint8Array(n.digest())
}

function G_(t) {
    const e = new DataView(t.buffer),
        n = e.getUint32(0, !0),
        r = e.getUint32(4, !0),
        i = e.getUint32(8, !0),
        s = e.getUint32(12, !0);
    return [new Ei([n, r], 0), new Ei([i, s], 0)]
}
class Fm {
    constructor(e, n, r) {
        if (this.bitmap = e, this.padding = n, this.hashCount = r, n < 0 || n >= 8) throw new Oo(`Invalid padding: ${n}`);
        if (r < 0) throw new Oo(`Invalid hash count: ${r}`);
        if (e.length > 0 && this.hashCount === 0) throw new Oo(`Invalid hash count: ${r}`);
        if (e.length === 0 && n !== 0) throw new Oo(`Invalid padding when bitmap length is 0: ${n}`);
        this.Te = 8 * e.length - n, this.Ie = Ei.fromNumber(this.Te)
    }
    Ee(e, n, r) {
        let i = e.add(n.multiply(Ei.fromNumber(r)));
        return i.compare(cV) === 1 && (i = new Ei([i.getBits(0), i.getBits(1)], 0)), i.modulo(this.Ie).toNumber()
    }
    de(e) {
        return (this.bitmap[Math.floor(e / 8)] & 1 << e % 8) != 0
    }
    mightContain(e) {
        if (this.Te === 0) return !1;
        const n = K_(e),
            [r, i] = G_(n);
        for (let s = 0; s < this.hashCount; s++) {
            const o = this.Ee(r, i, s);
            if (!this.de(o)) return !1
        }
        return !0
    }
    static create(e, n, r) {
        const i = e % 8 == 0 ? 0 : 8 - e % 8,
            s = new Uint8Array(Math.ceil(e / 8)),
            o = new Fm(s, i, n);
        return r.forEach(a => o.insert(a)), o
    }
    insert(e) {
        if (this.Te === 0) return;
        const n = K_(e),
            [r, i] = G_(n);
        for (let s = 0; s < this.hashCount; s++) {
            const o = this.Ee(r, i, s);
            this.Ae(o)
        }
    }
    Ae(e) {
        const n = Math.floor(e / 8),
            r = e % 8;
        this.bitmap[n] |= 1 << r
    }
}
class Oo extends Error {
    constructor() {
        super(...arguments), this.name = "BloomFilterError"
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xc {
    constructor(e, n, r, i, s) {
        this.snapshotVersion = e, this.targetChanges = n, this.targetMismatches = r, this.documentUpdates = i, this.resolvedLimboDocuments = s
    }
    static createSynthesizedRemoteEventForCurrentChange(e, n, r) {
        const i = new Map;
        return i.set(e, Ka.createSynthesizedTargetChangeForCurrentChange(e, n, r)), new Xc(J.min(), i, new Ae(re), er(), ne())
    }
}
class Ka {
    constructor(e, n, r, i, s) {
        this.resumeToken = e, this.current = n, this.addedDocuments = r, this.modifiedDocuments = i, this.removedDocuments = s
    }
    static createSynthesizedTargetChangeForCurrentChange(e, n, r) {
        return new Ka(r, n, ne(), ne(), ne())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hu {
    constructor(e, n, r, i) {
        this.Re = e, this.removedTargetIds = n, this.key = r, this.Ve = i
    }
}
class MS {
    constructor(e, n) {
        this.targetId = e, this.me = n
    }
}
class FS {
    constructor(e, n, r = Xe.EMPTY_BYTE_STRING, i = null) {
        this.state = e, this.targetIds = n, this.resumeToken = r, this.cause = i
    }
}
class Q_ {
    constructor() {
        this.fe = 0, this.ge = Y_(), this.pe = Xe.EMPTY_BYTE_STRING, this.ye = !1, this.we = !0
    }
    get current() {
        return this.ye
    }
    get resumeToken() {
        return this.pe
    }
    get Se() {
        return this.fe !== 0
    }
    get be() {
        return this.we
    }
    De(e) {
        e.approximateByteSize() > 0 && (this.we = !0, this.pe = e)
    }
    ve() {
        let e = ne(),
            n = ne(),
            r = ne();
        return this.ge.forEach((i, s) => {
            switch (s) {
                case 0:
                    e = e.add(i);
                    break;
                case 2:
                    n = n.add(i);
                    break;
                case 1:
                    r = r.add(i);
                    break;
                default:
                    Y()
            }
        }), new Ka(this.pe, this.ye, e, n, r)
    }
    Ce() {
        this.we = !1, this.ge = Y_()
    }
    Fe(e, n) {
        this.we = !0, this.ge = this.ge.insert(e, n)
    }
    Me(e) {
        this.we = !0, this.ge = this.ge.remove(e)
    }
    xe() {
        this.fe += 1
    }
    Oe() {
        this.fe -= 1, ae(this.fe >= 0)
    }
    Ne() {
        this.we = !0, this.ye = !0
    }
}
class hV {
    constructor(e) {
        this.Le = e, this.Be = new Map, this.ke = er(), this.qe = Bl(), this.Qe = Bl(), this.Ke = new Ae(re)
    }
    $e(e) {
        for (const n of e.Re) e.Ve && e.Ve.isFoundDocument() ? this.Ue(n, e.Ve) : this.We(n, e.key, e.Ve);
        for (const n of e.removedTargetIds) this.We(n, e.key, e.Ve)
    }
    Ge(e) {
        this.forEachTarget(e, n => {
            const r = this.ze(n);
            switch (e.state) {
                case 0:
                    this.je(n) && r.De(e.resumeToken);
                    break;
                case 1:
                    r.Oe(), r.Se || r.Ce(), r.De(e.resumeToken);
                    break;
                case 2:
                    r.Oe(), r.Se || this.removeTarget(n);
                    break;
                case 3:
                    this.je(n) && (r.Ne(), r.De(e.resumeToken));
                    break;
                case 4:
                    this.je(n) && (this.He(n), r.De(e.resumeToken));
                    break;
                default:
                    Y()
            }
        })
    }
    forEachTarget(e, n) {
        e.targetIds.length > 0 ? e.targetIds.forEach(n) : this.Be.forEach((r, i) => {
            this.je(i) && n(i)
        })
    }
    Je(e) {
        const n = e.targetId,
            r = e.me.count,
            i = this.Ye(n);
        if (i) {
            const s = i.target;
            if (Kf(s))
                if (r === 0) {
                    const o = new H(s.path);
                    this.We(n, o, lt.newNoDocument(o, J.min()))
                } else ae(r === 1);
            else {
                const o = this.Ze(n);
                if (o !== r) {
                    const a = this.Xe(e),
                        u = a ? this.et(a, e, o) : 1;
                    if (u !== 0) {
                        this.He(n);
                        const c = u === 2 ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch";
                        this.Ke = this.Ke.insert(n, c)
                    }
                }
            }
        }
    }
    Xe(e) {
        const n = e.me.unchangedNames;
        if (!n || !n.bits) return null;
        const {
            bits: {
                bitmap: r = "",
                padding: i = 0
            },
            hashCount: s = 0
        } = n;
        let o, a;
        try {
            o = Br(r).toUint8Array()
        } catch (u) {
            if (u instanceof mS) return Vs("Decoding the base64 bloom filter in existence filter failed (" + u.message + "); ignoring the bloom filter and falling back to full re-query."), null;
            throw u
        }
        try {
            a = new Fm(o, i, s)
        } catch (u) {
            return Vs(u instanceof Oo ? "BloomFilter error: " : "Applying bloom filter failed: ", u), null
        }
        return a.Te === 0 ? null : a
    }
    et(e, n, r) {
        return n.me.count === r - this.rt(e, n.targetId) ? 0 : 2
    }
    rt(e, n) {
        const r = this.Le.getRemoteKeysForTarget(n);
        let i = 0;
        return r.forEach(s => {
            const o = this.Le.nt(),
                a = `projects/${o.projectId}/databases/${o.database}/documents/${s.path.canonicalString()}`;
            e.mightContain(a) || (this.We(n, s, null), i++)
        }), i
    }
    it(e) {
        const n = new Map;
        this.Be.forEach((s, o) => {
            const a = this.Ye(o);
            if (a) {
                if (s.current && Kf(a.target)) {
                    const u = new H(a.target.path);
                    this.st(u).has(o) || this.ot(o, u) || this.We(o, u, lt.newNoDocument(u, e))
                }
                s.be && (n.set(o, s.ve()), s.Ce())
            }
        });
        let r = ne();
        this.Qe.forEach((s, o) => {
            let a = !0;
            o.forEachWhile(u => {
                const c = this.Ye(u);
                return !c || c.purpose === "TargetPurposeLimboResolution" || (a = !1, !1)
            }), a && (r = r.add(s))
        }), this.ke.forEach((s, o) => o.setReadTime(e));
        const i = new Xc(e, n, this.Ke, this.ke, r);
        return this.ke = er(), this.qe = Bl(), this.Qe = Bl(), this.Ke = new Ae(re), i
    }
    Ue(e, n) {
        if (!this.je(e)) return;
        const r = this.ot(e, n.key) ? 2 : 0;
        this.ze(e).Fe(n.key, r), this.ke = this.ke.insert(n.key, n), this.qe = this.qe.insert(n.key, this.st(n.key).add(e)), this.Qe = this.Qe.insert(n.key, this._t(n.key).add(e))
    }
    We(e, n, r) {
        if (!this.je(e)) return;
        const i = this.ze(e);
        this.ot(e, n) ? i.Fe(n, 1) : i.Me(n), this.Qe = this.Qe.insert(n, this._t(n).delete(e)), this.Qe = this.Qe.insert(n, this._t(n).add(e)), r && (this.ke = this.ke.insert(n, r))
    }
    removeTarget(e) {
        this.Be.delete(e)
    }
    Ze(e) {
        const n = this.ze(e).ve();
        return this.Le.getRemoteKeysForTarget(e).size + n.addedDocuments.size - n.removedDocuments.size
    }
    xe(e) {
        this.ze(e).xe()
    }
    ze(e) {
        let n = this.Be.get(e);
        return n || (n = new Q_, this.Be.set(e, n)), n
    }
    _t(e) {
        let n = this.Qe.get(e);
        return n || (n = new Ue(re), this.Qe = this.Qe.insert(e, n)), n
    }
    st(e) {
        let n = this.qe.get(e);
        return n || (n = new Ue(re), this.qe = this.qe.insert(e, n)), n
    }
    je(e) {
        const n = this.Ye(e) !== null;
        return n || W("WatchChangeAggregator", "Detected inactive target", e), n
    }
    Ye(e) {
        const n = this.Be.get(e);
        return n && n.Se ? null : this.Le.ut(e)
    }
    He(e) {
        this.Be.set(e, new Q_), this.Le.getRemoteKeysForTarget(e).forEach(n => {
            this.We(e, n, null)
        })
    }
    ot(e, n) {
        return this.Le.getRemoteKeysForTarget(e).has(n)
    }
}

function Bl() {
    return new Ae(H.comparator)
}

function Y_() {
    return new Ae(H.comparator)
}
const dV = {
        asc: "ASCENDING",
        desc: "DESCENDING"
    },
    fV = {
        "<": "LESS_THAN",
        "<=": "LESS_THAN_OR_EQUAL",
        ">": "GREATER_THAN",
        ">=": "GREATER_THAN_OR_EQUAL",
        "==": "EQUAL",
        "!=": "NOT_EQUAL",
        "array-contains": "ARRAY_CONTAINS",
        in: "IN",
        "not-in": "NOT_IN",
        "array-contains-any": "ARRAY_CONTAINS_ANY"
    },
    pV = {
        and: "AND",
        or: "OR"
    };
class mV {
    constructor(e, n) {
        this.databaseId = e, this.useProto3Json = n
    }
}

function Qf(t, e) {
    return t.useProto3Json || qc(e) ? e : {
        value: e
    }
}

function ec(t, e) {
    return t.useProto3Json ? `${new Date(1e3*e.seconds).toISOString().replace(/\.\d*/,"").replace("Z","")}.${("000000000"+e.nanoseconds).slice(-9)}Z` : {
        seconds: "" + e.seconds,
        nanos: e.nanoseconds
    }
}

function US(t, e) {
    return t.useProto3Json ? e.toBase64() : e.toUint8Array()
}

function gV(t, e) {
    return ec(t, e.toTimestamp())
}

function Tn(t) {
    return ae(!!t), J.fromTimestamp(function(n) {
        const r = jr(n);
        return new Fe(r.seconds, r.nanos)
    }(t))
}

function Um(t, e) {
    return Yf(t, e).canonicalString()
}

function Yf(t, e) {
    const n = function(i) {
        return new ye(["projects", i.projectId, "databases", i.database])
    }(t).child("documents");
    return e === void 0 ? n : n.child(e)
}

function jS(t) {
    const e = ye.fromString(t);
    return ae(qS(e)), e
}

function Xf(t, e) {
    return Um(t.databaseId, e.path)
}

function _d(t, e) {
    const n = jS(e);
    if (n.get(1) !== t.databaseId.projectId) throw new z(L.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t.databaseId.projectId);
    if (n.get(3) !== t.databaseId.database) throw new z(L.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t.databaseId.database);
    return new H($S(n))
}

function BS(t, e) {
    return Um(t.databaseId, e)
}

function yV(t) {
    const e = jS(t);
    return e.length === 4 ? ye.emptyPath() : $S(e)
}

function Jf(t) {
    return new ye(["projects", t.databaseId.projectId, "databases", t.databaseId.database]).canonicalString()
}

function $S(t) {
    return ae(t.length > 4 && t.get(4) === "documents"), t.popFirst(5)
}

function X_(t, e, n) {
    return {
        name: Xf(t, e),
        fields: n.value.mapValue.fields
    }
}

function vV(t, e) {
    let n;
    if ("targetChange" in e) {
        e.targetChange;
        const r = function(c) {
                return c === "NO_CHANGE" ? 0 : c === "ADD" ? 1 : c === "REMOVE" ? 2 : c === "CURRENT" ? 3 : c === "RESET" ? 4 : Y()
            }(e.targetChange.targetChangeType || "NO_CHANGE"),
            i = e.targetChange.targetIds || [],
            s = function(c, h) {
                return c.useProto3Json ? (ae(h === void 0 || typeof h == "string"), Xe.fromBase64String(h || "")) : (ae(h === void 0 || h instanceof Buffer || h instanceof Uint8Array), Xe.fromUint8Array(h || new Uint8Array))
            }(t, e.targetChange.resumeToken),
            o = e.targetChange.cause,
            a = o && function(c) {
                const h = c.code === void 0 ? L.UNKNOWN : LS(c.code);
                return new z(h, c.message || "")
            }(o);
        n = new FS(r, i, s, a || null)
    } else if ("documentChange" in e) {
        e.documentChange;
        const r = e.documentChange;
        r.document, r.document.name, r.document.updateTime;
        const i = _d(t, r.document.name),
            s = Tn(r.document.updateTime),
            o = r.document.createTime ? Tn(r.document.createTime) : J.min(),
            a = new At({
                mapValue: {
                    fields: r.document.fields
                }
            }),
            u = lt.newFoundDocument(i, s, o, a),
            c = r.targetIds || [],
            h = r.removedTargetIds || [];
        n = new hu(c, h, u.key, u)
    } else if ("documentDelete" in e) {
        e.documentDelete;
        const r = e.documentDelete;
        r.document;
        const i = _d(t, r.document),
            s = r.readTime ? Tn(r.readTime) : J.min(),
            o = lt.newNoDocument(i, s),
            a = r.removedTargetIds || [];
        n = new hu([], a, o.key, o)
    } else if ("documentRemove" in e) {
        e.documentRemove;
        const r = e.documentRemove;
        r.document;
        const i = _d(t, r.document),
            s = r.removedTargetIds || [];
        n = new hu([], s, i, null)
    } else {
        if (!("filter" in e)) return Y(); {
            e.filter;
            const r = e.filter;
            r.targetId;
            const {
                count: i = 0,
                unchangedNames: s
            } = r, o = new aV(i, s), a = r.targetId;
            n = new MS(a, o)
        }
    }
    return n
}

function _V(t, e) {
    let n;
    if (e instanceof Ha) n = {
        update: X_(t, e.key, e.value)
    };
    else if (e instanceof Lm) n = {
        delete: Xf(t, e.key)
    };
    else if (e instanceof Zr) n = {
        update: X_(t, e.key, e.data),
        updateMask: CV(e.fieldMask)
    };
    else {
        if (!(e instanceof iV)) return Y();
        n = {
            verify: Xf(t, e.key)
        }
    }
    return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map(r => function(s, o) {
        const a = o.transform;
        if (a instanceof Ju) return {
            fieldPath: o.field.canonicalString(),
            setToServerValue: "REQUEST_TIME"
        };
        if (a instanceof xa) return {
            fieldPath: o.field.canonicalString(),
            appendMissingElements: {
                values: a.elements
            }
        };
        if (a instanceof ba) return {
            fieldPath: o.field.canonicalString(),
            removeAllFromArray: {
                values: a.elements
            }
        };
        if (a instanceof Zu) return {
            fieldPath: o.field.canonicalString(),
            increment: a.Pe
        };
        throw Y()
    }(0, r))), e.precondition.isNone || (n.currentDocument = function(i, s) {
        return s.updateTime !== void 0 ? {
            updateTime: gV(i, s.updateTime)
        } : s.exists !== void 0 ? {
            exists: s.exists
        } : Y()
    }(t, e.precondition)), n
}

function wV(t, e) {
    return t && t.length > 0 ? (ae(e !== void 0), t.map(n => function(i, s) {
        let o = i.updateTime ? Tn(i.updateTime) : Tn(s);
        return o.isEqual(J.min()) && (o = Tn(s)), new tV(o, i.transformResults || [])
    }(n, e))) : []
}

function TV(t, e) {
    return {
        documents: [BS(t, e.path)]
    }
}

function EV(t, e) {
    const n = {
            structuredQuery: {}
        },
        r = e.path;
    let i;
    e.collectionGroup !== null ? (i = r, n.structuredQuery.from = [{
        collectionId: e.collectionGroup,
        allDescendants: !0
    }]) : (i = r.popLast(), n.structuredQuery.from = [{
        collectionId: r.lastSegment()
    }]), n.parent = BS(t, i);
    const s = function(c) {
        if (c.length !== 0) return WS(hn.create(c, "and"))
    }(e.filters);
    s && (n.structuredQuery.where = s);
    const o = function(c) {
        if (c.length !== 0) return c.map(h => function(m) {
            return {
                field: Xi(m.field),
                direction: AV(m.dir)
            }
        }(h))
    }(e.orderBy);
    o && (n.structuredQuery.orderBy = o);
    const a = Qf(t, e.limit);
    return a !== null && (n.structuredQuery.limit = a), e.startAt && (n.structuredQuery.startAt = function(c) {
        return {
            before: c.inclusive,
            values: c.position
        }
    }(e.startAt)), e.endAt && (n.structuredQuery.endAt = function(c) {
        return {
            before: !c.inclusive,
            values: c.position
        }
    }(e.endAt)), {
        ct: n,
        parent: i
    }
}

function IV(t) {
    let e = yV(t.parent);
    const n = t.structuredQuery,
        r = n.from ? n.from.length : 0;
    let i = null;
    if (r > 0) {
        ae(r === 1);
        const h = n.from[0];
        h.allDescendants ? i = h.collectionId : e = e.child(h.collectionId)
    }
    let s = [];
    n.where && (s = function(f) {
        const m = zS(f);
        return m instanceof hn && _S(m) ? m.getFilters() : [m]
    }(n.where));
    let o = [];
    n.orderBy && (o = function(f) {
        return f.map(m => function(I) {
            return new ka(Ji(I.field), function(k) {
                switch (k) {
                    case "ASCENDING":
                        return "asc";
                    case "DESCENDING":
                        return "desc";
                    default:
                        return
                }
            }(I.direction))
        }(m))
    }(n.orderBy));
    let a = null;
    n.limit && (a = function(f) {
        let m;
        return m = typeof f == "object" ? f.value : f, qc(m) ? null : m
    }(n.limit));
    let u = null;
    n.startAt && (u = function(f) {
        const m = !!f.before,
            _ = f.values || [];
        return new Yu(_, m)
    }(n.startAt));
    let c = null;
    return n.endAt && (c = function(f) {
        const m = !f.before,
            _ = f.values || [];
        return new Yu(_, m)
    }(n.endAt)), $D(e, i, o, s, a, "F", u, c)
}

function SV(t, e) {
    const n = function(i) {
        switch (i) {
            case "TargetPurposeListen":
                return null;
            case "TargetPurposeExistenceFilterMismatch":
                return "existence-filter-mismatch";
            case "TargetPurposeExistenceFilterMismatchBloom":
                return "existence-filter-mismatch-bloom";
            case "TargetPurposeLimboResolution":
                return "limbo-document";
            default:
                return Y()
        }
    }(e.purpose);
    return n == null ? null : {
        "goog-listen-tags": n
    }
}

function zS(t) {
    return t.unaryFilter !== void 0 ? function(n) {
        switch (n.unaryFilter.op) {
            case "IS_NAN":
                const r = Ji(n.unaryFilter.field);
                return Ve.create(r, "==", {
                    doubleValue: NaN
                });
            case "IS_NULL":
                const i = Ji(n.unaryFilter.field);
                return Ve.create(i, "==", {
                    nullValue: "NULL_VALUE"
                });
            case "IS_NOT_NAN":
                const s = Ji(n.unaryFilter.field);
                return Ve.create(s, "!=", {
                    doubleValue: NaN
                });
            case "IS_NOT_NULL":
                const o = Ji(n.unaryFilter.field);
                return Ve.create(o, "!=", {
                    nullValue: "NULL_VALUE"
                });
            default:
                return Y()
        }
    }(t) : t.fieldFilter !== void 0 ? function(n) {
        return Ve.create(Ji(n.fieldFilter.field), function(i) {
            switch (i) {
                case "EQUAL":
                    return "==";
                case "NOT_EQUAL":
                    return "!=";
                case "GREATER_THAN":
                    return ">";
                case "GREATER_THAN_OR_EQUAL":
                    return ">=";
                case "LESS_THAN":
                    return "<";
                case "LESS_THAN_OR_EQUAL":
                    return "<=";
                case "ARRAY_CONTAINS":
                    return "array-contains";
                case "IN":
                    return "in";
                case "NOT_IN":
                    return "not-in";
                case "ARRAY_CONTAINS_ANY":
                    return "array-contains-any";
                default:
                    return Y()
            }
        }(n.fieldFilter.op), n.fieldFilter.value)
    }(t) : t.compositeFilter !== void 0 ? function(n) {
        return hn.create(n.compositeFilter.filters.map(r => zS(r)), function(i) {
            switch (i) {
                case "AND":
                    return "and";
                case "OR":
                    return "or";
                default:
                    return Y()
            }
        }(n.compositeFilter.op))
    }(t) : Y()
}

function AV(t) {
    return dV[t]
}

function PV(t) {
    return fV[t]
}

function RV(t) {
    return pV[t]
}

function Xi(t) {
    return {
        fieldPath: t.canonicalString()
    }
}

function Ji(t) {
    return Ge.fromServerFormat(t.fieldPath)
}

function WS(t) {
    return t instanceof Ve ? function(n) {
        if (n.op === "==") {
            if (F_(n.value)) return {
                unaryFilter: {
                    field: Xi(n.field),
                    op: "IS_NAN"
                }
            };
            if (M_(n.value)) return {
                unaryFilter: {
                    field: Xi(n.field),
                    op: "IS_NULL"
                }
            }
        } else if (n.op === "!=") {
            if (F_(n.value)) return {
                unaryFilter: {
                    field: Xi(n.field),
                    op: "IS_NOT_NAN"
                }
            };
            if (M_(n.value)) return {
                unaryFilter: {
                    field: Xi(n.field),
                    op: "IS_NOT_NULL"
                }
            }
        }
        return {
            fieldFilter: {
                field: Xi(n.field),
                op: PV(n.op),
                value: n.value
            }
        }
    }(t) : t instanceof hn ? function(n) {
        const r = n.getFilters().map(i => WS(i));
        return r.length === 1 ? r[0] : {
            compositeFilter: {
                op: RV(n.op),
                filters: r
            }
        }
    }(t) : Y()
}

function CV(t) {
    const e = [];
    return t.fields.forEach(n => e.push(n.canonicalString())), {
        fieldPaths: e
    }
}

function qS(t) {
    return t.length >= 4 && t.get(0) === "projects" && t.get(2) === "databases"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ar {
    constructor(e, n, r, i, s = J.min(), o = J.min(), a = Xe.EMPTY_BYTE_STRING, u = null) {
        this.target = e, this.targetId = n, this.purpose = r, this.sequenceNumber = i, this.snapshotVersion = s, this.lastLimboFreeSnapshotVersion = o, this.resumeToken = a, this.expectedCount = u
    }
    withSequenceNumber(e) {
        return new Ar(this.target, this.targetId, this.purpose, e, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount)
    }
    withResumeToken(e, n) {
        return new Ar(this.target, this.targetId, this.purpose, this.sequenceNumber, n, this.lastLimboFreeSnapshotVersion, e, null)
    }
    withExpectedCount(e) {
        return new Ar(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, e)
    }
    withLastLimboFreeSnapshotVersion(e) {
        return new Ar(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken, this.expectedCount)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kV {
    constructor(e) {
        this.ht = e
    }
}

function xV(t) {
    const e = IV({
        parent: t.parent,
        structuredQuery: t.structuredQuery
    });
    return t.limitType === "LAST" ? Xu(e, e.limit, "L") : e
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bV {
    constructor() {
        this.ln = new NV
    }
    addToCollectionParentIndex(e, n) {
        return this.ln.add(n), F.resolve()
    }
    getCollectionParents(e, n) {
        return F.resolve(this.ln.getEntries(n))
    }
    addFieldIndex(e, n) {
        return F.resolve()
    }
    deleteFieldIndex(e, n) {
        return F.resolve()
    }
    deleteAllFieldIndexes(e) {
        return F.resolve()
    }
    createTargetIndexes(e, n) {
        return F.resolve()
    }
    getDocumentsMatchingTarget(e, n) {
        return F.resolve(null)
    }
    getIndexType(e, n) {
        return F.resolve(0)
    }
    getFieldIndexes(e, n) {
        return F.resolve([])
    }
    getNextCollectionGroupToUpdate(e) {
        return F.resolve(null)
    }
    getMinOffset(e, n) {
        return F.resolve(Ur.min())
    }
    getMinOffsetFromCollectionGroup(e, n) {
        return F.resolve(Ur.min())
    }
    updateCollectionGroup(e, n, r) {
        return F.resolve()
    }
    updateIndexEntries(e, n) {
        return F.resolve()
    }
}
class NV {
    constructor() {
        this.index = {}
    }
    add(e) {
        const n = e.lastSegment(),
            r = e.popLast(),
            i = this.index[n] || new Ue(ye.comparator),
            s = !i.has(r);
        return this.index[n] = i.add(r), s
    }
    has(e) {
        const n = e.lastSegment(),
            r = e.popLast(),
            i = this.index[n];
        return i && i.has(r)
    }
    getEntries(e) {
        return (this.index[e] || new Ue(ye.comparator)).toArray()
    }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const J_ = {
    didRun: !1,
    sequenceNumbersCollected: 0,
    targetsRemoved: 0,
    documentsRemoved: 0
};
class Et {
    static withCacheSize(e) {
        return new Et(e, Et.DEFAULT_COLLECTION_PERCENTILE, Et.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)
    }
    constructor(e, n, r) {
        this.cacheSizeCollectionThreshold = e, this.percentileToCollect = n, this.maximumSequenceNumbersToCollect = r
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Et.DEFAULT_COLLECTION_PERCENTILE = 10, Et.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Et.DEFAULT = new Et(41943040, Et.DEFAULT_COLLECTION_PERCENTILE, Et.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Et.DISABLED = new Et(-1, 0, 0);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fs {
    constructor(e) {
        this.kn = e
    }
    next() {
        return this.kn += 2, this.kn
    }
    static qn() {
        return new Fs(0)
    }
    static Qn() {
        return new Fs(-1)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Z_([t, e], [n, r]) {
    const i = re(t, n);
    return i === 0 ? re(e, r) : i
}
class DV {
    constructor(e) {
        this.Gn = e, this.buffer = new Ue(Z_), this.zn = 0
    }
    jn() {
        return ++this.zn
    }
    Hn(e) {
        const n = [e, this.jn()];
        if (this.buffer.size < this.Gn) this.buffer = this.buffer.add(n);
        else {
            const r = this.buffer.last();
            Z_(n, r) < 0 && (this.buffer = this.buffer.delete(r).add(n))
        }
    }
    get maxValue() {
        return this.buffer.last()[0]
    }
}
class VV {
    constructor(e, n, r) {
        this.garbageCollector = e, this.asyncQueue = n, this.localStore = r, this.Jn = null
    }
    start() {
        this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.Yn(6e4)
    }
    stop() {
        this.Jn && (this.Jn.cancel(), this.Jn = null)
    }
    get started() {
        return this.Jn !== null
    }
    Yn(e) {
        W("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.Jn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
            this.Jn = null;
            try {
                await this.localStore.collectGarbage(this.garbageCollector)
            } catch (n) {
                Ys(n) ? W("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", n) : await Qs(n)
            }
            await this.Yn(3e5)
        })
    }
}
class OV {
    constructor(e, n) {
        this.Zn = e, this.params = n
    }
    calculateTargetCount(e, n) {
        return this.Zn.Xn(e).next(r => Math.floor(n / 100 * r))
    }
    nthSequenceNumber(e, n) {
        if (n === 0) return F.resolve(Wc.oe);
        const r = new DV(n);
        return this.Zn.forEachTarget(e, i => r.Hn(i.sequenceNumber)).next(() => this.Zn.er(e, i => r.Hn(i))).next(() => r.maxValue)
    }
    removeTargets(e, n, r) {
        return this.Zn.removeTargets(e, n, r)
    }
    removeOrphanedDocuments(e, n) {
        return this.Zn.removeOrphanedDocuments(e, n)
    }
    collect(e, n) {
        return this.params.cacheSizeCollectionThreshold === -1 ? (W("LruGarbageCollector", "Garbage collection skipped; disabled"), F.resolve(J_)) : this.getCacheSize(e).next(r => r < this.params.cacheSizeCollectionThreshold ? (W("LruGarbageCollector", `Garbage collection skipped; Cache size ${r} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), J_) : this.tr(e, n))
    }
    getCacheSize(e) {
        return this.Zn.getCacheSize(e)
    }
    tr(e, n) {
        let r, i, s, o, a, u, c;
        const h = Date.now();
        return this.calculateTargetCount(e, this.params.percentileToCollect).next(f => (f > this.params.maximumSequenceNumbersToCollect ? (W("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${f}`), i = this.params.maximumSequenceNumbersToCollect) : i = f, o = Date.now(), this.nthSequenceNumber(e, i))).next(f => (r = f, a = Date.now(), this.removeTargets(e, r, n))).next(f => (s = f, u = Date.now(), this.removeOrphanedDocuments(e, r))).next(f => (c = Date.now(), Qi() <= te.DEBUG && W("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${o-h}ms
	Determined least recently used ${i} in ` + (a - o) + `ms
	Removed ${s} targets in ` + (u - a) + `ms
	Removed ${f} documents in ` + (c - u) + `ms
Total Duration: ${c-h}ms`), F.resolve({
            didRun: !0,
            sequenceNumbersCollected: i,
            targetsRemoved: s,
            documentsRemoved: f
        })))
    }
}

function LV(t, e) {
    return new OV(t, e)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MV {
    constructor() {
        this.changes = new Mi(e => e.toString(), (e, n) => e.isEqual(n)), this.changesApplied = !1
    }
    addEntry(e) {
        this.assertNotApplied(), this.changes.set(e.key, e)
    }
    removeEntry(e, n) {
        this.assertNotApplied(), this.changes.set(e, lt.newInvalidDocument(e).setReadTime(n))
    }
    getEntry(e, n) {
        this.assertNotApplied();
        const r = this.changes.get(n);
        return r !== void 0 ? F.resolve(r) : this.getFromCache(e, n)
    }
    getEntries(e, n) {
        return this.getAllFromCache(e, n)
    }
    apply(e) {
        return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(e)
    }
    assertNotApplied() {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FV {
    constructor(e, n) {
        this.overlayedDocument = e, this.mutatedFields = n
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UV {
    constructor(e, n, r, i) {
        this.remoteDocumentCache = e, this.mutationQueue = n, this.documentOverlayCache = r, this.indexManager = i
    }
    getDocument(e, n) {
        let r = null;
        return this.documentOverlayCache.getOverlay(e, n).next(i => (r = i, this.remoteDocumentCache.getEntry(e, n))).next(i => (r !== null && Zo(r.mutation, i, Lt.empty(), Fe.now()), i))
    }
    getDocuments(e, n) {
        return this.remoteDocumentCache.getEntries(e, n).next(r => this.getLocalViewOfDocuments(e, r, ne()).next(() => r))
    }
    getLocalViewOfDocuments(e, n, r = ne()) {
        const i = vi();
        return this.populateOverlays(e, i, n).next(() => this.computeViews(e, n, i, r).next(s => {
            let o = Vo();
            return s.forEach((a, u) => {
                o = o.insert(a, u.overlayedDocument)
            }), o
        }))
    }
    getOverlayedDocuments(e, n) {
        const r = vi();
        return this.populateOverlays(e, r, n).next(() => this.computeViews(e, n, r, ne()))
    }
    populateOverlays(e, n, r) {
        const i = [];
        return r.forEach(s => {
            n.has(s) || i.push(s)
        }), this.documentOverlayCache.getOverlays(e, i).next(s => {
            s.forEach((o, a) => {
                n.set(o, a)
            })
        })
    }
    computeViews(e, n, r, i) {
        let s = er();
        const o = Jo(),
            a = function() {
                return Jo()
            }();
        return n.forEach((u, c) => {
            const h = r.get(c.key);
            i.has(c.key) && (h === void 0 || h.mutation instanceof Zr) ? s = s.insert(c.key, c) : h !== void 0 ? (o.set(c.key, h.mutation.getFieldMask()), Zo(h.mutation, c, h.mutation.getFieldMask(), Fe.now())) : o.set(c.key, Lt.empty())
        }), this.recalculateAndSaveOverlays(e, s).next(u => (u.forEach((c, h) => o.set(c, h)), n.forEach((c, h) => {
            var f;
            return a.set(c, new FV(h, (f = o.get(c)) !== null && f !== void 0 ? f : null))
        }), a))
    }
    recalculateAndSaveOverlays(e, n) {
        const r = Jo();
        let i = new Ae((o, a) => o - a),
            s = ne();
        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e, n).next(o => {
            for (const a of o) a.keys().forEach(u => {
                const c = n.get(u);
                if (c === null) return;
                let h = r.get(u) || Lt.empty();
                h = a.applyToLocalView(c, h), r.set(u, h);
                const f = (i.get(a.batchId) || ne()).add(u);
                i = i.insert(a.batchId, f)
            })
        }).next(() => {
            const o = [],
                a = i.getReverseIterator();
            for (; a.hasNext();) {
                const u = a.getNext(),
                    c = u.key,
                    h = u.value,
                    f = CS();
                h.forEach(m => {
                    if (!s.has(m)) {
                        const _ = VS(n.get(m), r.get(m));
                        _ !== null && f.set(m, _), s = s.add(m)
                    }
                }), o.push(this.documentOverlayCache.saveOverlays(e, c, f))
            }
            return F.waitFor(o)
        }).next(() => r)
    }
    recalculateAndSaveOverlaysForDocumentKeys(e, n) {
        return this.remoteDocumentCache.getEntries(e, n).next(r => this.recalculateAndSaveOverlays(e, r))
    }
    getDocumentsMatchingQuery(e, n, r, i) {
        return function(o) {
            return H.isDocumentKey(o.path) && o.collectionGroup === null && o.filters.length === 0
        }(n) ? this.getDocumentsMatchingDocumentQuery(e, n.path) : IS(n) ? this.getDocumentsMatchingCollectionGroupQuery(e, n, r, i) : this.getDocumentsMatchingCollectionQuery(e, n, r, i)
    }
    getNextDocuments(e, n, r, i) {
        return this.remoteDocumentCache.getAllFromCollectionGroup(e, n, r, i).next(s => {
            const o = i - s.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, n, r.largestBatchId, i - s.size) : F.resolve(vi());
            let a = -1,
                u = s;
            return o.next(c => F.forEach(c, (h, f) => (a < f.largestBatchId && (a = f.largestBatchId), s.get(h) ? F.resolve() : this.remoteDocumentCache.getEntry(e, h).next(m => {
                u = u.insert(h, m)
            }))).next(() => this.populateOverlays(e, c, s)).next(() => this.computeViews(e, u, c, ne())).next(h => ({
                batchId: a,
                changes: RS(h)
            })))
        })
    }
    getDocumentsMatchingDocumentQuery(e, n) {
        return this.getDocument(e, new H(n)).next(r => {
            let i = Vo();
            return r.isFoundDocument() && (i = i.insert(r.key, r)), i
        })
    }
    getDocumentsMatchingCollectionGroupQuery(e, n, r, i) {
        const s = n.collectionGroup;
        let o = Vo();
        return this.indexManager.getCollectionParents(e, s).next(a => F.forEach(a, u => {
            const c = function(f, m) {
                return new Xs(m, null, f.explicitOrderBy.slice(), f.filters.slice(), f.limit, f.limitType, f.startAt, f.endAt)
            }(n, u.child(s));
            return this.getDocumentsMatchingCollectionQuery(e, c, r, i).next(h => {
                h.forEach((f, m) => {
                    o = o.insert(f, m)
                })
            })
        }).next(() => o))
    }
    getDocumentsMatchingCollectionQuery(e, n, r, i) {
        let s;
        return this.documentOverlayCache.getOverlaysForCollection(e, n.path, r.largestBatchId).next(o => (s = o, this.remoteDocumentCache.getDocumentsMatchingQuery(e, n, r, s, i))).next(o => {
            s.forEach((u, c) => {
                const h = c.getKey();
                o.get(h) === null && (o = o.insert(h, lt.newInvalidDocument(h)))
            });
            let a = Vo();
            return o.forEach((u, c) => {
                const h = s.get(u);
                h !== void 0 && Zo(h.mutation, c, Lt.empty(), Fe.now()), Gc(n, c) && (a = a.insert(u, c))
            }), a
        })
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jV {
    constructor(e) {
        this.serializer = e, this.Tr = new Map, this.Ir = new Map
    }
    getBundleMetadata(e, n) {
        return F.resolve(this.Tr.get(n))
    }
    saveBundleMetadata(e, n) {
        return this.Tr.set(n.id, function(i) {
            return {
                id: i.id,
                version: i.version,
                createTime: Tn(i.createTime)
            }
        }(n)), F.resolve()
    }
    getNamedQuery(e, n) {
        return F.resolve(this.Ir.get(n))
    }
    saveNamedQuery(e, n) {
        return this.Ir.set(n.name, function(i) {
            return {
                name: i.name,
                query: xV(i.bundledQuery),
                readTime: Tn(i.readTime)
            }
        }(n)), F.resolve()
    }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BV {
    constructor() {
        this.overlays = new Ae(H.comparator), this.Er = new Map
    }
    getOverlay(e, n) {
        return F.resolve(this.overlays.get(n))
    }
    getOverlays(e, n) {
        const r = vi();
        return F.forEach(n, i => this.getOverlay(e, i).next(s => {
            s !== null && r.set(i, s)
        })).next(() => r)
    }
    saveOverlays(e, n, r) {
        return r.forEach((i, s) => {
            this.Tt(e, n, s)
        }), F.resolve()
    }
    removeOverlaysForBatchId(e, n, r) {
        const i = this.Er.get(r);
        return i !== void 0 && (i.forEach(s => this.overlays = this.overlays.remove(s)), this.Er.delete(r)), F.resolve()
    }
    getOverlaysForCollection(e, n, r) {
        const i = vi(),
            s = n.length + 1,
            o = new H(n.child("")),
            a = this.overlays.getIteratorFrom(o);
        for (; a.hasNext();) {
            const u = a.getNext().value,
                c = u.getKey();
            if (!n.isPrefixOf(c.path)) break;
            c.path.length === s && u.largestBatchId > r && i.set(u.getKey(), u)
        }
        return F.resolve(i)
    }
    getOverlaysForCollectionGroup(e, n, r, i) {
        let s = new Ae((c, h) => c - h);
        const o = this.overlays.getIterator();
        for (; o.hasNext();) {
            const c = o.getNext().value;
            if (c.getKey().getCollectionGroup() === n && c.largestBatchId > r) {
                let h = s.get(c.largestBatchId);
                h === null && (h = vi(), s = s.insert(c.largestBatchId, h)), h.set(c.getKey(), c)
            }
        }
        const a = vi(),
            u = s.getIterator();
        for (; u.hasNext() && (u.getNext().value.forEach((c, h) => a.set(c, h)), !(a.size() >= i)););
        return F.resolve(a)
    }
    Tt(e, n, r) {
        const i = this.overlays.get(r.key);
        if (i !== null) {
            const o = this.Er.get(i.largestBatchId).delete(r.key);
            this.Er.set(i.largestBatchId, o)
        }
        this.overlays = this.overlays.insert(r.key, new oV(n, r));
        let s = this.Er.get(n);
        s === void 0 && (s = ne(), this.Er.set(n, s)), this.Er.set(n, s.add(r.key))
    }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $V {
    constructor() {
        this.sessionToken = Xe.EMPTY_BYTE_STRING
    }
    getSessionToken(e) {
        return F.resolve(this.sessionToken)
    }
    setSessionToken(e, n) {
        return this.sessionToken = n, F.resolve()
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jm {
    constructor() {
        this.dr = new Ue(je.Ar), this.Rr = new Ue(je.Vr)
    }
    isEmpty() {
        return this.dr.isEmpty()
    }
    addReference(e, n) {
        const r = new je(e, n);
        this.dr = this.dr.add(r), this.Rr = this.Rr.add(r)
    }
    mr(e, n) {
        e.forEach(r => this.addReference(r, n))
    }
    removeReference(e, n) {
        this.gr(new je(e, n))
    }
    pr(e, n) {
        e.forEach(r => this.removeReference(r, n))
    }
    yr(e) {
        const n = new H(new ye([])),
            r = new je(n, e),
            i = new je(n, e + 1),
            s = [];
        return this.Rr.forEachInRange([r, i], o => {
            this.gr(o), s.push(o.key)
        }), s
    }
    wr() {
        this.dr.forEach(e => this.gr(e))
    }
    gr(e) {
        this.dr = this.dr.delete(e), this.Rr = this.Rr.delete(e)
    }
    Sr(e) {
        const n = new H(new ye([])),
            r = new je(n, e),
            i = new je(n, e + 1);
        let s = ne();
        return this.Rr.forEachInRange([r, i], o => {
            s = s.add(o.key)
        }), s
    }
    containsKey(e) {
        const n = new je(e, 0),
            r = this.dr.firstAfterOrEqual(n);
        return r !== null && e.isEqual(r.key)
    }
}
class je {
    constructor(e, n) {
        this.key = e, this.br = n
    }
    static Ar(e, n) {
        return H.comparator(e.key, n.key) || re(e.br, n.br)
    }
    static Vr(e, n) {
        return re(e.br, n.br) || H.comparator(e.key, n.key)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zV {
    constructor(e, n) {
        this.indexManager = e, this.referenceDelegate = n, this.mutationQueue = [], this.Dr = 1, this.vr = new Ue(je.Ar)
    }
    checkEmpty(e) {
        return F.resolve(this.mutationQueue.length === 0)
    }
    addMutationBatch(e, n, r, i) {
        const s = this.Dr;
        this.Dr++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
        const o = new sV(s, n, r, i);
        this.mutationQueue.push(o);
        for (const a of i) this.vr = this.vr.add(new je(a.key, s)), this.indexManager.addToCollectionParentIndex(e, a.key.path.popLast());
        return F.resolve(o)
    }
    lookupMutationBatch(e, n) {
        return F.resolve(this.Cr(n))
    }
    getNextMutationBatchAfterBatchId(e, n) {
        const r = n + 1,
            i = this.Fr(r),
            s = i < 0 ? 0 : i;
        return F.resolve(this.mutationQueue.length > s ? this.mutationQueue[s] : null)
    }
    getHighestUnacknowledgedBatchId() {
        return F.resolve(this.mutationQueue.length === 0 ? -1 : this.Dr - 1)
    }
    getAllMutationBatches(e) {
        return F.resolve(this.mutationQueue.slice())
    }
    getAllMutationBatchesAffectingDocumentKey(e, n) {
        const r = new je(n, 0),
            i = new je(n, Number.POSITIVE_INFINITY),
            s = [];
        return this.vr.forEachInRange([r, i], o => {
            const a = this.Cr(o.br);
            s.push(a)
        }), F.resolve(s)
    }
    getAllMutationBatchesAffectingDocumentKeys(e, n) {
        let r = new Ue(re);
        return n.forEach(i => {
            const s = new je(i, 0),
                o = new je(i, Number.POSITIVE_INFINITY);
            this.vr.forEachInRange([s, o], a => {
                r = r.add(a.br)
            })
        }), F.resolve(this.Mr(r))
    }
    getAllMutationBatchesAffectingQuery(e, n) {
        const r = n.path,
            i = r.length + 1;
        let s = r;
        H.isDocumentKey(s) || (s = s.child(""));
        const o = new je(new H(s), 0);
        let a = new Ue(re);
        return this.vr.forEachWhile(u => {
            const c = u.key.path;
            return !!r.isPrefixOf(c) && (c.length === i && (a = a.add(u.br)), !0)
        }, o), F.resolve(this.Mr(a))
    }
    Mr(e) {
        const n = [];
        return e.forEach(r => {
            const i = this.Cr(r);
            i !== null && n.push(i)
        }), n
    }
    removeMutationBatch(e, n) {
        ae(this.Or(n.batchId, "removed") === 0), this.mutationQueue.shift();
        let r = this.vr;
        return F.forEach(n.mutations, i => {
            const s = new je(i.key, n.batchId);
            return r = r.delete(s), this.referenceDelegate.markPotentiallyOrphaned(e, i.key)
        }).next(() => {
            this.vr = r
        })
    }
    Ln(e) {}
    containsKey(e, n) {
        const r = new je(n, 0),
            i = this.vr.firstAfterOrEqual(r);
        return F.resolve(n.isEqual(i && i.key))
    }
    performConsistencyCheck(e) {
        return this.mutationQueue.length, F.resolve()
    }
    Or(e, n) {
        return this.Fr(e)
    }
    Fr(e) {
        return this.mutationQueue.length === 0 ? 0 : e - this.mutationQueue[0].batchId
    }
    Cr(e) {
        const n = this.Fr(e);
        return n < 0 || n >= this.mutationQueue.length ? null : this.mutationQueue[n]
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WV {
    constructor(e) {
        this.Nr = e, this.docs = function() {
            return new Ae(H.comparator)
        }(), this.size = 0
    }
    setIndexManager(e) {
        this.indexManager = e
    }
    addEntry(e, n) {
        const r = n.key,
            i = this.docs.get(r),
            s = i ? i.size : 0,
            o = this.Nr(n);
        return this.docs = this.docs.insert(r, {
            document: n.mutableCopy(),
            size: o
        }), this.size += o - s, this.indexManager.addToCollectionParentIndex(e, r.path.popLast())
    }
    removeEntry(e) {
        const n = this.docs.get(e);
        n && (this.docs = this.docs.remove(e), this.size -= n.size)
    }
    getEntry(e, n) {
        const r = this.docs.get(n);
        return F.resolve(r ? r.document.mutableCopy() : lt.newInvalidDocument(n))
    }
    getEntries(e, n) {
        let r = er();
        return n.forEach(i => {
            const s = this.docs.get(i);
            r = r.insert(i, s ? s.document.mutableCopy() : lt.newInvalidDocument(i))
        }), F.resolve(r)
    }
    getDocumentsMatchingQuery(e, n, r, i) {
        let s = er();
        const o = n.path,
            a = new H(o.child("")),
            u = this.docs.getIteratorFrom(a);
        for (; u.hasNext();) {
            const {
                key: c,
                value: {
                    document: h
                }
            } = u.getNext();
            if (!o.isPrefixOf(c.path)) break;
            c.path.length > o.length + 1 || TD(wD(h), r) <= 0 || (i.has(h.key) || Gc(n, h)) && (s = s.insert(h.key, h.mutableCopy()))
        }
        return F.resolve(s)
    }
    getAllFromCollectionGroup(e, n, r, i) {
        Y()
    }
    Lr(e, n) {
        return F.forEach(this.docs, r => n(r))
    }
    newChangeBuffer(e) {
        return new qV(this)
    }
    getSize(e) {
        return F.resolve(this.size)
    }
}
class qV extends MV {
    constructor(e) {
        super(), this.hr = e
    }
    applyChanges(e) {
        const n = [];
        return this.changes.forEach((r, i) => {
            i.isValidDocument() ? n.push(this.hr.addEntry(e, i)) : this.hr.removeEntry(r)
        }), F.waitFor(n)
    }
    getFromCache(e, n) {
        return this.hr.getEntry(e, n)
    }
    getAllFromCache(e, n) {
        return this.hr.getEntries(e, n)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HV {
    constructor(e) {
        this.persistence = e, this.Br = new Mi(n => Nm(n), Dm), this.lastRemoteSnapshotVersion = J.min(), this.highestTargetId = 0, this.kr = 0, this.qr = new jm, this.targetCount = 0, this.Qr = Fs.qn()
    }
    forEachTarget(e, n) {
        return this.Br.forEach((r, i) => n(i)), F.resolve()
    }
    getLastRemoteSnapshotVersion(e) {
        return F.resolve(this.lastRemoteSnapshotVersion)
    }
    getHighestSequenceNumber(e) {
        return F.resolve(this.kr)
    }
    allocateTargetId(e) {
        return this.highestTargetId = this.Qr.next(), F.resolve(this.highestTargetId)
    }
    setTargetsMetadata(e, n, r) {
        return r && (this.lastRemoteSnapshotVersion = r), n > this.kr && (this.kr = n), F.resolve()
    }
    Un(e) {
        this.Br.set(e.target, e);
        const n = e.targetId;
        n > this.highestTargetId && (this.Qr = new Fs(n), this.highestTargetId = n), e.sequenceNumber > this.kr && (this.kr = e.sequenceNumber)
    }
    addTargetData(e, n) {
        return this.Un(n), this.targetCount += 1, F.resolve()
    }
    updateTargetData(e, n) {
        return this.Un(n), F.resolve()
    }
    removeTargetData(e, n) {
        return this.Br.delete(n.target), this.qr.yr(n.targetId), this.targetCount -= 1, F.resolve()
    }
    removeTargets(e, n, r) {
        let i = 0;
        const s = [];
        return this.Br.forEach((o, a) => {
            a.sequenceNumber <= n && r.get(a.targetId) === null && (this.Br.delete(o), s.push(this.removeMatchingKeysForTargetId(e, a.targetId)), i++)
        }), F.waitFor(s).next(() => i)
    }
    getTargetCount(e) {
        return F.resolve(this.targetCount)
    }
    getTargetData(e, n) {
        const r = this.Br.get(n) || null;
        return F.resolve(r)
    }
    addMatchingKeys(e, n, r) {
        return this.qr.mr(n, r), F.resolve()
    }
    removeMatchingKeys(e, n, r) {
        this.qr.pr(n, r);
        const i = this.persistence.referenceDelegate,
            s = [];
        return i && n.forEach(o => {
            s.push(i.markPotentiallyOrphaned(e, o))
        }), F.waitFor(s)
    }
    removeMatchingKeysForTargetId(e, n) {
        return this.qr.yr(n), F.resolve()
    }
    getMatchingKeysForTargetId(e, n) {
        const r = this.qr.Sr(n);
        return F.resolve(r)
    }
    containsKey(e, n) {
        return F.resolve(this.qr.containsKey(n))
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HS {
    constructor(e, n) {
        this.Kr = {}, this.overlays = {}, this.$r = new Wc(0), this.Ur = !1, this.Ur = !0, this.Wr = new $V, this.referenceDelegate = e(this), this.Gr = new HV(this), this.indexManager = new bV, this.remoteDocumentCache = function(i) {
            return new WV(i)
        }(r => this.referenceDelegate.zr(r)), this.serializer = new kV(n), this.jr = new jV(this.serializer)
    }
    start() {
        return Promise.resolve()
    }
    shutdown() {
        return this.Ur = !1, Promise.resolve()
    }
    get started() {
        return this.Ur
    }
    setDatabaseDeletedListener() {}
    setNetworkEnabled() {}
    getIndexManager(e) {
        return this.indexManager
    }
    getDocumentOverlayCache(e) {
        let n = this.overlays[e.toKey()];
        return n || (n = new BV, this.overlays[e.toKey()] = n), n
    }
    getMutationQueue(e, n) {
        let r = this.Kr[e.toKey()];
        return r || (r = new zV(n, this.referenceDelegate), this.Kr[e.toKey()] = r), r
    }
    getGlobalsCache() {
        return this.Wr
    }
    getTargetCache() {
        return this.Gr
    }
    getRemoteDocumentCache() {
        return this.remoteDocumentCache
    }
    getBundleCache() {
        return this.jr
    }
    runTransaction(e, n, r) {
        W("MemoryPersistence", "Starting transaction:", e);
        const i = new KV(this.$r.next());
        return this.referenceDelegate.Hr(), r(i).next(s => this.referenceDelegate.Jr(i).next(() => s)).toPromise().then(s => (i.raiseOnCommittedEvent(), s))
    }
    Yr(e, n) {
        return F.or(Object.values(this.Kr).map(r => () => r.containsKey(e, n)))
    }
}
class KV extends ID {
    constructor(e) {
        super(), this.currentSequenceNumber = e
    }
}
class Bm {
    constructor(e) {
        this.persistence = e, this.Zr = new jm, this.Xr = null
    }
    static ei(e) {
        return new Bm(e)
    }
    get ti() {
        if (this.Xr) return this.Xr;
        throw Y()
    }
    addReference(e, n, r) {
        return this.Zr.addReference(r, n), this.ti.delete(r.toString()), F.resolve()
    }
    removeReference(e, n, r) {
        return this.Zr.removeReference(r, n), this.ti.add(r.toString()), F.resolve()
    }
    markPotentiallyOrphaned(e, n) {
        return this.ti.add(n.toString()), F.resolve()
    }
    removeTarget(e, n) {
        this.Zr.yr(n.targetId).forEach(i => this.ti.add(i.toString()));
        const r = this.persistence.getTargetCache();
        return r.getMatchingKeysForTargetId(e, n.targetId).next(i => {
            i.forEach(s => this.ti.add(s.toString()))
        }).next(() => r.removeTargetData(e, n))
    }
    Hr() {
        this.Xr = new Set
    }
    Jr(e) {
        const n = this.persistence.getRemoteDocumentCache().newChangeBuffer();
        return F.forEach(this.ti, r => {
            const i = H.fromPath(r);
            return this.ni(e, i).next(s => {
                s || n.removeEntry(i, J.min())
            })
        }).next(() => (this.Xr = null, n.apply(e)))
    }
    updateLimboDocument(e, n) {
        return this.ni(e, n).next(r => {
            r ? this.ti.delete(n.toString()) : this.ti.add(n.toString())
        })
    }
    zr(e) {
        return 0
    }
    ni(e, n) {
        return F.or([() => F.resolve(this.Zr.containsKey(n)), () => this.persistence.getTargetCache().containsKey(e, n), () => this.persistence.Yr(e, n)])
    }
}
class tc {
    constructor(e, n) {
        this.persistence = e, this.ri = new Mi(r => PD(r.path), (r, i) => r.isEqual(i)), this.garbageCollector = LV(this, n)
    }
    static ei(e, n) {
        return new tc(e, n)
    }
    Hr() {}
    Jr(e) {
        return F.resolve()
    }
    forEachTarget(e, n) {
        return this.persistence.getTargetCache().forEachTarget(e, n)
    }
    Xn(e) {
        const n = this.nr(e);
        return this.persistence.getTargetCache().getTargetCount(e).next(r => n.next(i => r + i))
    }
    nr(e) {
        let n = 0;
        return this.er(e, r => {
            n++
        }).next(() => n)
    }
    er(e, n) {
        return F.forEach(this.ri, (r, i) => this.ir(e, r, i).next(s => s ? F.resolve() : n(i)))
    }
    removeTargets(e, n, r) {
        return this.persistence.getTargetCache().removeTargets(e, n, r)
    }
    removeOrphanedDocuments(e, n) {
        let r = 0;
        const i = this.persistence.getRemoteDocumentCache(),
            s = i.newChangeBuffer();
        return i.Lr(e, o => this.ir(e, o, n).next(a => {
            a || (r++, s.removeEntry(o, J.min()))
        })).next(() => s.apply(e)).next(() => r)
    }
    markPotentiallyOrphaned(e, n) {
        return this.ri.set(n, e.currentSequenceNumber), F.resolve()
    }
    removeTarget(e, n) {
        const r = n.withSequenceNumber(e.currentSequenceNumber);
        return this.persistence.getTargetCache().updateTargetData(e, r)
    }
    addReference(e, n, r) {
        return this.ri.set(r, e.currentSequenceNumber), F.resolve()
    }
    removeReference(e, n, r) {
        return this.ri.set(r, e.currentSequenceNumber), F.resolve()
    }
    updateLimboDocument(e, n) {
        return this.ri.set(n, e.currentSequenceNumber), F.resolve()
    }
    zr(e) {
        let n = e.key.toString().length;
        return e.isFoundDocument() && (n += lu(e.data.value)), n
    }
    ir(e, n, r) {
        return F.or([() => this.persistence.Yr(e, n), () => this.persistence.getTargetCache().containsKey(e, n), () => {
            const i = this.ri.get(n);
            return F.resolve(i !== void 0 && i > r)
        }])
    }
    getCacheSize(e) {
        return this.persistence.getRemoteDocumentCache().getSize(e)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $m {
    constructor(e, n, r, i) {
        this.targetId = e, this.fromCache = n, this.Wi = r, this.Gi = i
    }
    static zi(e, n) {
        let r = ne(),
            i = ne();
        for (const s of n.docChanges) switch (s.type) {
            case 0:
                r = r.add(s.doc.key);
                break;
            case 1:
                i = i.add(s.doc.key)
        }
        return new $m(e, n.fromCache, r, i)
    }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GV {
    constructor() {
        this._documentReadCount = 0
    }
    get documentReadCount() {
        return this._documentReadCount
    }
    incrementDocumentReadCount(e) {
        this._documentReadCount += e
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class QV {
    constructor() {
        this.ji = !1, this.Hi = !1, this.Ji = 100, this.Yi = function() {
            return Px() ? 8 : SD(pt()) > 0 ? 6 : 4
        }()
    }
    initialize(e, n) {
        this.Zi = e, this.indexManager = n, this.ji = !0
    }
    getDocumentsMatchingQuery(e, n, r, i) {
        const s = {
            result: null
        };
        return this.Xi(e, n).next(o => {
            s.result = o
        }).next(() => {
            if (!s.result) return this.es(e, n, i, r).next(o => {
                s.result = o
            })
        }).next(() => {
            if (s.result) return;
            const o = new GV;
            return this.ts(e, n, o).next(a => {
                if (s.result = a, this.Hi) return this.ns(e, n, o, a.size)
            })
        }).next(() => s.result)
    }
    ns(e, n, r, i) {
        return r.documentReadCount < this.Ji ? (Qi() <= te.DEBUG && W("QueryEngine", "SDK will not create cache indexes for query:", Yi(n), "since it only creates cache indexes for collection contains", "more than or equal to", this.Ji, "documents"), F.resolve()) : (Qi() <= te.DEBUG && W("QueryEngine", "Query:", Yi(n), "scans", r.documentReadCount, "local documents and returns", i, "documents as results."), r.documentReadCount > this.Yi * i ? (Qi() <= te.DEBUG && W("QueryEngine", "The SDK decides to create cache indexes for query:", Yi(n), "as using cache indexes may help improve performance."), this.indexManager.createTargetIndexes(e, wn(n))) : F.resolve())
    }
    Xi(e, n) {
        if ($_(n)) return F.resolve(null);
        let r = wn(n);
        return this.indexManager.getIndexType(e, r).next(i => i === 0 ? null : (n.limit !== null && i === 1 && (n = Xu(n, null, "F"), r = wn(n)), this.indexManager.getDocumentsMatchingTarget(e, r).next(s => {
            const o = ne(...s);
            return this.Zi.getDocuments(e, o).next(a => this.indexManager.getMinOffset(e, r).next(u => {
                const c = this.rs(n, a);
                return this.ss(n, c, o, u.readTime) ? this.Xi(e, Xu(n, null, "F")) : this.os(e, c, n, u)
            }))
        })))
    }
    es(e, n, r, i) {
        return $_(n) || i.isEqual(J.min()) ? F.resolve(null) : this.Zi.getDocuments(e, r).next(s => {
            const o = this.rs(n, s);
            return this.ss(n, o, r, i) ? F.resolve(null) : (Qi() <= te.DEBUG && W("QueryEngine", "Re-using previous result from %s to execute query: %s", i.toString(), Yi(n)), this.os(e, o, n, _D(i, -1)).next(a => a))
        })
    }
    rs(e, n) {
        let r = new Ue(AS(e));
        return n.forEach((i, s) => {
            Gc(e, s) && (r = r.add(s))
        }), r
    }
    ss(e, n, r, i) {
        if (e.limit === null) return !1;
        if (r.size !== n.size) return !0;
        const s = e.limitType === "F" ? n.last() : n.first();
        return !!s && (s.hasPendingWrites || s.version.compareTo(i) > 0)
    }
    ts(e, n, r) {
        return Qi() <= te.DEBUG && W("QueryEngine", "Using full collection scan to execute query:", Yi(n)), this.Zi.getDocumentsMatchingQuery(e, n, Ur.min(), r)
    }
    os(e, n, r, i) {
        return this.Zi.getDocumentsMatchingQuery(e, r, i).next(s => (n.forEach(o => {
            s = s.insert(o.key, o)
        }), s))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class YV {
    constructor(e, n, r, i) {
        this.persistence = e, this._s = n, this.serializer = i, this.us = new Ae(re), this.cs = new Mi(s => Nm(s), Dm), this.ls = new Map, this.hs = e.getRemoteDocumentCache(), this.Gr = e.getTargetCache(), this.jr = e.getBundleCache(), this.Ps(r)
    }
    Ps(e) {
        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e), this.indexManager = this.persistence.getIndexManager(e), this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager), this.localDocuments = new UV(this.hs, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.hs.setIndexManager(this.indexManager), this._s.initialize(this.localDocuments, this.indexManager)
    }
    collectGarbage(e) {
        return this.persistence.runTransaction("Collect garbage", "readwrite-primary", n => e.collect(n, this.us))
    }
}

function XV(t, e, n, r) {
    return new YV(t, e, n, r)
}
async function KS(t, e) {
    const n = Z(t);
    return await n.persistence.runTransaction("Handle user change", "readonly", r => {
        let i;
        return n.mutationQueue.getAllMutationBatches(r).next(s => (i = s, n.Ps(e), n.mutationQueue.getAllMutationBatches(r))).next(s => {
            const o = [],
                a = [];
            let u = ne();
            for (const c of i) {
                o.push(c.batchId);
                for (const h of c.mutations) u = u.add(h.key)
            }
            for (const c of s) {
                a.push(c.batchId);
                for (const h of c.mutations) u = u.add(h.key)
            }
            return n.localDocuments.getDocuments(r, u).next(c => ({
                Ts: c,
                removedBatchIds: o,
                addedBatchIds: a
            }))
        })
    })
}

function JV(t, e) {
    const n = Z(t);
    return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", r => {
        const i = e.batch.keys(),
            s = n.hs.newChangeBuffer({
                trackRemovals: !0
            });
        return function(a, u, c, h) {
            const f = c.batch,
                m = f.keys();
            let _ = F.resolve();
            return m.forEach(I => {
                _ = _.next(() => h.getEntry(u, I)).next(R => {
                    const k = c.docVersions.get(I);
                    ae(k !== null), R.version.compareTo(k) < 0 && (f.applyToRemoteDocument(R, c), R.isValidDocument() && (R.setReadTime(c.commitVersion), h.addEntry(R)))
                })
            }), _.next(() => a.mutationQueue.removeMutationBatch(u, f))
        }(n, r, e, s).next(() => s.apply(r)).next(() => n.mutationQueue.performConsistencyCheck(r)).next(() => n.documentOverlayCache.removeOverlaysForBatchId(r, i, e.batch.batchId)).next(() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(r, function(a) {
            let u = ne();
            for (let c = 0; c < a.mutationResults.length; ++c) a.mutationResults[c].transformResults.length > 0 && (u = u.add(a.batch.mutations[c].key));
            return u
        }(e))).next(() => n.localDocuments.getDocuments(r, i))
    })
}

function GS(t) {
    const e = Z(t);
    return e.persistence.runTransaction("Get last remote snapshot version", "readonly", n => e.Gr.getLastRemoteSnapshotVersion(n))
}

function ZV(t, e) {
    const n = Z(t),
        r = e.snapshotVersion;
    let i = n.us;
    return n.persistence.runTransaction("Apply remote event", "readwrite-primary", s => {
        const o = n.hs.newChangeBuffer({
            trackRemovals: !0
        });
        i = n.us;
        const a = [];
        e.targetChanges.forEach((h, f) => {
            const m = i.get(f);
            if (!m) return;
            a.push(n.Gr.removeMatchingKeys(s, h.removedDocuments, f).next(() => n.Gr.addMatchingKeys(s, h.addedDocuments, f)));
            let _ = m.withSequenceNumber(s.currentSequenceNumber);
            e.targetMismatches.get(f) !== null ? _ = _.withResumeToken(Xe.EMPTY_BYTE_STRING, J.min()).withLastLimboFreeSnapshotVersion(J.min()) : h.resumeToken.approximateByteSize() > 0 && (_ = _.withResumeToken(h.resumeToken, r)), i = i.insert(f, _),
                function(R, k, w) {
                    return R.resumeToken.approximateByteSize() === 0 || k.snapshotVersion.toMicroseconds() - R.snapshotVersion.toMicroseconds() >= 3e8 ? !0 : w.addedDocuments.size + w.modifiedDocuments.size + w.removedDocuments.size > 0
                }(m, _, h) && a.push(n.Gr.updateTargetData(s, _))
        });
        let u = er(),
            c = ne();
        if (e.documentUpdates.forEach(h => {
                e.resolvedLimboDocuments.has(h) && a.push(n.persistence.referenceDelegate.updateLimboDocument(s, h))
            }), a.push(eO(s, o, e.documentUpdates).next(h => {
                u = h.Is, c = h.Es
            })), !r.isEqual(J.min())) {
            const h = n.Gr.getLastRemoteSnapshotVersion(s).next(f => n.Gr.setTargetsMetadata(s, s.currentSequenceNumber, r));
            a.push(h)
        }
        return F.waitFor(a).next(() => o.apply(s)).next(() => n.localDocuments.getLocalViewOfDocuments(s, u, c)).next(() => u)
    }).then(s => (n.us = i, s))
}

function eO(t, e, n) {
    let r = ne(),
        i = ne();
    return n.forEach(s => r = r.add(s)), e.getEntries(t, r).next(s => {
        let o = er();
        return n.forEach((a, u) => {
            const c = s.get(a);
            u.isFoundDocument() !== c.isFoundDocument() && (i = i.add(a)), u.isNoDocument() && u.version.isEqual(J.min()) ? (e.removeEntry(a, u.readTime), o = o.insert(a, u)) : !c.isValidDocument() || u.version.compareTo(c.version) > 0 || u.version.compareTo(c.version) === 0 && c.hasPendingWrites ? (e.addEntry(u), o = o.insert(a, u)) : W("LocalStore", "Ignoring outdated watch update for ", a, ". Current version:", c.version, " Watch version:", u.version)
        }), {
            Is: o,
            Es: i
        }
    })
}

function tO(t, e) {
    const n = Z(t);
    return n.persistence.runTransaction("Get next mutation batch", "readonly", r => (e === void 0 && (e = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(r, e)))
}

function nO(t, e) {
    const n = Z(t);
    return n.persistence.runTransaction("Allocate target", "readwrite", r => {
        let i;
        return n.Gr.getTargetData(r, e).next(s => s ? (i = s, F.resolve(i)) : n.Gr.allocateTargetId(r).next(o => (i = new Ar(e, o, "TargetPurposeListen", r.currentSequenceNumber), n.Gr.addTargetData(r, i).next(() => i))))
    }).then(r => {
        const i = n.us.get(r.targetId);
        return (i === null || r.snapshotVersion.compareTo(i.snapshotVersion) > 0) && (n.us = n.us.insert(r.targetId, r), n.cs.set(e, r.targetId)), r
    })
}
async function Zf(t, e, n) {
    const r = Z(t),
        i = r.us.get(e),
        s = n ? "readwrite" : "readwrite-primary";
    try {
        n || await r.persistence.runTransaction("Release target", s, o => r.persistence.referenceDelegate.removeTarget(o, i))
    } catch (o) {
        if (!Ys(o)) throw o;
        W("LocalStore", `Failed to update sequence numbers for target ${e}: ${o}`)
    }
    r.us = r.us.remove(e), r.cs.delete(i.target)
}

function e0(t, e, n) {
    const r = Z(t);
    let i = J.min(),
        s = ne();
    return r.persistence.runTransaction("Execute query", "readwrite", o => function(u, c, h) {
        const f = Z(u),
            m = f.cs.get(h);
        return m !== void 0 ? F.resolve(f.us.get(m)) : f.Gr.getTargetData(c, h)
    }(r, o, wn(e)).next(a => {
        if (a) return i = a.lastLimboFreeSnapshotVersion, r.Gr.getMatchingKeysForTargetId(o, a.targetId).next(u => {
            s = u
        })
    }).next(() => r._s.getDocumentsMatchingQuery(o, e, n ? i : J.min(), n ? s : ne())).next(a => (rO(r, WD(e), a), {
        documents: a,
        ds: s
    })))
}

function rO(t, e, n) {
    let r = t.ls.get(e) || J.min();
    n.forEach((i, s) => {
        s.readTime.compareTo(r) > 0 && (r = s.readTime)
    }), t.ls.set(e, r)
}
class t0 {
    constructor() {
        this.activeTargetIds = YD()
    }
    ps(e) {
        this.activeTargetIds = this.activeTargetIds.add(e)
    }
    ys(e) {
        this.activeTargetIds = this.activeTargetIds.delete(e)
    }
    gs() {
        const e = {
            activeTargetIds: this.activeTargetIds.toArray(),
            updateTimeMs: Date.now()
        };
        return JSON.stringify(e)
    }
}
class iO {
    constructor() {
        this._o = new t0, this.ao = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null
    }
    addPendingMutation(e) {}
    updateMutationState(e, n, r) {}
    addLocalQueryTarget(e, n = !0) {
        return n && this._o.ps(e), this.ao[e] || "not-current"
    }
    updateQueryState(e, n, r) {
        this.ao[e] = n
    }
    removeLocalQueryTarget(e) {
        this._o.ys(e)
    }
    isLocalQueryTarget(e) {
        return this._o.activeTargetIds.has(e)
    }
    clearQueryState(e) {
        delete this.ao[e]
    }
    getAllActiveQueryTargets() {
        return this._o.activeTargetIds
    }
    isActiveQueryTarget(e) {
        return this._o.activeTargetIds.has(e)
    }
    start() {
        return this._o = new t0, Promise.resolve()
    }
    handleUserChange(e, n, r) {}
    setOnlineState(e) {}
    shutdown() {}
    writeSequenceNumber(e) {}
    notifyBundleLoaded(e) {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sO {
    uo(e) {}
    shutdown() {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class n0 {
    constructor() {
        this.co = () => this.lo(), this.ho = () => this.Po(), this.To = [], this.Io()
    }
    uo(e) {
        this.To.push(e)
    }
    shutdown() {
        window.removeEventListener("online", this.co), window.removeEventListener("offline", this.ho)
    }
    Io() {
        window.addEventListener("online", this.co), window.addEventListener("offline", this.ho)
    }
    lo() {
        W("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
        for (const e of this.To) e(0)
    }
    Po() {
        W("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
        for (const e of this.To) e(1)
    }
    static p() {
        return typeof window < "u" && window.addEventListener !== void 0 && window.removeEventListener !== void 0
    }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let $l = null;

function wd() {
    return $l === null ? $l = function() {
        return 268435456 + Math.round(2147483648 * Math.random())
    }() : $l++, "0x" + $l.toString(16)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const oO = {
    BatchGetDocuments: "batchGet",
    Commit: "commit",
    RunQuery: "runQuery",
    RunAggregationQuery: "runAggregationQuery"
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class aO {
    constructor(e) {
        this.Eo = e.Eo, this.Ao = e.Ao
    }
    Ro(e) {
        this.Vo = e
    }
    mo(e) {
        this.fo = e
    }
    po(e) {
        this.yo = e
    }
    onMessage(e) {
        this.wo = e
    }
    close() {
        this.Ao()
    }
    send(e) {
        this.Eo(e)
    }
    So() {
        this.Vo()
    }
    bo() {
        this.fo()
    }
    Do(e) {
        this.yo(e)
    }
    vo(e) {
        this.wo(e)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const it = "WebChannelConnection";
class lO extends class {
    get Co() {
        return !1
    }
    constructor(n) {
        this.databaseInfo = n, this.databaseId = n.databaseId;
        const r = n.ssl ? "https" : "http",
            i = encodeURIComponent(this.databaseId.projectId),
            s = encodeURIComponent(this.databaseId.database);
        this.Fo = r + "://" + n.host, this.Mo = `projects/${i}/databases/${s}`, this.xo = this.databaseId.database === "(default)" ? `project_id=${i}` : `project_id=${i}&database_id=${s}`
    }
    Oo(n, r, i, s, o) {
        const a = wd(),
            u = this.No(n, r.toUriEncodedString());
        W("RestConnection", `Sending RPC '${n}' ${a}:`, u, i);
        const c = {
            "google-cloud-resource-prefix": this.Mo,
            "x-goog-request-params": this.xo
        };
        return this.Lo(c, s, o), this.Bo(n, u, c, i).then(h => (W("RestConnection", `Received RPC '${n}' ${a}: `, h), h), h => {
            throw Vs("RestConnection", `RPC '${n}' ${a} failed with error: `, h, "url: ", u, "request:", i), h
        })
    }
    ko(n, r, i, s, o, a) {
        return this.Oo(n, r, i, s, o)
    }
    Lo(n, r, i) {
        n["X-Goog-Api-Client"] = function() {
            return "gl-js/ fire/" + Gs
        }(), n["Content-Type"] = "text/plain", this.databaseInfo.appId && (n["X-Firebase-GMPID"] = this.databaseInfo.appId), r && r.headers.forEach((s, o) => n[o] = s), i && i.headers.forEach((s, o) => n[o] = s)
    }
    No(n, r) {
        const i = oO[n];
        return `${this.Fo}/v1/${r}:${i}`
    }
    terminate() {}
} {
    constructor(e) {
        super(e), this.forceLongPolling = e.forceLongPolling, this.autoDetectLongPolling = e.autoDetectLongPolling, this.useFetchStreams = e.useFetchStreams, this.longPollingOptions = e.longPollingOptions
    }
    Bo(e, n, r, i) {
        const s = wd();
        return new Promise((o, a) => {
            const u = new aS;
            u.setWithCredentials(!0), u.listenOnce(lS.COMPLETE, () => {
                try {
                    switch (u.getLastErrorCode()) {
                        case au.NO_ERROR:
                            const h = u.getResponseJson();
                            W(it, `XHR for RPC '${e}' ${s} received:`, JSON.stringify(h)), o(h);
                            break;
                        case au.TIMEOUT:
                            W(it, `RPC '${e}' ${s} timed out`), a(new z(L.DEADLINE_EXCEEDED, "Request time out"));
                            break;
                        case au.HTTP_ERROR:
                            const f = u.getStatus();
                            if (W(it, `RPC '${e}' ${s} failed with status:`, f, "response text:", u.getResponseText()), f > 0) {
                                let m = u.getResponseJson();
                                Array.isArray(m) && (m = m[0]);
                                const _ = m == null ? void 0 : m.error;
                                if (_ && _.status && _.message) {
                                    const I = function(k) {
                                        const w = k.toLowerCase().replace(/_/g, "-");
                                        return Object.values(L).indexOf(w) >= 0 ? w : L.UNKNOWN
                                    }(_.status);
                                    a(new z(I, _.message))
                                } else a(new z(L.UNKNOWN, "Server responded with status " + u.getStatus()))
                            } else a(new z(L.UNAVAILABLE, "Connection failed."));
                            break;
                        default:
                            Y()
                    }
                } finally {
                    W(it, `RPC '${e}' ${s} completed.`)
                }
            });
            const c = JSON.stringify(i);
            W(it, `RPC '${e}' ${s} sending request:`, i), u.send(n, "POST", c, r, 15)
        })
    }
    qo(e, n, r) {
        const i = wd(),
            s = [this.Fo, "/", "google.firestore.v1.Firestore", "/", e, "/channel"],
            o = hS(),
            a = cS(),
            u = {
                httpSessionIdParam: "gsessionid",
                initMessageHeaders: {},
                messageUrlParams: {
                    database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
                },
                sendRawJson: !0,
                supportsCrossDomainXhr: !0,
                internalChannelParams: {
                    forwardChannelRequestTimeoutMs: 6e5
                },
                forceLongPolling: this.forceLongPolling,
                detectBufferingProxy: this.autoDetectLongPolling
            },
            c = this.longPollingOptions.timeoutSeconds;
        c !== void 0 && (u.longPollingTimeout = Math.round(1e3 * c)), this.useFetchStreams && (u.useFetchStreams = !0), this.Lo(u.initMessageHeaders, n, r), u.encodeInitMessageHeaders = !0;
        const h = s.join("");
        W(it, `Creating RPC '${e}' stream ${i}: ${h}`, u);
        const f = o.createWebChannel(h, u);
        let m = !1,
            _ = !1;
        const I = new aO({
                Eo: k => {
                    _ ? W(it, `Not sending because RPC '${e}' stream ${i} is closed:`, k) : (m || (W(it, `Opening RPC '${e}' stream ${i} transport.`), f.open(), m = !0), W(it, `RPC '${e}' stream ${i} sending:`, k), f.send(k))
                },
                Ao: () => f.close()
            }),
            R = (k, w, v) => {
                k.listen(w, T => {
                    try {
                        v(T)
                    } catch (x) {
                        setTimeout(() => {
                            throw x
                        }, 0)
                    }
                })
            };
        return R(f, Do.EventType.OPEN, () => {
            _ || (W(it, `RPC '${e}' stream ${i} transport opened.`), I.So())
        }), R(f, Do.EventType.CLOSE, () => {
            _ || (_ = !0, W(it, `RPC '${e}' stream ${i} transport closed`), I.Do())
        }), R(f, Do.EventType.ERROR, k => {
            _ || (_ = !0, Vs(it, `RPC '${e}' stream ${i} transport errored:`, k), I.Do(new z(L.UNAVAILABLE, "The operation could not be completed")))
        }), R(f, Do.EventType.MESSAGE, k => {
            var w;
            if (!_) {
                const v = k.data[0];
                ae(!!v);
                const T = v,
                    x = (T == null ? void 0 : T.error) || ((w = T[0]) === null || w === void 0 ? void 0 : w.error);
                if (x) {
                    W(it, `RPC '${e}' stream ${i} received error:`, x);
                    const O = x.status;
                    let U = function(E) {
                            const A = Ne[E];
                            if (A !== void 0) return LS(A)
                        }(O),
                        S = x.message;
                    U === void 0 && (U = L.INTERNAL, S = "Unknown error status: " + O + " with message " + x.message), _ = !0, I.Do(new z(U, S)), f.close()
                } else W(it, `RPC '${e}' stream ${i} received:`, v), I.vo(v)
            }
        }), R(a, uS.STAT_EVENT, k => {
            k.stat === zf.PROXY ? W(it, `RPC '${e}' stream ${i} detected buffering proxy`) : k.stat === zf.NOPROXY && W(it, `RPC '${e}' stream ${i} detected no buffering proxy`)
        }), setTimeout(() => {
            I.bo()
        }, 0), I
    }
}

function Td() {
    return typeof document < "u" ? document : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Jc(t) {
    return new mV(t, !0)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class QS {
    constructor(e, n, r = 1e3, i = 1.5, s = 6e4) {
        this.li = e, this.timerId = n, this.Qo = r, this.Ko = i, this.$o = s, this.Uo = 0, this.Wo = null, this.Go = Date.now(), this.reset()
    }
    reset() {
        this.Uo = 0
    }
    zo() {
        this.Uo = this.$o
    }
    jo(e) {
        this.cancel();
        const n = Math.floor(this.Uo + this.Ho()),
            r = Math.max(0, Date.now() - this.Go),
            i = Math.max(0, n - r);
        i > 0 && W("ExponentialBackoff", `Backing off for ${i} ms (base delay: ${this.Uo} ms, delay with jitter: ${n} ms, last attempt: ${r} ms ago)`), this.Wo = this.li.enqueueAfterDelay(this.timerId, i, () => (this.Go = Date.now(), e())), this.Uo *= this.Ko, this.Uo < this.Qo && (this.Uo = this.Qo), this.Uo > this.$o && (this.Uo = this.$o)
    }
    Jo() {
        this.Wo !== null && (this.Wo.skipDelay(), this.Wo = null)
    }
    cancel() {
        this.Wo !== null && (this.Wo.cancel(), this.Wo = null)
    }
    Ho() {
        return (Math.random() - .5) * this.Uo
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class YS {
    constructor(e, n, r, i, s, o, a, u) {
        this.li = e, this.Yo = r, this.Zo = i, this.connection = s, this.authCredentialsProvider = o, this.appCheckCredentialsProvider = a, this.listener = u, this.state = 0, this.Xo = 0, this.e_ = null, this.t_ = null, this.stream = null, this.n_ = 0, this.r_ = new QS(e, n)
    }
    i_() {
        return this.state === 1 || this.state === 5 || this.s_()
    }
    s_() {
        return this.state === 2 || this.state === 3
    }
    start() {
        this.n_ = 0, this.state !== 4 ? this.auth() : this.o_()
    }
    async stop() {
        this.i_() && await this.close(0)
    }
    __() {
        this.state = 0, this.r_.reset()
    }
    a_() {
        this.s_() && this.e_ === null && (this.e_ = this.li.enqueueAfterDelay(this.Yo, 6e4, () => this.u_()))
    }
    c_(e) {
        this.l_(), this.stream.send(e)
    }
    async u_() {
        if (this.s_()) return this.close(0)
    }
    l_() {
        this.e_ && (this.e_.cancel(), this.e_ = null)
    }
    h_() {
        this.t_ && (this.t_.cancel(), this.t_ = null)
    }
    async close(e, n) {
        this.l_(), this.h_(), this.r_.cancel(), this.Xo++, e !== 4 ? this.r_.reset() : n && n.code === L.RESOURCE_EXHAUSTED ? (Zn(n.toString()), Zn("Using maximum backoff delay to prevent overloading the backend."), this.r_.zo()) : n && n.code === L.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.P_(), this.stream.close(), this.stream = null), this.state = e, await this.listener.po(n)
    }
    P_() {}
    auth() {
        this.state = 1;
        const e = this.T_(this.Xo),
            n = this.Xo;
        Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([r, i]) => {
            this.Xo === n && this.I_(r, i)
        }, r => {
            e(() => {
                const i = new z(L.UNKNOWN, "Fetching auth token failed: " + r.message);
                return this.E_(i)
            })
        })
    }
    I_(e, n) {
        const r = this.T_(this.Xo);
        this.stream = this.d_(e, n), this.stream.Ro(() => {
            r(() => this.listener.Ro())
        }), this.stream.mo(() => {
            r(() => (this.state = 2, this.t_ = this.li.enqueueAfterDelay(this.Zo, 1e4, () => (this.s_() && (this.state = 3), Promise.resolve())), this.listener.mo()))
        }), this.stream.po(i => {
            r(() => this.E_(i))
        }), this.stream.onMessage(i => {
            r(() => ++this.n_ == 1 ? this.A_(i) : this.onNext(i))
        })
    }
    o_() {
        this.state = 5, this.r_.jo(async () => {
            this.state = 0, this.start()
        })
    }
    E_(e) {
        return W("PersistentStream", `close with error: ${e}`), this.stream = null, this.close(4, e)
    }
    T_(e) {
        return n => {
            this.li.enqueueAndForget(() => this.Xo === e ? n() : (W("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()))
        }
    }
}
class uO extends YS {
    constructor(e, n, r, i, s, o) {
        super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", n, r, i, o), this.serializer = s
    }
    d_(e, n) {
        return this.connection.qo("Listen", e, n)
    }
    A_(e) {
        return this.onNext(e)
    }
    onNext(e) {
        this.r_.reset();
        const n = vV(this.serializer, e),
            r = function(s) {
                if (!("targetChange" in s)) return J.min();
                const o = s.targetChange;
                return o.targetIds && o.targetIds.length ? J.min() : o.readTime ? Tn(o.readTime) : J.min()
            }(e);
        return this.listener.R_(n, r)
    }
    V_(e) {
        const n = {};
        n.database = Jf(this.serializer), n.addTarget = function(s, o) {
            let a;
            const u = o.target;
            if (a = Kf(u) ? {
                    documents: TV(s, u)
                } : {
                    query: EV(s, u).ct
                }, a.targetId = o.targetId, o.resumeToken.approximateByteSize() > 0) {
                a.resumeToken = US(s, o.resumeToken);
                const c = Qf(s, o.expectedCount);
                c !== null && (a.expectedCount = c)
            } else if (o.snapshotVersion.compareTo(J.min()) > 0) {
                a.readTime = ec(s, o.snapshotVersion.toTimestamp());
                const c = Qf(s, o.expectedCount);
                c !== null && (a.expectedCount = c)
            }
            return a
        }(this.serializer, e);
        const r = SV(this.serializer, e);
        r && (n.labels = r), this.c_(n)
    }
    m_(e) {
        const n = {};
        n.database = Jf(this.serializer), n.removeTarget = e, this.c_(n)
    }
}
class cO extends YS {
    constructor(e, n, r, i, s, o) {
        super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", n, r, i, o), this.serializer = s
    }
    get f_() {
        return this.n_ > 0
    }
    start() {
        this.lastStreamToken = void 0, super.start()
    }
    P_() {
        this.f_ && this.g_([])
    }
    d_(e, n) {
        return this.connection.qo("Write", e, n)
    }
    A_(e) {
        return ae(!!e.streamToken), this.lastStreamToken = e.streamToken, ae(!e.writeResults || e.writeResults.length === 0), this.listener.p_()
    }
    onNext(e) {
        ae(!!e.streamToken), this.lastStreamToken = e.streamToken, this.r_.reset();
        const n = wV(e.writeResults, e.commitTime),
            r = Tn(e.commitTime);
        return this.listener.y_(r, n)
    }
    w_() {
        const e = {};
        e.database = Jf(this.serializer), this.c_(e)
    }
    g_(e) {
        const n = {
            streamToken: this.lastStreamToken,
            writes: e.map(r => _V(this.serializer, r))
        };
        this.c_(n)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hO extends class {} {
    constructor(e, n, r, i) {
        super(), this.authCredentials = e, this.appCheckCredentials = n, this.connection = r, this.serializer = i, this.S_ = !1
    }
    b_() {
        if (this.S_) throw new z(L.FAILED_PRECONDITION, "The client has already been terminated.")
    }
    Oo(e, n, r, i) {
        return this.b_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, o]) => this.connection.Oo(e, Yf(n, r), i, s, o)).catch(s => {
            throw s.name === "FirebaseError" ? (s.code === L.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), s) : new z(L.UNKNOWN, s.toString())
        })
    }
    ko(e, n, r, i, s) {
        return this.b_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([o, a]) => this.connection.ko(e, Yf(n, r), i, o, a, s)).catch(o => {
            throw o.name === "FirebaseError" ? (o.code === L.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), o) : new z(L.UNKNOWN, o.toString())
        })
    }
    terminate() {
        this.S_ = !0, this.connection.terminate()
    }
}
class dO {
    constructor(e, n) {
        this.asyncQueue = e, this.onlineStateHandler = n, this.state = "Unknown", this.D_ = 0, this.v_ = null, this.C_ = !0
    }
    F_() {
        this.D_ === 0 && (this.M_("Unknown"), this.v_ = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.v_ = null, this.x_("Backend didn't respond within 10 seconds."), this.M_("Offline"), Promise.resolve())))
    }
    O_(e) {
        this.state === "Online" ? this.M_("Unknown") : (this.D_++, this.D_ >= 1 && (this.N_(), this.x_(`Connection failed 1 times. Most recent error: ${e.toString()}`), this.M_("Offline")))
    }
    set(e) {
        this.N_(), this.D_ = 0, e === "Online" && (this.C_ = !1), this.M_(e)
    }
    M_(e) {
        e !== this.state && (this.state = e, this.onlineStateHandler(e))
    }
    x_(e) {
        const n = `Could not reach Cloud Firestore backend. ${e}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
        this.C_ ? (Zn(n), this.C_ = !1) : W("OnlineStateTracker", n)
    }
    N_() {
        this.v_ !== null && (this.v_.cancel(), this.v_ = null)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fO {
    constructor(e, n, r, i, s) {
        this.localStore = e, this.datastore = n, this.asyncQueue = r, this.remoteSyncer = {}, this.L_ = [], this.B_ = new Map, this.k_ = new Set, this.q_ = [], this.Q_ = s, this.Q_.uo(o => {
            r.enqueueAndForget(async () => {
                Fi(this) && (W("RemoteStore", "Restarting streams for network reachability change."), await async function(u) {
                    const c = Z(u);
                    c.k_.add(4), await Ga(c), c.K_.set("Unknown"), c.k_.delete(4), await Zc(c)
                }(this))
            })
        }), this.K_ = new dO(r, i)
    }
}
async function Zc(t) {
    if (Fi(t))
        for (const e of t.q_) await e(!0)
}
async function Ga(t) {
    for (const e of t.q_) await e(!1)
}

function XS(t, e) {
    const n = Z(t);
    n.B_.has(e.targetId) || (n.B_.set(e.targetId, e), Hm(n) ? qm(n) : Js(n).s_() && Wm(n, e))
}

function zm(t, e) {
    const n = Z(t),
        r = Js(n);
    n.B_.delete(e), r.s_() && JS(n, e), n.B_.size === 0 && (r.s_() ? r.a_() : Fi(n) && n.K_.set("Unknown"))
}

function Wm(t, e) {
    if (t.U_.xe(e.targetId), e.resumeToken.approximateByteSize() > 0 || e.snapshotVersion.compareTo(J.min()) > 0) {
        const n = t.remoteSyncer.getRemoteKeysForTarget(e.targetId).size;
        e = e.withExpectedCount(n)
    }
    Js(t).V_(e)
}

function JS(t, e) {
    t.U_.xe(e), Js(t).m_(e)
}

function qm(t) {
    t.U_ = new hV({
        getRemoteKeysForTarget: e => t.remoteSyncer.getRemoteKeysForTarget(e),
        ut: e => t.B_.get(e) || null,
        nt: () => t.datastore.serializer.databaseId
    }), Js(t).start(), t.K_.F_()
}

function Hm(t) {
    return Fi(t) && !Js(t).i_() && t.B_.size > 0
}

function Fi(t) {
    return Z(t).k_.size === 0
}

function ZS(t) {
    t.U_ = void 0
}
async function pO(t) {
    t.K_.set("Online")
}
async function mO(t) {
    t.B_.forEach((e, n) => {
        Wm(t, e)
    })
}
async function gO(t, e) {
    ZS(t), Hm(t) ? (t.K_.O_(e), qm(t)) : t.K_.set("Unknown")
}
async function yO(t, e, n) {
    if (t.K_.set("Online"), e instanceof FS && e.state === 2 && e.cause) try {
        await async function(i, s) {
            const o = s.cause;
            for (const a of s.targetIds) i.B_.has(a) && (await i.remoteSyncer.rejectListen(a, o), i.B_.delete(a), i.U_.removeTarget(a))
        }(t, e)
    } catch (r) {
        W("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), r), await nc(t, r)
    } else if (e instanceof hu ? t.U_.$e(e) : e instanceof MS ? t.U_.Je(e) : t.U_.Ge(e), !n.isEqual(J.min())) try {
        const r = await GS(t.localStore);
        n.compareTo(r) >= 0 && await
        function(s, o) {
            const a = s.U_.it(o);
            return a.targetChanges.forEach((u, c) => {
                if (u.resumeToken.approximateByteSize() > 0) {
                    const h = s.B_.get(c);
                    h && s.B_.set(c, h.withResumeToken(u.resumeToken, o))
                }
            }), a.targetMismatches.forEach((u, c) => {
                const h = s.B_.get(u);
                if (!h) return;
                s.B_.set(u, h.withResumeToken(Xe.EMPTY_BYTE_STRING, h.snapshotVersion)), JS(s, u);
                const f = new Ar(h.target, u, c, h.sequenceNumber);
                Wm(s, f)
            }), s.remoteSyncer.applyRemoteEvent(a)
        }(t, n)
    } catch (r) {
        W("RemoteStore", "Failed to raise snapshot:", r), await nc(t, r)
    }
}
async function nc(t, e, n) {
    if (!Ys(e)) throw e;
    t.k_.add(1), await Ga(t), t.K_.set("Offline"), n || (n = () => GS(t.localStore)), t.asyncQueue.enqueueRetryable(async () => {
        W("RemoteStore", "Retrying IndexedDB access"), await n(), t.k_.delete(1), await Zc(t)
    })
}

function e1(t, e) {
    return e().catch(n => nc(t, n, e))
}
async function eh(t) {
    const e = Z(t),
        n = zr(e);
    let r = e.L_.length > 0 ? e.L_[e.L_.length - 1].batchId : -1;
    for (; vO(e);) try {
        const i = await tO(e.localStore, r);
        if (i === null) {
            e.L_.length === 0 && n.a_();
            break
        }
        r = i.batchId, _O(e, i)
    } catch (i) {
        await nc(e, i)
    }
    t1(e) && n1(e)
}

function vO(t) {
    return Fi(t) && t.L_.length < 10
}

function _O(t, e) {
    t.L_.push(e);
    const n = zr(t);
    n.s_() && n.f_ && n.g_(e.mutations)
}

function t1(t) {
    return Fi(t) && !zr(t).i_() && t.L_.length > 0
}

function n1(t) {
    zr(t).start()
}
async function wO(t) {
    zr(t).w_()
}
async function TO(t) {
    const e = zr(t);
    for (const n of t.L_) e.g_(n.mutations)
}
async function EO(t, e, n) {
    const r = t.L_.shift(),
        i = Mm.from(r, e, n);
    await e1(t, () => t.remoteSyncer.applySuccessfulWrite(i)), await eh(t)
}
async function IO(t, e) {
    e && zr(t).f_ && await async function(r, i) {
        if (function(o) {
                return lV(o) && o !== L.ABORTED
            }(i.code)) {
            const s = r.L_.shift();
            zr(r).__(), await e1(r, () => r.remoteSyncer.rejectFailedWrite(s.batchId, i)), await eh(r)
        }
    }(t, e), t1(t) && n1(t)
}
async function r0(t, e) {
    const n = Z(t);
    n.asyncQueue.verifyOperationInProgress(), W("RemoteStore", "RemoteStore received new credentials");
    const r = Fi(n);
    n.k_.add(3), await Ga(n), r && n.K_.set("Unknown"), await n.remoteSyncer.handleCredentialChange(e), n.k_.delete(3), await Zc(n)
}
async function SO(t, e) {
    const n = Z(t);
    e ? (n.k_.delete(2), await Zc(n)) : e || (n.k_.add(2), await Ga(n), n.K_.set("Unknown"))
}

function Js(t) {
    return t.W_ || (t.W_ = function(n, r, i) {
        const s = Z(n);
        return s.b_(), new uO(r, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, i)
    }(t.datastore, t.asyncQueue, {
        Ro: pO.bind(null, t),
        mo: mO.bind(null, t),
        po: gO.bind(null, t),
        R_: yO.bind(null, t)
    }), t.q_.push(async e => {
        e ? (t.W_.__(), Hm(t) ? qm(t) : t.K_.set("Unknown")) : (await t.W_.stop(), ZS(t))
    })), t.W_
}

function zr(t) {
    return t.G_ || (t.G_ = function(n, r, i) {
        const s = Z(n);
        return s.b_(), new cO(r, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, i)
    }(t.datastore, t.asyncQueue, {
        Ro: () => Promise.resolve(),
        mo: wO.bind(null, t),
        po: IO.bind(null, t),
        p_: TO.bind(null, t),
        y_: EO.bind(null, t)
    }), t.q_.push(async e => {
        e ? (t.G_.__(), await eh(t)) : (await t.G_.stop(), t.L_.length > 0 && (W("RemoteStore", `Stopping write stream with ${t.L_.length} pending writes`), t.L_ = []))
    })), t.G_
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Km {
    constructor(e, n, r, i, s) {
        this.asyncQueue = e, this.timerId = n, this.targetTimeMs = r, this.op = i, this.removalCallback = s, this.deferred = new zn, this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch(o => {})
    }
    get promise() {
        return this.deferred.promise
    }
    static createAndSchedule(e, n, r, i, s) {
        const o = Date.now() + r,
            a = new Km(e, n, o, i, s);
        return a.start(r), a
    }
    start(e) {
        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e)
    }
    skipDelay() {
        return this.handleDelayElapsed()
    }
    cancel(e) {
        this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new z(L.CANCELLED, "Operation cancelled" + (e ? ": " + e : ""))))
    }
    handleDelayElapsed() {
        this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then(e => this.deferred.resolve(e))) : Promise.resolve())
    }
    clearTimeout() {
        this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null)
    }
}

function Gm(t, e) {
    if (Zn("AsyncQueue", `${e}: ${t}`), Ys(t)) return new z(L.UNAVAILABLE, `${e}: ${t}`);
    throw t
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Is {
    static emptySet(e) {
        return new Is(e.comparator)
    }
    constructor(e) {
        this.comparator = e ? (n, r) => e(n, r) || H.comparator(n.key, r.key) : (n, r) => H.comparator(n.key, r.key), this.keyedMap = Vo(), this.sortedSet = new Ae(this.comparator)
    }
    has(e) {
        return this.keyedMap.get(e) != null
    }
    get(e) {
        return this.keyedMap.get(e)
    }
    first() {
        return this.sortedSet.minKey()
    }
    last() {
        return this.sortedSet.maxKey()
    }
    isEmpty() {
        return this.sortedSet.isEmpty()
    }
    indexOf(e) {
        const n = this.keyedMap.get(e);
        return n ? this.sortedSet.indexOf(n) : -1
    }
    get size() {
        return this.sortedSet.size
    }
    forEach(e) {
        this.sortedSet.inorderTraversal((n, r) => (e(n), !1))
    }
    add(e) {
        const n = this.delete(e.key);
        return n.copy(n.keyedMap.insert(e.key, e), n.sortedSet.insert(e, null))
    }
    delete(e) {
        const n = this.get(e);
        return n ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(n)) : this
    }
    isEqual(e) {
        if (!(e instanceof Is) || this.size !== e.size) return !1;
        const n = this.sortedSet.getIterator(),
            r = e.sortedSet.getIterator();
        for (; n.hasNext();) {
            const i = n.getNext().key,
                s = r.getNext().key;
            if (!i.isEqual(s)) return !1
        }
        return !0
    }
    toString() {
        const e = [];
        return this.forEach(n => {
            e.push(n.toString())
        }), e.length === 0 ? "DocumentSet ()" : `DocumentSet (
  ` + e.join(`  
`) + `
)`
    }
    copy(e, n) {
        const r = new Is;
        return r.comparator = this.comparator, r.keyedMap = e, r.sortedSet = n, r
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class i0 {
    constructor() {
        this.z_ = new Ae(H.comparator)
    }
    track(e) {
        const n = e.doc.key,
            r = this.z_.get(n);
        r ? e.type !== 0 && r.type === 3 ? this.z_ = this.z_.insert(n, e) : e.type === 3 && r.type !== 1 ? this.z_ = this.z_.insert(n, {
            type: r.type,
            doc: e.doc
        }) : e.type === 2 && r.type === 2 ? this.z_ = this.z_.insert(n, {
            type: 2,
            doc: e.doc
        }) : e.type === 2 && r.type === 0 ? this.z_ = this.z_.insert(n, {
            type: 0,
            doc: e.doc
        }) : e.type === 1 && r.type === 0 ? this.z_ = this.z_.remove(n) : e.type === 1 && r.type === 2 ? this.z_ = this.z_.insert(n, {
            type: 1,
            doc: r.doc
        }) : e.type === 0 && r.type === 1 ? this.z_ = this.z_.insert(n, {
            type: 2,
            doc: e.doc
        }) : Y() : this.z_ = this.z_.insert(n, e)
    }
    j_() {
        const e = [];
        return this.z_.inorderTraversal((n, r) => {
            e.push(r)
        }), e
    }
}
class Us {
    constructor(e, n, r, i, s, o, a, u, c) {
        this.query = e, this.docs = n, this.oldDocs = r, this.docChanges = i, this.mutatedKeys = s, this.fromCache = o, this.syncStateChanged = a, this.excludesMetadataChanges = u, this.hasCachedResults = c
    }
    static fromInitialDocuments(e, n, r, i, s) {
        const o = [];
        return n.forEach(a => {
            o.push({
                type: 0,
                doc: a
            })
        }), new Us(e, n, Is.emptySet(n), o, r, i, !0, !1, s)
    }
    get hasPendingWrites() {
        return !this.mutatedKeys.isEmpty()
    }
    isEqual(e) {
        if (!(this.fromCache === e.fromCache && this.hasCachedResults === e.hasCachedResults && this.syncStateChanged === e.syncStateChanged && this.mutatedKeys.isEqual(e.mutatedKeys) && Kc(this.query, e.query) && this.docs.isEqual(e.docs) && this.oldDocs.isEqual(e.oldDocs))) return !1;
        const n = this.docChanges,
            r = e.docChanges;
        if (n.length !== r.length) return !1;
        for (let i = 0; i < n.length; i++)
            if (n[i].type !== r[i].type || !n[i].doc.isEqual(r[i].doc)) return !1;
        return !0
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AO {
    constructor() {
        this.H_ = void 0, this.J_ = []
    }
    Y_() {
        return this.J_.some(e => e.Z_())
    }
}
class PO {
    constructor() {
        this.queries = s0(), this.onlineState = "Unknown", this.X_ = new Set
    }
    terminate() {
        (function(n, r) {
            const i = Z(n),
                s = i.queries;
            i.queries = s0(), s.forEach((o, a) => {
                for (const u of a.J_) u.onError(r)
            })
        })(this, new z(L.ABORTED, "Firestore shutting down"))
    }
}

function s0() {
    return new Mi(t => SS(t), Kc)
}
async function r1(t, e) {
    const n = Z(t);
    let r = 3;
    const i = e.query;
    let s = n.queries.get(i);
    s ? !s.Y_() && e.Z_() && (r = 2) : (s = new AO, r = e.Z_() ? 0 : 1);
    try {
        switch (r) {
            case 0:
                s.H_ = await n.onListen(i, !0);
                break;
            case 1:
                s.H_ = await n.onListen(i, !1);
                break;
            case 2:
                await n.onFirstRemoteStoreListen(i)
        }
    } catch (o) {
        const a = Gm(o, `Initialization of query '${Yi(e.query)}' failed`);
        return void e.onError(a)
    }
    n.queries.set(i, s), s.J_.push(e), e.ea(n.onlineState), s.H_ && e.ta(s.H_) && Qm(n)
}
async function i1(t, e) {
    const n = Z(t),
        r = e.query;
    let i = 3;
    const s = n.queries.get(r);
    if (s) {
        const o = s.J_.indexOf(e);
        o >= 0 && (s.J_.splice(o, 1), s.J_.length === 0 ? i = e.Z_() ? 0 : 1 : !s.Y_() && e.Z_() && (i = 2))
    }
    switch (i) {
        case 0:
            return n.queries.delete(r), n.onUnlisten(r, !0);
        case 1:
            return n.queries.delete(r), n.onUnlisten(r, !1);
        case 2:
            return n.onLastRemoteStoreUnlisten(r);
        default:
            return
    }
}

function RO(t, e) {
    const n = Z(t);
    let r = !1;
    for (const i of e) {
        const s = i.query,
            o = n.queries.get(s);
        if (o) {
            for (const a of o.J_) a.ta(i) && (r = !0);
            o.H_ = i
        }
    }
    r && Qm(n)
}

function CO(t, e, n) {
    const r = Z(t),
        i = r.queries.get(e);
    if (i)
        for (const s of i.J_) s.onError(n);
    r.queries.delete(e)
}

function Qm(t) {
    t.X_.forEach(e => {
        e.next()
    })
}
var ep, o0;
(o0 = ep || (ep = {})).na = "default", o0.Cache = "cache";
class s1 {
    constructor(e, n, r) {
        this.query = e, this.ra = n, this.ia = !1, this.sa = null, this.onlineState = "Unknown", this.options = r || {}
    }
    ta(e) {
        if (!this.options.includeMetadataChanges) {
            const r = [];
            for (const i of e.docChanges) i.type !== 3 && r.push(i);
            e = new Us(e.query, e.docs, e.oldDocs, r, e.mutatedKeys, e.fromCache, e.syncStateChanged, !0, e.hasCachedResults)
        }
        let n = !1;
        return this.ia ? this.oa(e) && (this.ra.next(e), n = !0) : this._a(e, this.onlineState) && (this.aa(e), n = !0), this.sa = e, n
    }
    onError(e) {
        this.ra.error(e)
    }
    ea(e) {
        this.onlineState = e;
        let n = !1;
        return this.sa && !this.ia && this._a(this.sa, e) && (this.aa(this.sa), n = !0), n
    }
    _a(e, n) {
        if (!e.fromCache || !this.Z_()) return !0;
        const r = n !== "Offline";
        return (!this.options.ua || !r) && (!e.docs.isEmpty() || e.hasCachedResults || n === "Offline")
    }
    oa(e) {
        if (e.docChanges.length > 0) return !0;
        const n = this.sa && this.sa.hasPendingWrites !== e.hasPendingWrites;
        return !(!e.syncStateChanged && !n) && this.options.includeMetadataChanges === !0
    }
    aa(e) {
        e = Us.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults), this.ia = !0, this.ra.next(e)
    }
    Z_() {
        return this.options.source !== ep.Cache
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class o1 {
    constructor(e) {
        this.key = e
    }
}
class a1 {
    constructor(e) {
        this.key = e
    }
}
class kO {
    constructor(e, n) {
        this.query = e, this.da = n, this.Aa = null, this.hasCachedResults = !1, this.current = !1, this.Ra = ne(), this.mutatedKeys = ne(), this.Va = AS(e), this.ma = new Is(this.Va)
    }
    get fa() {
        return this.da
    }
    ga(e, n) {
        const r = n ? n.pa : new i0,
            i = n ? n.ma : this.ma;
        let s = n ? n.mutatedKeys : this.mutatedKeys,
            o = i,
            a = !1;
        const u = this.query.limitType === "F" && i.size === this.query.limit ? i.last() : null,
            c = this.query.limitType === "L" && i.size === this.query.limit ? i.first() : null;
        if (e.inorderTraversal((h, f) => {
                const m = i.get(h),
                    _ = Gc(this.query, f) ? f : null,
                    I = !!m && this.mutatedKeys.has(m.key),
                    R = !!_ && (_.hasLocalMutations || this.mutatedKeys.has(_.key) && _.hasCommittedMutations);
                let k = !1;
                m && _ ? m.data.isEqual(_.data) ? I !== R && (r.track({
                    type: 3,
                    doc: _
                }), k = !0) : this.ya(m, _) || (r.track({
                    type: 2,
                    doc: _
                }), k = !0, (u && this.Va(_, u) > 0 || c && this.Va(_, c) < 0) && (a = !0)) : !m && _ ? (r.track({
                    type: 0,
                    doc: _
                }), k = !0) : m && !_ && (r.track({
                    type: 1,
                    doc: m
                }), k = !0, (u || c) && (a = !0)), k && (_ ? (o = o.add(_), s = R ? s.add(h) : s.delete(h)) : (o = o.delete(h), s = s.delete(h)))
            }), this.query.limit !== null)
            for (; o.size > this.query.limit;) {
                const h = this.query.limitType === "F" ? o.last() : o.first();
                o = o.delete(h.key), s = s.delete(h.key), r.track({
                    type: 1,
                    doc: h
                })
            }
        return {
            ma: o,
            pa: r,
            ss: a,
            mutatedKeys: s
        }
    }
    ya(e, n) {
        return e.hasLocalMutations && n.hasCommittedMutations && !n.hasLocalMutations
    }
    applyChanges(e, n, r, i) {
        const s = this.ma;
        this.ma = e.ma, this.mutatedKeys = e.mutatedKeys;
        const o = e.pa.j_();
        o.sort((h, f) => function(_, I) {
            const R = k => {
                switch (k) {
                    case 0:
                        return 1;
                    case 2:
                    case 3:
                        return 2;
                    case 1:
                        return 0;
                    default:
                        return Y()
                }
            };
            return R(_) - R(I)
        }(h.type, f.type) || this.Va(h.doc, f.doc)), this.wa(r), i = i != null && i;
        const a = n && !i ? this.Sa() : [],
            u = this.Ra.size === 0 && this.current && !i ? 1 : 0,
            c = u !== this.Aa;
        return this.Aa = u, o.length !== 0 || c ? {
            snapshot: new Us(this.query, e.ma, s, o, e.mutatedKeys, u === 0, c, !1, !!r && r.resumeToken.approximateByteSize() > 0),
            ba: a
        } : {
            ba: a
        }
    }
    ea(e) {
        return this.current && e === "Offline" ? (this.current = !1, this.applyChanges({
            ma: this.ma,
            pa: new i0,
            mutatedKeys: this.mutatedKeys,
            ss: !1
        }, !1)) : {
            ba: []
        }
    }
    Da(e) {
        return !this.da.has(e) && !!this.ma.has(e) && !this.ma.get(e).hasLocalMutations
    }
    wa(e) {
        e && (e.addedDocuments.forEach(n => this.da = this.da.add(n)), e.modifiedDocuments.forEach(n => {}), e.removedDocuments.forEach(n => this.da = this.da.delete(n)), this.current = e.current)
    }
    Sa() {
        if (!this.current) return [];
        const e = this.Ra;
        this.Ra = ne(), this.ma.forEach(r => {
            this.Da(r.key) && (this.Ra = this.Ra.add(r.key))
        });
        const n = [];
        return e.forEach(r => {
            this.Ra.has(r) || n.push(new a1(r))
        }), this.Ra.forEach(r => {
            e.has(r) || n.push(new o1(r))
        }), n
    }
    va(e) {
        this.da = e.ds, this.Ra = ne();
        const n = this.ga(e.documents);
        return this.applyChanges(n, !0)
    }
    Ca() {
        return Us.fromInitialDocuments(this.query, this.ma, this.mutatedKeys, this.Aa === 0, this.hasCachedResults)
    }
}
class xO {
    constructor(e, n, r) {
        this.query = e, this.targetId = n, this.view = r
    }
}
class bO {
    constructor(e) {
        this.key = e, this.Fa = !1
    }
}
class NO {
    constructor(e, n, r, i, s, o) {
        this.localStore = e, this.remoteStore = n, this.eventManager = r, this.sharedClientState = i, this.currentUser = s, this.maxConcurrentLimboResolutions = o, this.Ma = {}, this.xa = new Mi(a => SS(a), Kc), this.Oa = new Map, this.Na = new Set, this.La = new Ae(H.comparator), this.Ba = new Map, this.ka = new jm, this.qa = {}, this.Qa = new Map, this.Ka = Fs.Qn(), this.onlineState = "Unknown", this.$a = void 0
    }
    get isPrimaryClient() {
        return this.$a === !0
    }
}
async function DO(t, e, n = !0) {
    const r = f1(t);
    let i;
    const s = r.xa.get(e);
    return s ? (r.sharedClientState.addLocalQueryTarget(s.targetId), i = s.view.Ca()) : i = await l1(r, e, n, !0), i
}
async function VO(t, e) {
    const n = f1(t);
    await l1(n, e, !0, !1)
}
async function l1(t, e, n, r) {
    const i = await nO(t.localStore, wn(e)),
        s = i.targetId,
        o = t.sharedClientState.addLocalQueryTarget(s, n);
    let a;
    return r && (a = await OO(t, e, s, o === "current", i.resumeToken)), t.isPrimaryClient && n && XS(t.remoteStore, i), a
}
async function OO(t, e, n, r, i) {
    t.Ua = (f, m, _) => async function(R, k, w, v) {
        let T = k.view.ga(w);
        T.ss && (T = await e0(R.localStore, k.query, !1).then(({
            documents: S
        }) => k.view.ga(S, T)));
        const x = v && v.targetChanges.get(k.targetId),
            O = v && v.targetMismatches.get(k.targetId) != null,
            U = k.view.applyChanges(T, R.isPrimaryClient, x, O);
        return l0(R, k.targetId, U.ba), U.snapshot
    }(t, f, m, _);
    const s = await e0(t.localStore, e, !0),
        o = new kO(e, s.ds),
        a = o.ga(s.documents),
        u = Ka.createSynthesizedTargetChangeForCurrentChange(n, r && t.onlineState !== "Offline", i),
        c = o.applyChanges(a, t.isPrimaryClient, u);
    l0(t, n, c.ba);
    const h = new xO(e, n, o);
    return t.xa.set(e, h), t.Oa.has(n) ? t.Oa.get(n).push(e) : t.Oa.set(n, [e]), c.snapshot
}
async function LO(t, e, n) {
    const r = Z(t),
        i = r.xa.get(e),
        s = r.Oa.get(i.targetId);
    if (s.length > 1) return r.Oa.set(i.targetId, s.filter(o => !Kc(o, e))), void r.xa.delete(e);
    r.isPrimaryClient ? (r.sharedClientState.removeLocalQueryTarget(i.targetId), r.sharedClientState.isActiveQueryTarget(i.targetId) || await Zf(r.localStore, i.targetId, !1).then(() => {
        r.sharedClientState.clearQueryState(i.targetId), n && zm(r.remoteStore, i.targetId), tp(r, i.targetId)
    }).catch(Qs)) : (tp(r, i.targetId), await Zf(r.localStore, i.targetId, !0))
}
async function MO(t, e) {
    const n = Z(t),
        r = n.xa.get(e),
        i = n.Oa.get(r.targetId);
    n.isPrimaryClient && i.length === 1 && (n.sharedClientState.removeLocalQueryTarget(r.targetId), zm(n.remoteStore, r.targetId))
}
async function FO(t, e, n) {
    const r = qO(t);
    try {
        const i = await
        function(o, a) {
            const u = Z(o),
                c = Fe.now(),
                h = a.reduce((_, I) => _.add(I.key), ne());
            let f, m;
            return u.persistence.runTransaction("Locally write mutations", "readwrite", _ => {
                let I = er(),
                    R = ne();
                return u.hs.getEntries(_, h).next(k => {
                    I = k, I.forEach((w, v) => {
                        v.isValidDocument() || (R = R.add(w))
                    })
                }).next(() => u.localDocuments.getOverlayedDocuments(_, I)).next(k => {
                    f = k;
                    const w = [];
                    for (const v of a) {
                        const T = rV(v, f.get(v.key).overlayedDocument);
                        T != null && w.push(new Zr(v.key, T, gS(T.value.mapValue), Xt.exists(!0)))
                    }
                    return u.mutationQueue.addMutationBatch(_, c, w, a)
                }).next(k => {
                    m = k;
                    const w = k.applyToLocalDocumentSet(f, R);
                    return u.documentOverlayCache.saveOverlays(_, k.batchId, w)
                })
            }).then(() => ({
                batchId: m.batchId,
                changes: RS(f)
            }))
        }(r.localStore, e);
        r.sharedClientState.addPendingMutation(i.batchId),
            function(o, a, u) {
                let c = o.qa[o.currentUser.toKey()];
                c || (c = new Ae(re)), c = c.insert(a, u), o.qa[o.currentUser.toKey()] = c
            }(r, i.batchId, n), await Qa(r, i.changes), await eh(r.remoteStore)
    } catch (i) {
        const s = Gm(i, "Failed to persist write");
        n.reject(s)
    }
}
async function u1(t, e) {
    const n = Z(t);
    try {
        const r = await ZV(n.localStore, e);
        e.targetChanges.forEach((i, s) => {
            const o = n.Ba.get(s);
            o && (ae(i.addedDocuments.size + i.modifiedDocuments.size + i.removedDocuments.size <= 1), i.addedDocuments.size > 0 ? o.Fa = !0 : i.modifiedDocuments.size > 0 ? ae(o.Fa) : i.removedDocuments.size > 0 && (ae(o.Fa), o.Fa = !1))
        }), await Qa(n, r, e)
    } catch (r) {
        await Qs(r)
    }
}

function a0(t, e, n) {
    const r = Z(t);
    if (r.isPrimaryClient && n === 0 || !r.isPrimaryClient && n === 1) {
        const i = [];
        r.xa.forEach((s, o) => {
                const a = o.view.ea(e);
                a.snapshot && i.push(a.snapshot)
            }),
            function(o, a) {
                const u = Z(o);
                u.onlineState = a;
                let c = !1;
                u.queries.forEach((h, f) => {
                    for (const m of f.J_) m.ea(a) && (c = !0)
                }), c && Qm(u)
            }(r.eventManager, e), i.length && r.Ma.R_(i), r.onlineState = e, r.isPrimaryClient && r.sharedClientState.setOnlineState(e)
    }
}
async function UO(t, e, n) {
    const r = Z(t);
    r.sharedClientState.updateQueryState(e, "rejected", n);
    const i = r.Ba.get(e),
        s = i && i.key;
    if (s) {
        let o = new Ae(H.comparator);
        o = o.insert(s, lt.newNoDocument(s, J.min()));
        const a = ne().add(s),
            u = new Xc(J.min(), new Map, new Ae(re), o, a);
        await u1(r, u), r.La = r.La.remove(s), r.Ba.delete(e), Ym(r)
    } else await Zf(r.localStore, e, !1).then(() => tp(r, e, n)).catch(Qs)
}
async function jO(t, e) {
    const n = Z(t),
        r = e.batch.batchId;
    try {
        const i = await JV(n.localStore, e);
        h1(n, r, null), c1(n, r), n.sharedClientState.updateMutationState(r, "acknowledged"), await Qa(n, i)
    } catch (i) {
        await Qs(i)
    }
}
async function BO(t, e, n) {
    const r = Z(t);
    try {
        const i = await
        function(o, a) {
            const u = Z(o);
            return u.persistence.runTransaction("Reject batch", "readwrite-primary", c => {
                let h;
                return u.mutationQueue.lookupMutationBatch(c, a).next(f => (ae(f !== null), h = f.keys(), u.mutationQueue.removeMutationBatch(c, f))).next(() => u.mutationQueue.performConsistencyCheck(c)).next(() => u.documentOverlayCache.removeOverlaysForBatchId(c, h, a)).next(() => u.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(c, h)).next(() => u.localDocuments.getDocuments(c, h))
            })
        }(r.localStore, e);
        h1(r, e, n), c1(r, e), r.sharedClientState.updateMutationState(e, "rejected", n), await Qa(r, i)
    } catch (i) {
        await Qs(i)
    }
}

function c1(t, e) {
    (t.Qa.get(e) || []).forEach(n => {
        n.resolve()
    }), t.Qa.delete(e)
}

function h1(t, e, n) {
    const r = Z(t);
    let i = r.qa[r.currentUser.toKey()];
    if (i) {
        const s = i.get(e);
        s && (n ? s.reject(n) : s.resolve(), i = i.remove(e)), r.qa[r.currentUser.toKey()] = i
    }
}

function tp(t, e, n = null) {
    t.sharedClientState.removeLocalQueryTarget(e);
    for (const r of t.Oa.get(e)) t.xa.delete(r), n && t.Ma.Wa(r, n);
    t.Oa.delete(e), t.isPrimaryClient && t.ka.yr(e).forEach(r => {
        t.ka.containsKey(r) || d1(t, r)
    })
}

function d1(t, e) {
    t.Na.delete(e.path.canonicalString());
    const n = t.La.get(e);
    n !== null && (zm(t.remoteStore, n), t.La = t.La.remove(e), t.Ba.delete(n), Ym(t))
}

function l0(t, e, n) {
    for (const r of n) r instanceof o1 ? (t.ka.addReference(r.key, e), $O(t, r)) : r instanceof a1 ? (W("SyncEngine", "Document no longer in limbo: " + r.key), t.ka.removeReference(r.key, e), t.ka.containsKey(r.key) || d1(t, r.key)) : Y()
}

function $O(t, e) {
    const n = e.key,
        r = n.path.canonicalString();
    t.La.get(n) || t.Na.has(r) || (W("SyncEngine", "New document in limbo: " + n), t.Na.add(r), Ym(t))
}

function Ym(t) {
    for (; t.Na.size > 0 && t.La.size < t.maxConcurrentLimboResolutions;) {
        const e = t.Na.values().next().value;
        t.Na.delete(e);
        const n = new H(ye.fromString(e)),
            r = t.Ka.next();
        t.Ba.set(r, new bO(n)), t.La = t.La.insert(n, r), XS(t.remoteStore, new Ar(wn(Vm(n.path)), r, "TargetPurposeLimboResolution", Wc.oe))
    }
}
async function Qa(t, e, n) {
    const r = Z(t),
        i = [],
        s = [],
        o = [];
    r.xa.isEmpty() || (r.xa.forEach((a, u) => {
        o.push(r.Ua(u, e, n).then(c => {
            var h;
            if ((c || n) && r.isPrimaryClient) {
                const f = c ? !c.fromCache : (h = n == null ? void 0 : n.targetChanges.get(u.targetId)) === null || h === void 0 ? void 0 : h.current;
                r.sharedClientState.updateQueryState(u.targetId, f ? "current" : "not-current")
            }
            if (c) {
                i.push(c);
                const f = $m.zi(u.targetId, c);
                s.push(f)
            }
        }))
    }), await Promise.all(o), r.Ma.R_(i), await async function(u, c) {
        const h = Z(u);
        try {
            await h.persistence.runTransaction("notifyLocalViewChanges", "readwrite", f => F.forEach(c, m => F.forEach(m.Wi, _ => h.persistence.referenceDelegate.addReference(f, m.targetId, _)).next(() => F.forEach(m.Gi, _ => h.persistence.referenceDelegate.removeReference(f, m.targetId, _)))))
        } catch (f) {
            if (!Ys(f)) throw f;
            W("LocalStore", "Failed to update sequence numbers: " + f)
        }
        for (const f of c) {
            const m = f.targetId;
            if (!f.fromCache) {
                const _ = h.us.get(m),
                    I = _.snapshotVersion,
                    R = _.withLastLimboFreeSnapshotVersion(I);
                h.us = h.us.insert(m, R)
            }
        }
    }(r.localStore, s))
}
async function zO(t, e) {
    const n = Z(t);
    if (!n.currentUser.isEqual(e)) {
        W("SyncEngine", "User change. New user:", e.toKey());
        const r = await KS(n.localStore, e);
        n.currentUser = e,
            function(s, o) {
                s.Qa.forEach(a => {
                    a.forEach(u => {
                        u.reject(new z(L.CANCELLED, o))
                    })
                }), s.Qa.clear()
            }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, r.removedBatchIds, r.addedBatchIds), await Qa(n, r.Ts)
    }
}

function WO(t, e) {
    const n = Z(t),
        r = n.Ba.get(e);
    if (r && r.Fa) return ne().add(r.key); {
        let i = ne();
        const s = n.Oa.get(e);
        if (!s) return i;
        for (const o of s) {
            const a = n.xa.get(o);
            i = i.unionWith(a.view.fa)
        }
        return i
    }
}

function f1(t) {
    const e = Z(t);
    return e.remoteStore.remoteSyncer.applyRemoteEvent = u1.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = WO.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = UO.bind(null, e), e.Ma.R_ = RO.bind(null, e.eventManager), e.Ma.Wa = CO.bind(null, e.eventManager), e
}

function qO(t) {
    const e = Z(t);
    return e.remoteStore.remoteSyncer.applySuccessfulWrite = jO.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = BO.bind(null, e), e
}
class rc {
    constructor() {
        this.kind = "memory", this.synchronizeTabs = !1
    }
    async initialize(e) {
        this.serializer = Jc(e.databaseInfo.databaseId), this.sharedClientState = this.za(e), this.persistence = this.ja(e), await this.persistence.start(), this.localStore = this.Ha(e), this.gcScheduler = this.Ja(e, this.localStore), this.indexBackfillerScheduler = this.Ya(e, this.localStore)
    }
    Ja(e, n) {
        return null
    }
    Ya(e, n) {
        return null
    }
    Ha(e) {
        return XV(this.persistence, new QV, e.initialUser, this.serializer)
    }
    ja(e) {
        return new HS(Bm.ei, this.serializer)
    }
    za(e) {
        return new iO
    }
    async terminate() {
        var e, n;
        (e = this.gcScheduler) === null || e === void 0 || e.stop(), (n = this.indexBackfillerScheduler) === null || n === void 0 || n.stop(), this.sharedClientState.shutdown(), await this.persistence.shutdown()
    }
}
rc.provider = {
    build: () => new rc
};
class HO extends rc {
    constructor(e) {
        super(), this.cacheSizeBytes = e
    }
    Ja(e, n) {
        ae(this.persistence.referenceDelegate instanceof tc);
        const r = this.persistence.referenceDelegate.garbageCollector;
        return new VV(r, e.asyncQueue, n)
    }
    ja(e) {
        const n = this.cacheSizeBytes !== void 0 ? Et.withCacheSize(this.cacheSizeBytes) : Et.DEFAULT;
        return new HS(r => tc.ei(r, n), this.serializer)
    }
}
class np {
    async initialize(e, n) {
        this.localStore || (this.localStore = e.localStore, this.sharedClientState = e.sharedClientState, this.datastore = this.createDatastore(n), this.remoteStore = this.createRemoteStore(n), this.eventManager = this.createEventManager(n), this.syncEngine = this.createSyncEngine(n, !e.synchronizeTabs), this.sharedClientState.onlineStateHandler = r => a0(this.syncEngine, r, 1), this.remoteStore.remoteSyncer.handleCredentialChange = zO.bind(null, this.syncEngine), await SO(this.remoteStore, this.syncEngine.isPrimaryClient))
    }
    createEventManager(e) {
        return function() {
            return new PO
        }()
    }
    createDatastore(e) {
        const n = Jc(e.databaseInfo.databaseId),
            r = function(s) {
                return new lO(s)
            }(e.databaseInfo);
        return function(s, o, a, u) {
            return new hO(s, o, a, u)
        }(e.authCredentials, e.appCheckCredentials, r, n)
    }
    createRemoteStore(e) {
        return function(r, i, s, o, a) {
            return new fO(r, i, s, o, a)
        }(this.localStore, this.datastore, e.asyncQueue, n => a0(this.syncEngine, n, 0), function() {
            return n0.p() ? new n0 : new sO
        }())
    }
    createSyncEngine(e, n) {
        return function(i, s, o, a, u, c, h) {
            const f = new NO(i, s, o, a, u, c);
            return h && (f.$a = !0), f
        }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, n)
    }
    async terminate() {
        var e, n;
        await async function(i) {
            const s = Z(i);
            W("RemoteStore", "RemoteStore shutting down."), s.k_.add(5), await Ga(s), s.Q_.shutdown(), s.K_.set("Unknown")
        }(this.remoteStore), (e = this.datastore) === null || e === void 0 || e.terminate(), (n = this.eventManager) === null || n === void 0 || n.terminate()
    }
}
np.provider = {
    build: () => new np
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class p1 {
    constructor(e) {
        this.observer = e, this.muted = !1
    }
    next(e) {
        this.muted || this.observer.next && this.Xa(this.observer.next, e)
    }
    error(e) {
        this.muted || (this.observer.error ? this.Xa(this.observer.error, e) : Zn("Uncaught Error in snapshot listener:", e.toString()))
    }
    eu() {
        this.muted = !0
    }
    Xa(e, n) {
        setTimeout(() => {
            this.muted || e(n)
        }, 0)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class KO {
    constructor(e, n, r, i, s) {
        this.authCredentials = e, this.appCheckCredentials = n, this.asyncQueue = r, this.databaseInfo = i, this.user = ot.UNAUTHENTICATED, this.clientId = fS.newId(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this._uninitializedComponentsProvider = s, this.authCredentials.start(r, async o => {
            W("FirestoreClient", "Received user=", o.uid), await this.authCredentialListener(o), this.user = o
        }), this.appCheckCredentials.start(r, o => (W("FirestoreClient", "Received new app check token=", o), this.appCheckCredentialListener(o, this.user)))
    }
    get configuration() {
        return {
            asyncQueue: this.asyncQueue,
            databaseInfo: this.databaseInfo,
            clientId: this.clientId,
            authCredentials: this.authCredentials,
            appCheckCredentials: this.appCheckCredentials,
            initialUser: this.user,
            maxConcurrentLimboResolutions: 100
        }
    }
    setCredentialChangeListener(e) {
        this.authCredentialListener = e
    }
    setAppCheckTokenChangeListener(e) {
        this.appCheckCredentialListener = e
    }
    terminate() {
        this.asyncQueue.enterRestrictedMode();
        const e = new zn;
        return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
            try {
                this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), e.resolve()
            } catch (n) {
                const r = Gm(n, "Failed to shutdown persistence");
                e.reject(r)
            }
        }), e.promise
    }
}
async function Ed(t, e) {
    t.asyncQueue.verifyOperationInProgress(), W("FirestoreClient", "Initializing OfflineComponentProvider");
    const n = t.configuration;
    await e.initialize(n);
    let r = n.initialUser;
    t.setCredentialChangeListener(async i => {
        r.isEqual(i) || (await KS(e.localStore, i), r = i)
    }), e.persistence.setDatabaseDeletedListener(() => t.terminate()), t._offlineComponents = e
}
async function u0(t, e) {
    t.asyncQueue.verifyOperationInProgress();
    const n = await GO(t);
    W("FirestoreClient", "Initializing OnlineComponentProvider"), await e.initialize(n, t.configuration), t.setCredentialChangeListener(r => r0(e.remoteStore, r)), t.setAppCheckTokenChangeListener((r, i) => r0(e.remoteStore, i)), t._onlineComponents = e
}
async function GO(t) {
    if (!t._offlineComponents)
        if (t._uninitializedComponentsProvider) {
            W("FirestoreClient", "Using user provided OfflineComponentProvider");
            try {
                await Ed(t, t._uninitializedComponentsProvider._offline)
            } catch (e) {
                const n = e;
                if (! function(i) {
                        return i.name === "FirebaseError" ? i.code === L.FAILED_PRECONDITION || i.code === L.UNIMPLEMENTED : !(typeof DOMException < "u" && i instanceof DOMException) || i.code === 22 || i.code === 20 || i.code === 11
                    }(n)) throw n;
                Vs("Error using user provided cache. Falling back to memory cache: " + n), await Ed(t, new rc)
            }
        } else W("FirestoreClient", "Using default OfflineComponentProvider"), await Ed(t, new HO(void 0));
    return t._offlineComponents
}
async function m1(t) {
    return t._onlineComponents || (t._uninitializedComponentsProvider ? (W("FirestoreClient", "Using user provided OnlineComponentProvider"), await u0(t, t._uninitializedComponentsProvider._online)) : (W("FirestoreClient", "Using default OnlineComponentProvider"), await u0(t, new np))), t._onlineComponents
}

function QO(t) {
    return m1(t).then(e => e.syncEngine)
}
async function g1(t) {
    const e = await m1(t),
        n = e.eventManager;
    return n.onListen = DO.bind(null, e.syncEngine), n.onUnlisten = LO.bind(null, e.syncEngine), n.onFirstRemoteStoreListen = VO.bind(null, e.syncEngine), n.onLastRemoteStoreUnlisten = MO.bind(null, e.syncEngine), n
}

function YO(t, e, n = {}) {
    const r = new zn;
    return t.asyncQueue.enqueueAndForget(async () => function(s, o, a, u, c) {
        const h = new p1({
                next: m => {
                    h.eu(), o.enqueueAndForget(() => i1(s, f));
                    const _ = m.docs.has(a);
                    !_ && m.fromCache ? c.reject(new z(L.UNAVAILABLE, "Failed to get document because the client is offline.")) : _ && m.fromCache && u && u.source === "server" ? c.reject(new z(L.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : c.resolve(m)
                },
                error: m => c.reject(m)
            }),
            f = new s1(Vm(a.path), h, {
                includeMetadataChanges: !0,
                ua: !0
            });
        return r1(s, f)
    }(await g1(t), t.asyncQueue, e, n, r)), r.promise
}

function XO(t, e, n = {}) {
    const r = new zn;
    return t.asyncQueue.enqueueAndForget(async () => function(s, o, a, u, c) {
        const h = new p1({
                next: m => {
                    h.eu(), o.enqueueAndForget(() => i1(s, f)), m.fromCache && u.source === "server" ? c.reject(new z(L.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : c.resolve(m)
                },
                error: m => c.reject(m)
            }),
            f = new s1(a, h, {
                includeMetadataChanges: !0,
                ua: !0
            });
        return r1(s, f)
    }(await g1(t), t.asyncQueue, e, n, r)), r.promise
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function y1(t) {
    const e = {};
    return t.timeoutSeconds !== void 0 && (e.timeoutSeconds = t.timeoutSeconds), e
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const c0 = new Map;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function v1(t, e, n) {
    if (!n) throw new z(L.INVALID_ARGUMENT, `Function ${t}() cannot be called with an empty ${e}.`)
}

function JO(t, e, n, r) {
    if (e === !0 && r === !0) throw new z(L.INVALID_ARGUMENT, `${t} and ${n} cannot be used together.`)
}

function h0(t) {
    if (!H.isDocumentKey(t)) throw new z(L.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t} has ${t.length}.`)
}

function d0(t) {
    if (H.isDocumentKey(t)) throw new z(L.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t} has ${t.length}.`)
}

function th(t) {
    if (t === void 0) return "undefined";
    if (t === null) return "null";
    if (typeof t == "string") return t.length > 20 && (t = `${t.substring(0,20)}...`), JSON.stringify(t);
    if (typeof t == "number" || typeof t == "boolean") return "" + t;
    if (typeof t == "object") {
        if (t instanceof Array) return "an array"; {
            const e = function(r) {
                return r.constructor ? r.constructor.name : null
            }(t);
            return e ? `a custom ${e} object` : "an object"
        }
    }
    return typeof t == "function" ? "a function" : Y()
}

function Wr(t, e) {
    if ("_delegate" in t && (t = t._delegate), !(t instanceof e)) {
        if (e.name === t.constructor.name) throw new z(L.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?"); {
            const n = th(t);
            throw new z(L.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`)
        }
    }
    return t
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class f0 {
    constructor(e) {
        var n, r;
        if (e.host === void 0) {
            if (e.ssl !== void 0) throw new z(L.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
            this.host = "firestore.googleapis.com", this.ssl = !0
        } else this.host = e.host, this.ssl = (n = e.ssl) === null || n === void 0 || n;
        if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, this.localCache = e.localCache, e.cacheSizeBytes === void 0) this.cacheSizeBytes = 41943040;
        else {
            if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576) throw new z(L.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
            this.cacheSizeBytes = e.cacheSizeBytes
        }
        JO("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : e.experimentalAutoDetectLongPolling === void 0 ? this.experimentalAutoDetectLongPolling = !0 : this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling, this.experimentalLongPollingOptions = y1((r = e.experimentalLongPollingOptions) !== null && r !== void 0 ? r : {}),
            function(s) {
                if (s.timeoutSeconds !== void 0) {
                    if (isNaN(s.timeoutSeconds)) throw new z(L.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (must not be NaN)`);
                    if (s.timeoutSeconds < 5) throw new z(L.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (minimum allowed value is 5)`);
                    if (s.timeoutSeconds > 30) throw new z(L.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (maximum allowed value is 30)`)
                }
            }(this.experimentalLongPollingOptions), this.useFetchStreams = !!e.useFetchStreams
    }
    isEqual(e) {
        return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && function(r, i) {
            return r.timeoutSeconds === i.timeoutSeconds
        }(this.experimentalLongPollingOptions, e.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams
    }
}
class nh {
    constructor(e, n, r, i) {
        this._authCredentials = e, this._appCheckCredentials = n, this._databaseId = r, this._app = i, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new f0({}), this._settingsFrozen = !1, this._terminateTask = "notTerminated"
    }
    get app() {
        if (!this._app) throw new z(L.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
        return this._app
    }
    get _initialized() {
        return this._settingsFrozen
    }
    get _terminated() {
        return this._terminateTask !== "notTerminated"
    }
    _setSettings(e) {
        if (this._settingsFrozen) throw new z(L.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
        this._settings = new f0(e), e.credentials !== void 0 && (this._authCredentials = function(r) {
            if (!r) return new cD;
            switch (r.type) {
                case "firstParty":
                    return new pD(r.sessionIndex || "0", r.iamToken || null, r.authTokenFactory || null);
                case "provider":
                    return r.client;
                default:
                    throw new z(L.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type")
            }
        }(e.credentials))
    }
    _getSettings() {
        return this._settings
    }
    _freezeSettings() {
        return this._settingsFrozen = !0, this._settings
    }
    _delete() {
        return this._terminateTask === "notTerminated" && (this._terminateTask = this._terminate()), this._terminateTask
    }
    async _restart() {
        this._terminateTask === "notTerminated" ? await this._terminate() : this._terminateTask = "notTerminated"
    }
    toJSON() {
        return {
            app: this._app,
            databaseId: this._databaseId,
            settings: this._settings
        }
    }
    _terminate() {
        return function(n) {
            const r = c0.get(n);
            r && (W("ComponentProvider", "Removing Datastore"), c0.delete(n), r.terminate())
        }(this), Promise.resolve()
    }
}

function ZO(t, e, n, r = {}) {
    var i;
    const s = (t = Wr(t, nh))._getSettings(),
        o = `${e}:${n}`;
    if (s.host !== "firestore.googleapis.com" && s.host !== o && Vs("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."), t._setSettings(Object.assign(Object.assign({}, s), {
            host: o,
            ssl: !1
        })), r.mockUserToken) {
        let a, u;
        if (typeof r.mockUserToken == "string") a = r.mockUserToken, u = ot.MOCK_USER;
        else {
            a = xI(r.mockUserToken, (i = t._app) === null || i === void 0 ? void 0 : i.options.projectId);
            const c = r.mockUserToken.sub || r.mockUserToken.user_id;
            if (!c) throw new z(L.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
            u = new ot(c)
        }
        t._authCredentials = new hD(new dS(a, u))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ei {
    constructor(e, n, r) {
        this.converter = n, this._query = r, this.type = "query", this.firestore = e
    }
    withConverter(e) {
        return new ei(this.firestore, e, this._query)
    }
}
class bt {
    constructor(e, n, r) {
        this.converter = n, this._key = r, this.type = "document", this.firestore = e
    }
    get _path() {
        return this._key.path
    }
    get id() {
        return this._key.path.lastSegment()
    }
    get path() {
        return this._key.path.canonicalString()
    }
    get parent() {
        return new Lr(this.firestore, this.converter, this._key.path.popLast())
    }
    withConverter(e) {
        return new bt(this.firestore, e, this._key)
    }
}
class Lr extends ei {
    constructor(e, n, r) {
        super(e, n, Vm(r)), this._path = r, this.type = "collection"
    }
    get id() {
        return this._query.path.lastSegment()
    }
    get path() {
        return this._query.path.canonicalString()
    }
    get parent() {
        const e = this._path.popLast();
        return e.isEmpty() ? null : new bt(this.firestore, null, new H(e))
    }
    withConverter(e) {
        return new Lr(this.firestore, e, this._path)
    }
}

function _1(t, e, ...n) {
    if (t = Ce(t), v1("collection", "path", e), t instanceof nh) {
        const r = ye.fromString(e, ...n);
        return d0(r), new Lr(t, null, r)
    } {
        if (!(t instanceof bt || t instanceof Lr)) throw new z(L.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
        const r = t._path.child(ye.fromString(e, ...n));
        return d0(r), new Lr(t.firestore, null, r)
    }
}

function eL(t, e, ...n) {
    if (t = Ce(t), arguments.length === 1 && (e = fS.newId()), v1("doc", "path", e), t instanceof nh) {
        const r = ye.fromString(e, ...n);
        return h0(r), new bt(t, null, new H(r))
    } {
        if (!(t instanceof bt || t instanceof Lr)) throw new z(L.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
        const r = t._path.child(ye.fromString(e, ...n));
        return h0(r), new bt(t.firestore, t instanceof Lr ? t.converter : null, new H(r))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class p0 {
    constructor(e = Promise.resolve()) {
        this.Iu = [], this.Eu = !1, this.du = [], this.Au = null, this.Ru = !1, this.Vu = !1, this.mu = [], this.r_ = new QS(this, "async_queue_retry"), this.fu = () => {
            const r = Td();
            r && W("AsyncQueue", "Visibility state changed to " + r.visibilityState), this.r_.Jo()
        }, this.gu = e;
        const n = Td();
        n && typeof n.addEventListener == "function" && n.addEventListener("visibilitychange", this.fu)
    }
    get isShuttingDown() {
        return this.Eu
    }
    enqueueAndForget(e) {
        this.enqueue(e)
    }
    enqueueAndForgetEvenWhileRestricted(e) {
        this.pu(), this.yu(e)
    }
    enterRestrictedMode(e) {
        if (!this.Eu) {
            this.Eu = !0, this.Vu = e || !1;
            const n = Td();
            n && typeof n.removeEventListener == "function" && n.removeEventListener("visibilitychange", this.fu)
        }
    }
    enqueue(e) {
        if (this.pu(), this.Eu) return new Promise(() => {});
        const n = new zn;
        return this.yu(() => this.Eu && this.Vu ? Promise.resolve() : (e().then(n.resolve, n.reject), n.promise)).then(() => n.promise)
    }
    enqueueRetryable(e) {
        this.enqueueAndForget(() => (this.Iu.push(e), this.wu()))
    }
    async wu() {
        if (this.Iu.length !== 0) {
            try {
                await this.Iu[0](), this.Iu.shift(), this.r_.reset()
            } catch (e) {
                if (!Ys(e)) throw e;
                W("AsyncQueue", "Operation failed with retryable error: " + e)
            }
            this.Iu.length > 0 && this.r_.jo(() => this.wu())
        }
    }
    yu(e) {
        const n = this.gu.then(() => (this.Ru = !0, e().catch(r => {
            this.Au = r, this.Ru = !1;
            const i = function(o) {
                let a = o.message || "";
                return o.stack && (a = o.stack.includes(o.message) ? o.stack : o.message + `
` + o.stack), a
            }(r);
            throw Zn("INTERNAL UNHANDLED ERROR: ", i), r
        }).then(r => (this.Ru = !1, r))));
        return this.gu = n, n
    }
    enqueueAfterDelay(e, n, r) {
        this.pu(), this.mu.indexOf(e) > -1 && (n = 0);
        const i = Km.createAndSchedule(this, e, n, r, s => this.Su(s));
        return this.du.push(i), i
    }
    pu() {
        this.Au && Y()
    }
    verifyOperationInProgress() {}
    async bu() {
        let e;
        do e = this.gu, await e; while (e !== this.gu)
    }
    Du(e) {
        for (const n of this.du)
            if (n.timerId === e) return !0;
        return !1
    }
    vu(e) {
        return this.bu().then(() => {
            this.du.sort((n, r) => n.targetTimeMs - r.targetTimeMs);
            for (const n of this.du)
                if (n.skipDelay(), e !== "all" && n.timerId === e) break;
            return this.bu()
        })
    }
    Cu(e) {
        this.mu.push(e)
    }
    Su(e) {
        const n = this.du.indexOf(e);
        this.du.splice(n, 1)
    }
}
class Ya extends nh {
    constructor(e, n, r, i) {
        super(e, n, r, i), this.type = "firestore", this._queue = new p0, this._persistenceKey = (i == null ? void 0 : i.name) || "[DEFAULT]"
    }
    async _terminate() {
        if (this._firestoreClient) {
            const e = this._firestoreClient.terminate();
            this._queue = new p0(e), this._firestoreClient = void 0, await e
        }
    }
}

function w1(t, e) {
    const n = typeof t == "object" ? t : qa(),
        r = typeof t == "string" ? t : "(default)",
        i = ir(n, "firestore").getImmediate({
            identifier: r
        });
    if (!i._initialized) {
        const s = RI("firestore");
        s && ZO(i, ...s)
    }
    return i
}

function rh(t) {
    if (t._terminated) throw new z(L.FAILED_PRECONDITION, "The client has already been terminated.");
    return t._firestoreClient || tL(t), t._firestoreClient
}

function tL(t) {
    var e, n, r;
    const i = t._freezeSettings(),
        s = function(a, u, c, h) {
            return new kD(a, u, c, h.host, h.ssl, h.experimentalForceLongPolling, h.experimentalAutoDetectLongPolling, y1(h.experimentalLongPollingOptions), h.useFetchStreams)
        }(t._databaseId, ((e = t._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t._persistenceKey, i);
    t._componentsProvider || !((n = i.localCache) === null || n === void 0) && n._offlineComponentProvider && (!((r = i.localCache) === null || r === void 0) && r._onlineComponentProvider) && (t._componentsProvider = {
        _offline: i.localCache._offlineComponentProvider,
        _online: i.localCache._onlineComponentProvider
    }), t._firestoreClient = new KO(t._authCredentials, t._appCheckCredentials, t._queue, s, t._componentsProvider && function(a) {
        const u = a == null ? void 0 : a._online.build();
        return {
            _offline: a == null ? void 0 : a._offline.build(u),
            _online: u
        }
    }(t._componentsProvider))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class js {
    constructor(e) {
        this._byteString = e
    }
    static fromBase64String(e) {
        try {
            return new js(Xe.fromBase64String(e))
        } catch (n) {
            throw new z(L.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + n)
        }
    }
    static fromUint8Array(e) {
        return new js(Xe.fromUint8Array(e))
    }
    toBase64() {
        return this._byteString.toBase64()
    }
    toUint8Array() {
        return this._byteString.toUint8Array()
    }
    toString() {
        return "Bytes(base64: " + this.toBase64() + ")"
    }
    isEqual(e) {
        return this._byteString.isEqual(e._byteString)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ih {
    constructor(...e) {
        for (let n = 0; n < e.length; ++n)
            if (e[n].length === 0) throw new z(L.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
        this._internalPath = new Ge(e)
    }
    isEqual(e) {
        return this._internalPath.isEqual(e._internalPath)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xm {
    constructor(e) {
        this._methodName = e
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Jm {
    constructor(e, n) {
        if (!isFinite(e) || e < -90 || e > 90) throw new z(L.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + e);
        if (!isFinite(n) || n < -180 || n > 180) throw new z(L.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + n);
        this._lat = e, this._long = n
    }
    get latitude() {
        return this._lat
    }
    get longitude() {
        return this._long
    }
    isEqual(e) {
        return this._lat === e._lat && this._long === e._long
    }
    toJSON() {
        return {
            latitude: this._lat,
            longitude: this._long
        }
    }
    _compareTo(e) {
        return re(this._lat, e._lat) || re(this._long, e._long)
    }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zm {
    constructor(e) {
        this._values = (e || []).map(n => n)
    }
    toArray() {
        return this._values.map(e => e)
    }
    isEqual(e) {
        return function(r, i) {
            if (r.length !== i.length) return !1;
            for (let s = 0; s < r.length; ++s)
                if (r[s] !== i[s]) return !1;
            return !0
        }(this._values, e._values)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nL = /^__.*__$/;
class rL {
    constructor(e, n, r) {
        this.data = e, this.fieldMask = n, this.fieldTransforms = r
    }
    toMutation(e, n) {
        return this.fieldMask !== null ? new Zr(e, this.data, this.fieldMask, n, this.fieldTransforms) : new Ha(e, this.data, n, this.fieldTransforms)
    }
}
class T1 {
    constructor(e, n, r) {
        this.data = e, this.fieldMask = n, this.fieldTransforms = r
    }
    toMutation(e, n) {
        return new Zr(e, this.data, this.fieldMask, n, this.fieldTransforms)
    }
}

function E1(t) {
    switch (t) {
        case 0:
        case 2:
        case 1:
            return !0;
        case 3:
        case 4:
            return !1;
        default:
            throw Y()
    }
}
class eg {
    constructor(e, n, r, i, s, o) {
        this.settings = e, this.databaseId = n, this.serializer = r, this.ignoreUndefinedProperties = i, s === void 0 && this.Fu(), this.fieldTransforms = s || [], this.fieldMask = o || []
    }
    get path() {
        return this.settings.path
    }
    get Mu() {
        return this.settings.Mu
    }
    xu(e) {
        return new eg(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask)
    }
    Ou(e) {
        var n;
        const r = (n = this.path) === null || n === void 0 ? void 0 : n.child(e),
            i = this.xu({
                path: r,
                Nu: !1
            });
        return i.Lu(e), i
    }
    Bu(e) {
        var n;
        const r = (n = this.path) === null || n === void 0 ? void 0 : n.child(e),
            i = this.xu({
                path: r,
                Nu: !1
            });
        return i.Fu(), i
    }
    ku(e) {
        return this.xu({
            path: void 0,
            Nu: !0
        })
    }
    qu(e) {
        return ic(e, this.settings.methodName, this.settings.Qu || !1, this.path, this.settings.Ku)
    }
    contains(e) {
        return this.fieldMask.find(n => e.isPrefixOf(n)) !== void 0 || this.fieldTransforms.find(n => e.isPrefixOf(n.field)) !== void 0
    }
    Fu() {
        if (this.path)
            for (let e = 0; e < this.path.length; e++) this.Lu(this.path.get(e))
    }
    Lu(e) {
        if (e.length === 0) throw this.qu("Document fields must not be empty");
        if (E1(this.Mu) && nL.test(e)) throw this.qu('Document fields cannot begin and end with "__"')
    }
}
class iL {
    constructor(e, n, r) {
        this.databaseId = e, this.ignoreUndefinedProperties = n, this.serializer = r || Jc(e)
    }
    $u(e, n, r, i = !1) {
        return new eg({
            Mu: e,
            methodName: n,
            Ku: r,
            path: Ge.emptyPath(),
            Nu: !1,
            Qu: i
        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties)
    }
}

function tg(t) {
    const e = t._freezeSettings(),
        n = Jc(t._databaseId);
    return new iL(t._databaseId, !!e.ignoreUndefinedProperties, n)
}

function I1(t, e, n, r, i, s = {}) {
    const o = t.$u(s.merge || s.mergeFields ? 2 : 0, e, n, i);
    ng("Data must be an object, but it was:", o, r);
    const a = S1(r, o);
    let u, c;
    if (s.merge) u = new Lt(o.fieldMask), c = o.fieldTransforms;
    else if (s.mergeFields) {
        const h = [];
        for (const f of s.mergeFields) {
            const m = rp(e, f, n);
            if (!o.contains(m)) throw new z(L.INVALID_ARGUMENT, `Field '${m}' is specified in your field mask but missing from your input data.`);
            P1(h, m) || h.push(m)
        }
        u = new Lt(h), c = o.fieldTransforms.filter(f => u.covers(f.field))
    } else u = null, c = o.fieldTransforms;
    return new rL(new At(a), u, c)
}
class sh extends Xm {
    _toFieldTransform(e) {
        if (e.Mu !== 2) throw e.Mu === 1 ? e.qu(`${this._methodName}() can only appear at the top level of your update data`) : e.qu(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
        return e.fieldMask.push(e.path), null
    }
    isEqual(e) {
        return e instanceof sh
    }
}

function sL(t, e, n, r) {
    const i = t.$u(1, e, n);
    ng("Data must be an object, but it was:", i, r);
    const s = [],
        o = At.empty();
    Jr(r, (u, c) => {
        const h = rg(e, u, n);
        c = Ce(c);
        const f = i.Bu(h);
        if (c instanceof sh) s.push(h);
        else {
            const m = Xa(c, f);
            m != null && (s.push(h), o.set(h, m))
        }
    });
    const a = new Lt(s);
    return new T1(o, a, i.fieldTransforms)
}

function oL(t, e, n, r, i, s) {
    const o = t.$u(1, e, n),
        a = [rp(e, r, n)],
        u = [i];
    if (s.length % 2 != 0) throw new z(L.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
    for (let m = 0; m < s.length; m += 2) a.push(rp(e, s[m])), u.push(s[m + 1]);
    const c = [],
        h = At.empty();
    for (let m = a.length - 1; m >= 0; --m)
        if (!P1(c, a[m])) {
            const _ = a[m];
            let I = u[m];
            I = Ce(I);
            const R = o.Bu(_);
            if (I instanceof sh) c.push(_);
            else {
                const k = Xa(I, R);
                k != null && (c.push(_), h.set(_, k))
            }
        }
    const f = new Lt(c);
    return new T1(h, f, o.fieldTransforms)
}

function aL(t, e, n, r = !1) {
    return Xa(n, t.$u(r ? 4 : 3, e))
}

function Xa(t, e) {
    if (A1(t = Ce(t))) return ng("Unsupported field value:", e, t), S1(t, e);
    if (t instanceof Xm) return function(r, i) {
        if (!E1(i.Mu)) throw i.qu(`${r._methodName}() can only be used with update() and set()`);
        if (!i.path) throw i.qu(`${r._methodName}() is not currently supported inside arrays`);
        const s = r._toFieldTransform(i);
        s && i.fieldTransforms.push(s)
    }(t, e), null;
    if (t === void 0 && e.ignoreUndefinedProperties) return null;
    if (e.path && e.fieldMask.push(e.path), t instanceof Array) {
        if (e.settings.Nu && e.Mu !== 4) throw e.qu("Nested arrays are not supported");
        return function(r, i) {
            const s = [];
            let o = 0;
            for (const a of r) {
                let u = Xa(a, i.ku(o));
                u == null && (u = {
                    nullValue: "NULL_VALUE"
                }), s.push(u), o++
            }
            return {
                arrayValue: {
                    values: s
                }
            }
        }(t, e)
    }
    return function(r, i) {
        if ((r = Ce(r)) === null) return {
            nullValue: "NULL_VALUE"
        };
        if (typeof r == "number") return XD(i.serializer, r);
        if (typeof r == "boolean") return {
            booleanValue: r
        };
        if (typeof r == "string") return {
            stringValue: r
        };
        if (r instanceof Date) {
            const s = Fe.fromDate(r);
            return {
                timestampValue: ec(i.serializer, s)
            }
        }
        if (r instanceof Fe) {
            const s = new Fe(r.seconds, 1e3 * Math.floor(r.nanoseconds / 1e3));
            return {
                timestampValue: ec(i.serializer, s)
            }
        }
        if (r instanceof Jm) return {
            geoPointValue: {
                latitude: r.latitude,
                longitude: r.longitude
            }
        };
        if (r instanceof js) return {
            bytesValue: US(i.serializer, r._byteString)
        };
        if (r instanceof bt) {
            const s = i.databaseId,
                o = r.firestore._databaseId;
            if (!o.isEqual(s)) throw i.qu(`Document reference is for database ${o.projectId}/${o.database} but should be for database ${s.projectId}/${s.database}`);
            return {
                referenceValue: Um(r.firestore._databaseId || i.databaseId, r._key.path)
            }
        }
        if (r instanceof Zm) return function(o, a) {
            return {
                mapValue: {
                    fields: {
                        __type__: {
                            stringValue: "__vector__"
                        },
                        value: {
                            arrayValue: {
                                values: o.toArray().map(u => {
                                    if (typeof u != "number") throw a.qu("VectorValues must only contain numeric values.");
                                    return Om(a.serializer, u)
                                })
                            }
                        }
                    }
                }
            }
        }(r, i);
        throw i.qu(`Unsupported field value: ${th(r)}`)
    }(t, e)
}

function S1(t, e) {
    const n = {};
    return pS(t) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : Jr(t, (r, i) => {
        const s = Xa(i, e.Ou(r));
        s != null && (n[r] = s)
    }), {
        mapValue: {
            fields: n
        }
    }
}

function A1(t) {
    return !(typeof t != "object" || t === null || t instanceof Array || t instanceof Date || t instanceof Fe || t instanceof Jm || t instanceof js || t instanceof bt || t instanceof Xm || t instanceof Zm)
}

function ng(t, e, n) {
    if (!A1(n) || ! function(i) {
            return typeof i == "object" && i !== null && (Object.getPrototypeOf(i) === Object.prototype || Object.getPrototypeOf(i) === null)
        }(n)) {
        const r = th(n);
        throw r === "an object" ? e.qu(t + " a custom object") : e.qu(t + " " + r)
    }
}

function rp(t, e, n) {
    if ((e = Ce(e)) instanceof ih) return e._internalPath;
    if (typeof e == "string") return rg(t, e);
    throw ic("Field path arguments must be of type string or ", t, !1, void 0, n)
}
const lL = new RegExp("[~\\*/\\[\\]]");

function rg(t, e, n) {
    if (e.search(lL) >= 0) throw ic(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t, !1, void 0, n);
    try {
        return new ih(...e.split("."))._internalPath
    } catch {
        throw ic(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t, !1, void 0, n)
    }
}

function ic(t, e, n, r, i) {
    const s = r && !r.isEmpty(),
        o = i !== void 0;
    let a = `Function ${e}() called with invalid data`;
    n && (a += " (via `toFirestore()`)"), a += ". ";
    let u = "";
    return (s || o) && (u += " (found", s && (u += ` in field ${r}`), o && (u += ` in document ${i}`), u += ")"), new z(L.INVALID_ARGUMENT, a + t + u)
}

function P1(t, e) {
    return t.some(n => n.isEqual(e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class R1 {
    constructor(e, n, r, i, s) {
        this._firestore = e, this._userDataWriter = n, this._key = r, this._document = i, this._converter = s
    }
    get id() {
        return this._key.path.lastSegment()
    }
    get ref() {
        return new bt(this._firestore, this._converter, this._key)
    }
    exists() {
        return this._document !== null
    }
    data() {
        if (this._document) {
            if (this._converter) {
                const e = new uL(this._firestore, this._userDataWriter, this._key, this._document, null);
                return this._converter.fromFirestore(e)
            }
            return this._userDataWriter.convertValue(this._document.data.value)
        }
    }
    get(e) {
        if (this._document) {
            const n = this._document.data.field(oh("DocumentSnapshot.get", e));
            if (n !== null) return this._userDataWriter.convertValue(n)
        }
    }
}
class uL extends R1 {
    data() {
        return super.data()
    }
}

function oh(t, e) {
    return typeof e == "string" ? rg(t, e) : e instanceof ih ? e._internalPath : e._delegate._internalPath
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function cL(t) {
    if (t.limitType === "L" && t.explicitOrderBy.length === 0) throw new z(L.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause")
}
class ig {}
class sg extends ig {}

function C1(t, e, ...n) {
    let r = [];
    e instanceof ig && r.push(e), r = r.concat(n),
        function(s) {
            const o = s.filter(u => u instanceof og).length,
                a = s.filter(u => u instanceof ah).length;
            if (o > 1 || o > 0 && a > 0) throw new z(L.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.")
        }(r);
    for (const i of r) t = i._apply(t);
    return t
}
class ah extends sg {
    constructor(e, n, r) {
        super(), this._field = e, this._op = n, this._value = r, this.type = "where"
    }
    static _create(e, n, r) {
        return new ah(e, n, r)
    }
    _apply(e) {
        const n = this._parse(e);
        return k1(e._query, n), new ei(e.firestore, e.converter, Gf(e._query, n))
    }
    _parse(e) {
        const n = tg(e.firestore);
        return function(s, o, a, u, c, h, f) {
            let m;
            if (c.isKeyField()) {
                if (h === "array-contains" || h === "array-contains-any") throw new z(L.INVALID_ARGUMENT, `Invalid Query. You can't perform '${h}' queries on documentId().`);
                if (h === "in" || h === "not-in") {
                    g0(f, h);
                    const _ = [];
                    for (const I of f) _.push(m0(u, s, I));
                    m = {
                        arrayValue: {
                            values: _
                        }
                    }
                } else m = m0(u, s, f)
            } else h !== "in" && h !== "not-in" && h !== "array-contains-any" || g0(f, h), m = aL(a, o, f, h === "in" || h === "not-in");
            return Ve.create(c, h, m)
        }(e._query, "where", n, e.firestore._databaseId, this._field, this._op, this._value)
    }
}

function hL(t, e, n) {
    const r = e,
        i = oh("where", t);
    return ah._create(i, r, n)
}
class og extends ig {
    constructor(e, n) {
        super(), this.type = e, this._queryConstraints = n
    }
    static _create(e, n) {
        return new og(e, n)
    }
    _parse(e) {
        const n = this._queryConstraints.map(r => r._parse(e)).filter(r => r.getFilters().length > 0);
        return n.length === 1 ? n[0] : hn.create(n, this._getOperator())
    }
    _apply(e) {
        const n = this._parse(e);
        return n.getFilters().length === 0 ? e : (function(i, s) {
            let o = i;
            const a = s.getFlattenedFilters();
            for (const u of a) k1(o, u), o = Gf(o, u)
        }(e._query, n), new ei(e.firestore, e.converter, Gf(e._query, n)))
    }
    _getQueryConstraints() {
        return this._queryConstraints
    }
    _getOperator() {
        return this.type === "and" ? "and" : "or"
    }
}
class ag extends sg {
    constructor(e, n) {
        super(), this._field = e, this._direction = n, this.type = "orderBy"
    }
    static _create(e, n) {
        return new ag(e, n)
    }
    _apply(e) {
        const n = function(i, s, o) {
            if (i.startAt !== null) throw new z(L.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
            if (i.endAt !== null) throw new z(L.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
            return new ka(s, o)
        }(e._query, this._field, this._direction);
        return new ei(e.firestore, e.converter, function(i, s) {
            const o = i.explicitOrderBy.concat([s]);
            return new Xs(i.path, i.collectionGroup, o, i.filters.slice(), i.limit, i.limitType, i.startAt, i.endAt)
        }(e._query, n))
    }
}

function dL(t, e = "asc") {
    const n = e,
        r = oh("orderBy", t);
    return ag._create(r, n)
}
class lg extends sg {
    constructor(e, n, r) {
        super(), this.type = e, this._limit = n, this._limitType = r
    }
    static _create(e, n, r) {
        return new lg(e, n, r)
    }
    _apply(e) {
        return new ei(e.firestore, e.converter, Xu(e._query, this._limit, this._limitType))
    }
}

function fL(t) {
    return lg._create("limit", t, "F")
}

function m0(t, e, n) {
    if (typeof(n = Ce(n)) == "string") {
        if (n === "") throw new z(L.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
        if (!IS(e) && n.indexOf("/") !== -1) throw new z(L.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
        const r = e.path.child(ye.fromString(n));
        if (!H.isDocumentKey(r)) throw new z(L.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`);
        return L_(t, new H(r))
    }
    if (n instanceof bt) return L_(t, n._key);
    throw new z(L.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${th(n)}.`)
}

function g0(t, e) {
    if (!Array.isArray(t) || t.length === 0) throw new z(L.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`)
}

function k1(t, e) {
    const n = function(i, s) {
        for (const o of i)
            for (const a of o.getFlattenedFilters())
                if (s.indexOf(a.op) >= 0) return a.op;
        return null
    }(t.filters, function(i) {
        switch (i) {
            case "!=":
                return ["!=", "not-in"];
            case "array-contains-any":
            case "in":
                return ["not-in"];
            case "not-in":
                return ["array-contains-any", "in", "not-in", "!="];
            default:
                return []
        }
    }(e.op));
    if (n !== null) throw n === e.op ? new z(L.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e.op.toString()}' filter.`) : new z(L.INVALID_ARGUMENT, `Invalid query. You cannot use '${e.op.toString()}' filters with '${n.toString()}' filters.`)
}
class pL {
    convertValue(e, n = "none") {
        switch ($r(e)) {
            case 0:
                return null;
            case 1:
                return e.booleanValue;
            case 2:
                return xe(e.integerValue || e.doubleValue);
            case 3:
                return this.convertTimestamp(e.timestampValue);
            case 4:
                return this.convertServerTimestamp(e, n);
            case 5:
                return e.stringValue;
            case 6:
                return this.convertBytes(Br(e.bytesValue));
            case 7:
                return this.convertReference(e.referenceValue);
            case 8:
                return this.convertGeoPoint(e.geoPointValue);
            case 9:
                return this.convertArray(e.arrayValue, n);
            case 11:
                return this.convertObject(e.mapValue, n);
            case 10:
                return this.convertVectorValue(e.mapValue);
            default:
                throw Y()
        }
    }
    convertObject(e, n) {
        return this.convertObjectMap(e.fields, n)
    }
    convertObjectMap(e, n = "none") {
        const r = {};
        return Jr(e, (i, s) => {
            r[i] = this.convertValue(s, n)
        }), r
    }
    convertVectorValue(e) {
        var n, r, i;
        const s = (i = (r = (n = e.fields) === null || n === void 0 ? void 0 : n.value.arrayValue) === null || r === void 0 ? void 0 : r.values) === null || i === void 0 ? void 0 : i.map(o => xe(o.doubleValue));
        return new Zm(s)
    }
    convertGeoPoint(e) {
        return new Jm(xe(e.latitude), xe(e.longitude))
    }
    convertArray(e, n) {
        return (e.values || []).map(r => this.convertValue(r, n))
    }
    convertServerTimestamp(e, n) {
        switch (n) {
            case "previous":
                const r = Hc(e);
                return r == null ? null : this.convertValue(r, n);
            case "estimate":
                return this.convertTimestamp(Pa(e));
            default:
                return null
        }
    }
    convertTimestamp(e) {
        const n = jr(e);
        return new Fe(n.seconds, n.nanos)
    }
    convertDocumentKey(e, n) {
        const r = ye.fromString(e);
        ae(qS(r));
        const i = new Ra(r.get(1), r.get(3)),
            s = new H(r.popFirst(5));
        return i.isEqual(n) || Zn(`Document ${s} contains a document reference within a different database (${i.projectId}/${i.database}) which is not supported. It will be treated as a reference in the current database (${n.projectId}/${n.database}) instead.`), s
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function x1(t, e, n) {
    let r;
    return r = t ? n && (n.merge || n.mergeFields) ? t.toFirestore(e, n) : t.toFirestore(e) : e, r
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Lo {
    constructor(e, n) {
        this.hasPendingWrites = e, this.fromCache = n
    }
    isEqual(e) {
        return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache
    }
}
class b1 extends R1 {
    constructor(e, n, r, i, s, o) {
        super(e, n, r, i, o), this._firestore = e, this._firestoreImpl = e, this.metadata = s
    }
    exists() {
        return super.exists()
    }
    data(e = {}) {
        if (this._document) {
            if (this._converter) {
                const n = new du(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
                return this._converter.fromFirestore(n, e)
            }
            return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps)
        }
    }
    get(e, n = {}) {
        if (this._document) {
            const r = this._document.data.field(oh("DocumentSnapshot.get", e));
            if (r !== null) return this._userDataWriter.convertValue(r, n.serverTimestamps)
        }
    }
}
class du extends b1 {
    data(e = {}) {
        return super.data(e)
    }
}
class mL {
    constructor(e, n, r, i) {
        this._firestore = e, this._userDataWriter = n, this._snapshot = i, this.metadata = new Lo(i.hasPendingWrites, i.fromCache), this.query = r
    }
    get docs() {
        const e = [];
        return this.forEach(n => e.push(n)), e
    }
    get size() {
        return this._snapshot.docs.size
    }
    get empty() {
        return this.size === 0
    }
    forEach(e, n) {
        this._snapshot.docs.forEach(r => {
            e.call(n, new du(this._firestore, this._userDataWriter, r.key, r, new Lo(this._snapshot.mutatedKeys.has(r.key), this._snapshot.fromCache), this.query.converter))
        })
    }
    docChanges(e = {}) {
        const n = !!e.includeMetadataChanges;
        if (n && this._snapshot.excludesMetadataChanges) throw new z(L.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
        return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === n || (this._cachedChanges = function(i, s) {
            if (i._snapshot.oldDocs.isEmpty()) {
                let o = 0;
                return i._snapshot.docChanges.map(a => {
                    const u = new du(i._firestore, i._userDataWriter, a.doc.key, a.doc, new Lo(i._snapshot.mutatedKeys.has(a.doc.key), i._snapshot.fromCache), i.query.converter);
                    return a.doc, {
                        type: "added",
                        doc: u,
                        oldIndex: -1,
                        newIndex: o++
                    }
                })
            } {
                let o = i._snapshot.oldDocs;
                return i._snapshot.docChanges.filter(a => s || a.type !== 3).map(a => {
                    const u = new du(i._firestore, i._userDataWriter, a.doc.key, a.doc, new Lo(i._snapshot.mutatedKeys.has(a.doc.key), i._snapshot.fromCache), i.query.converter);
                    let c = -1,
                        h = -1;
                    return a.type !== 0 && (c = o.indexOf(a.doc.key), o = o.delete(a.doc.key)), a.type !== 1 && (o = o.add(a.doc), h = o.indexOf(a.doc.key)), {
                        type: gL(a.type),
                        doc: u,
                        oldIndex: c,
                        newIndex: h
                    }
                })
            }
        }(this, n), this._cachedChangesIncludeMetadataChanges = n), this._cachedChanges
    }
}

function gL(t) {
    switch (t) {
        case 0:
            return "added";
        case 2:
        case 3:
            return "modified";
        case 1:
            return "removed";
        default:
            return Y()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function yL(t) {
    t = Wr(t, bt);
    const e = Wr(t.firestore, Ya);
    return YO(rh(e), t._key).then(n => _L(e, t, n))
}
class N1 extends pL {
    constructor(e) {
        super(), this.firestore = e
    }
    convertBytes(e) {
        return new js(e)
    }
    convertReference(e) {
        const n = this.convertDocumentKey(e, this.firestore._databaseId);
        return new bt(this.firestore, null, n)
    }
}

function D1(t) {
    t = Wr(t, ei);
    const e = Wr(t.firestore, Ya),
        n = rh(e),
        r = new N1(e);
    return cL(t._query), XO(n, t._query).then(i => new mL(e, r, t, i))
}

function vL(t, e, n) {
    t = Wr(t, bt);
    const r = Wr(t.firestore, Ya),
        i = x1(t.converter, e, n);
    return V1(r, [I1(tg(r), "setDoc", t._key, i, t.converter !== null, n).toMutation(t._key, Xt.none())])
}

function V1(t, e) {
    return function(r, i) {
        const s = new zn;
        return r.asyncQueue.enqueueAndForget(async () => FO(await QO(r), i, s)), s.promise
    }(rh(t), e)
}

function _L(t, e, n) {
    const r = n.docs.get(e._key),
        i = new N1(t);
    return new b1(t, i, e._key, r, new Lo(n.hasPendingWrites, n.fromCache), e.converter)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wL {
    constructor(e, n) {
        this._firestore = e, this._commitHandler = n, this._mutations = [], this._committed = !1, this._dataReader = tg(e)
    }
    set(e, n, r) {
        this._verifyNotCommitted();
        const i = Id(e, this._firestore),
            s = x1(i.converter, n, r),
            o = I1(this._dataReader, "WriteBatch.set", i._key, s, i.converter !== null, r);
        return this._mutations.push(o.toMutation(i._key, Xt.none())), this
    }
    update(e, n, r, ...i) {
        this._verifyNotCommitted();
        const s = Id(e, this._firestore);
        let o;
        return o = typeof(n = Ce(n)) == "string" || n instanceof ih ? oL(this._dataReader, "WriteBatch.update", s._key, n, r, i) : sL(this._dataReader, "WriteBatch.update", s._key, n), this._mutations.push(o.toMutation(s._key, Xt.exists(!0))), this
    }
    delete(e) {
        this._verifyNotCommitted();
        const n = Id(e, this._firestore);
        return this._mutations = this._mutations.concat(new Lm(n._key, Xt.none())), this
    }
    commit() {
        return this._verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve()
    }
    _verifyNotCommitted() {
        if (this._committed) throw new z(L.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.")
    }
}

function Id(t, e) {
    if ((t = Ce(t)).firestore !== e) throw new z(L.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
    return t
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function TL(t) {
    return rh(t = Wr(t, Ya)), new wL(t, e => V1(t, e))
}(function(e, n = !0) {
    (function(i) {
        Gs = i
    })(Li), jt(new Nt("firestore", (r, {
        instanceIdentifier: i,
        options: s
    }) => {
        const o = r.getProvider("app").getImmediate(),
            a = new Ya(new dD(r.getProvider("auth-internal")), new gD(r.getProvider("app-check-internal")), function(c, h) {
                if (!Object.prototype.hasOwnProperty.apply(c.options, ["projectId"])) throw new z(L.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
                return new Ra(c.options.projectId, h)
            }(o, i), o);
        return s = Object.assign({
            useFetchStreams: n
        }, s), a._setSettings(s), a
    }, "PUBLIC").setMultipleInstances(!0)), ct(x_, "4.7.5", e), ct(x_, "4.7.5", "esm2017")
})();

function ug(t, e) {
    var n = {};
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
}

function O1() {
    return {
        "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
    }
}
const EL = O1,
    L1 = new Xr("auth", "Firebase", O1());
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sc = new jc("@firebase/auth");

function IL(t, ...e) {
    sc.logLevel <= te.WARN && sc.warn(`Auth (${Li}): ${t}`, ...e)
}

function fu(t, ...e) {
    sc.logLevel <= te.ERROR && sc.error(`Auth (${Li}): ${t}`, ...e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function tr(t, ...e) {
    throw cg(t, ...e)
}

function En(t, ...e) {
    return cg(t, ...e)
}

function M1(t, e, n) {
    const r = Object.assign(Object.assign({}, EL()), {
        [e]: n
    });
    return new Xr("auth", "Firebase", r).create(e, {
        appName: t.name
    })
}

function Ii(t) {
    return M1(t, "operation-not-supported-in-this-environment", "Operations that alter the current user are not supported in conjunction with FirebaseServerApp")
}

function cg(t, ...e) {
    if (typeof t != "string") {
        const n = e[0],
            r = [...e.slice(1)];
        return r[0] && (r[0].appName = t.name), t._errorFactory.create(n, ...r)
    }
    return L1.create(t, ...e)
}

function X(t, e, ...n) {
    if (!t) throw cg(e, ...n)
}

function Mn(t) {
    const e = "INTERNAL ASSERTION FAILED: " + t;
    throw fu(e), new Error(e)
}

function nr(t, e) {
    t || Mn(e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ip() {
    var t;
    return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.href) || ""
}

function SL() {
    return y0() === "http:" || y0() === "https:"
}

function y0() {
    var t;
    return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.protocol) || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function AL() {
    return typeof navigator < "u" && navigator && "onLine" in navigator && typeof navigator.onLine == "boolean" && (SL() || bI() || "connection" in navigator) ? navigator.onLine : !0
}

function PL() {
    if (typeof navigator > "u") return null;
    const t = navigator;
    return t.languages && t.languages[0] || t.language || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ja {
    constructor(e, n) {
        this.shortDelay = e, this.longDelay = n, nr(n > e, "Short delay should be less than long delay!"), this.isMobile = Tx() || Sx()
    }
    get() {
        return AL() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hg(t, e) {
    nr(t.emulator, "Emulator should always be set here");
    const {
        url: n
    } = t.emulator;
    return e ? `${n}${e.startsWith("/")?e.slice(1):e}` : n
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class F1 {
    static initialize(e, n, r) {
        this.fetchImpl = e, n && (this.headersImpl = n), r && (this.responseImpl = r)
    }
    static fetch() {
        if (this.fetchImpl) return this.fetchImpl;
        if (typeof self < "u" && "fetch" in self) return self.fetch;
        if (typeof globalThis < "u" && globalThis.fetch) return globalThis.fetch;
        if (typeof fetch < "u") return fetch;
        Mn("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
    static headers() {
        if (this.headersImpl) return this.headersImpl;
        if (typeof self < "u" && "Headers" in self) return self.Headers;
        if (typeof globalThis < "u" && globalThis.Headers) return globalThis.Headers;
        if (typeof Headers < "u") return Headers;
        Mn("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
    static response() {
        if (this.responseImpl) return this.responseImpl;
        if (typeof self < "u" && "Response" in self) return self.Response;
        if (typeof globalThis < "u" && globalThis.Response) return globalThis.Response;
        if (typeof Response < "u") return Response;
        Mn("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RL = {
    CREDENTIAL_MISMATCH: "custom-token-mismatch",
    MISSING_CUSTOM_TOKEN: "internal-error",
    INVALID_IDENTIFIER: "invalid-email",
    MISSING_CONTINUE_URI: "internal-error",
    INVALID_PASSWORD: "wrong-password",
    MISSING_PASSWORD: "missing-password",
    INVALID_LOGIN_CREDENTIALS: "invalid-credential",
    EMAIL_EXISTS: "email-already-in-use",
    PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
    INVALID_IDP_RESPONSE: "invalid-credential",
    INVALID_PENDING_TOKEN: "invalid-credential",
    FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
    MISSING_REQ_TYPE: "internal-error",
    EMAIL_NOT_FOUND: "user-not-found",
    RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
    EXPIRED_OOB_CODE: "expired-action-code",
    INVALID_OOB_CODE: "invalid-action-code",
    MISSING_OOB_CODE: "internal-error",
    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
    INVALID_ID_TOKEN: "invalid-user-token",
    TOKEN_EXPIRED: "user-token-expired",
    USER_NOT_FOUND: "user-token-expired",
    TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
    PASSWORD_DOES_NOT_MEET_REQUIREMENTS: "password-does-not-meet-requirements",
    INVALID_CODE: "invalid-verification-code",
    INVALID_SESSION_INFO: "invalid-verification-id",
    INVALID_TEMPORARY_PROOF: "invalid-credential",
    MISSING_SESSION_INFO: "missing-verification-id",
    SESSION_EXPIRED: "code-expired",
    MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
    UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
    INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
    ADMIN_ONLY_OPERATION: "admin-restricted-operation",
    INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
    MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
    MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
    MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
    SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
    SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
    BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
    RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
    MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
    INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
    INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
    MISSING_CLIENT_TYPE: "missing-client-type",
    MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
    INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
    INVALID_REQ_TYPE: "invalid-req-type"
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CL = new Ja(3e4, 6e4);

function dg(t, e) {
    return t.tenantId && !e.tenantId ? Object.assign(Object.assign({}, e), {
        tenantId: t.tenantId
    }) : e
}
async function Zs(t, e, n, r, i = {}) {
    return U1(t, i, async () => {
        let s = {},
            o = {};
        r && (e === "GET" ? o = r : s = {
            body: JSON.stringify(r)
        });
        const a = Wa(Object.assign({
                key: t.config.apiKey
            }, o)).slice(1),
            u = await t._getAdditionalHeaders();
        u["Content-Type"] = "application/json", t.languageCode && (u["X-Firebase-Locale"] = t.languageCode);
        const c = Object.assign({
            method: e,
            headers: u
        }, s);
        return Ix() || (c.referrerPolicy = "no-referrer"), F1.fetch()(j1(t, t.config.apiHost, n, a), c)
    })
}
async function U1(t, e, n) {
    t._canInitEmulator = !1;
    const r = Object.assign(Object.assign({}, RL), e);
    try {
        const i = new xL(t),
            s = await Promise.race([n(), i.promise]);
        i.clearNetworkTimeout();
        const o = await s.json();
        if ("needConfirmation" in o) throw zl(t, "account-exists-with-different-credential", o);
        if (s.ok && !("errorMessage" in o)) return o; {
            const a = s.ok ? o.errorMessage : o.error.message,
                [u, c] = a.split(" : ");
            if (u === "FEDERATED_USER_ID_ALREADY_LINKED") throw zl(t, "credential-already-in-use", o);
            if (u === "EMAIL_EXISTS") throw zl(t, "email-already-in-use", o);
            if (u === "USER_DISABLED") throw zl(t, "user-disabled", o);
            const h = r[u] || u.toLowerCase().replace(/[_\s]+/g, "-");
            if (c) throw M1(t, h, c);
            tr(t, h)
        }
    } catch (i) {
        if (i instanceof en) throw i;
        tr(t, "network-request-failed", {
            message: String(i)
        })
    }
}
async function kL(t, e, n, r, i = {}) {
    const s = await Zs(t, e, n, r, i);
    return "mfaPendingCredential" in s && tr(t, "multi-factor-auth-required", {
        _serverResponse: s
    }), s
}

function j1(t, e, n, r) {
    const i = `${e}${n}?${r}`;
    return t.config.emulator ? hg(t.config, i) : `${t.config.apiScheme}://${i}`
}
class xL {
    clearNetworkTimeout() {
        clearTimeout(this.timer)
    }
    constructor(e) {
        this.auth = e, this.timer = null, this.promise = new Promise((n, r) => {
            this.timer = setTimeout(() => r(En(this.auth, "network-request-failed")), CL.get())
        })
    }
}

function zl(t, e, n) {
    const r = {
        appName: t.name
    };
    n.email && (r.email = n.email), n.phoneNumber && (r.phoneNumber = n.phoneNumber);
    const i = En(t, e, r);
    return i.customData._tokenResponse = n, i
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function bL(t, e) {
    return Zs(t, "POST", "/v1/accounts:delete", e)
}
async function B1(t, e) {
    return Zs(t, "POST", "/v1/accounts:lookup", e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ea(t) {
    if (t) try {
        const e = new Date(Number(t));
        if (!isNaN(e.getTime())) return e.toUTCString()
    } catch {}
}
async function NL(t, e = !1) {
    const n = Ce(t),
        r = await n.getIdToken(e),
        i = fg(r);
    X(i && i.exp && i.auth_time && i.iat, n.auth, "internal-error");
    const s = typeof i.firebase == "object" ? i.firebase : void 0,
        o = s == null ? void 0 : s.sign_in_provider;
    return {
        claims: i,
        token: r,
        authTime: ea(Sd(i.auth_time)),
        issuedAtTime: ea(Sd(i.iat)),
        expirationTime: ea(Sd(i.exp)),
        signInProvider: o || null,
        signInSecondFactor: (s == null ? void 0 : s.sign_in_second_factor) || null
    }
}

function Sd(t) {
    return Number(t) * 1e3
}

function fg(t) {
    const [e, n, r] = t.split(".");
    if (e === void 0 || n === void 0 || r === void 0) return fu("JWT malformed, contained fewer than 3 sections"), null;
    try {
        const i = AI(n);
        return i ? JSON.parse(i) : (fu("Failed to decode base64 JWT payload"), null)
    } catch (i) {
        return fu("Caught error parsing JWT payload as JSON", i == null ? void 0 : i.toString()), null
    }
}

function v0(t) {
    const e = fg(t);
    return X(e, "internal-error"), X(typeof e.exp < "u", "internal-error"), X(typeof e.iat < "u", "internal-error"), Number(e.exp) - Number(e.iat)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Na(t, e, n = !1) {
    if (n) return e;
    try {
        return await e
    } catch (r) {
        throw r instanceof en && DL(r) && t.auth.currentUser === t && await t.auth.signOut(), r
    }
}

function DL({
    code: t
}) {
    return t === "auth/user-disabled" || t === "auth/user-token-expired"
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VL {
    constructor(e) {
        this.user = e, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4
    }
    _start() {
        this.isRunning || (this.isRunning = !0, this.schedule())
    }
    _stop() {
        this.isRunning && (this.isRunning = !1, this.timerId !== null && clearTimeout(this.timerId))
    }
    getInterval(e) {
        var n;
        if (e) {
            const r = this.errorBackoff;
            return this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4), r
        } else {
            this.errorBackoff = 3e4;
            const i = ((n = this.user.stsTokenManager.expirationTime) !== null && n !== void 0 ? n : 0) - Date.now() - 3e5;
            return Math.max(0, i)
        }
    }
    schedule(e = !1) {
        if (!this.isRunning) return;
        const n = this.getInterval(e);
        this.timerId = setTimeout(async () => {
            await this.iteration()
        }, n)
    }
    async iteration() {
        try {
            await this.user.getIdToken(!0)
        } catch (e) {
            (e == null ? void 0 : e.code) === "auth/network-request-failed" && this.schedule(!0);
            return
        }
        this.schedule()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sp {
    constructor(e, n) {
        this.createdAt = e, this.lastLoginAt = n, this._initializeTime()
    }
    _initializeTime() {
        this.lastSignInTime = ea(this.lastLoginAt), this.creationTime = ea(this.createdAt)
    }
    _copy(e) {
        this.createdAt = e.createdAt, this.lastLoginAt = e.lastLoginAt, this._initializeTime()
    }
    toJSON() {
        return {
            createdAt: this.createdAt,
            lastLoginAt: this.lastLoginAt
        }
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function oc(t) {
    var e;
    const n = t.auth,
        r = await t.getIdToken(),
        i = await Na(t, B1(n, {
            idToken: r
        }));
    X(i == null ? void 0 : i.users.length, n, "internal-error");
    const s = i.users[0];
    t._notifyReloadListener(s);
    const o = !((e = s.providerUserInfo) === null || e === void 0) && e.length ? $1(s.providerUserInfo) : [],
        a = LL(t.providerData, o),
        u = t.isAnonymous,
        c = !(t.email && s.passwordHash) && !(a != null && a.length),
        h = u ? c : !1,
        f = {
            uid: s.localId,
            displayName: s.displayName || null,
            photoURL: s.photoUrl || null,
            email: s.email || null,
            emailVerified: s.emailVerified || !1,
            phoneNumber: s.phoneNumber || null,
            tenantId: s.tenantId || null,
            providerData: a,
            metadata: new sp(s.createdAt, s.lastLoginAt),
            isAnonymous: h
        };
    Object.assign(t, f)
}
async function OL(t) {
    const e = Ce(t);
    await oc(e), await e.auth._persistUserIfCurrent(e), e.auth._notifyListenersIfCurrent(e)
}

function LL(t, e) {
    return [...t.filter(r => !e.some(i => i.providerId === r.providerId)), ...e]
}

function $1(t) {
    return t.map(e => {
        var {
            providerId: n
        } = e, r = ug(e, ["providerId"]);
        return {
            providerId: n,
            uid: r.rawId || "",
            displayName: r.displayName || null,
            email: r.email || null,
            phoneNumber: r.phoneNumber || null,
            photoURL: r.photoUrl || null
        }
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ML(t, e) {
    const n = await U1(t, {}, async () => {
        const r = Wa({
                grant_type: "refresh_token",
                refresh_token: e
            }).slice(1),
            {
                tokenApiHost: i,
                apiKey: s
            } = t.config,
            o = j1(t, i, "/v1/token", `key=${s}`),
            a = await t._getAdditionalHeaders();
        return a["Content-Type"] = "application/x-www-form-urlencoded", F1.fetch()(o, {
            method: "POST",
            headers: a,
            body: r
        })
    });
    return {
        accessToken: n.access_token,
        expiresIn: n.expires_in,
        refreshToken: n.refresh_token
    }
}
async function FL(t, e) {
    return Zs(t, "POST", "/v2/accounts:revokeToken", dg(t, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ss {
    constructor() {
        this.refreshToken = null, this.accessToken = null, this.expirationTime = null
    }
    get isExpired() {
        return !this.expirationTime || Date.now() > this.expirationTime - 3e4
    }
    updateFromServerResponse(e) {
        X(e.idToken, "internal-error"), X(typeof e.idToken < "u", "internal-error"), X(typeof e.refreshToken < "u", "internal-error");
        const n = "expiresIn" in e && typeof e.expiresIn < "u" ? Number(e.expiresIn) : v0(e.idToken);
        this.updateTokensAndExpiration(e.idToken, e.refreshToken, n)
    }
    updateFromIdToken(e) {
        X(e.length !== 0, "internal-error");
        const n = v0(e);
        this.updateTokensAndExpiration(e, null, n)
    }
    async getToken(e, n = !1) {
        return !n && this.accessToken && !this.isExpired ? this.accessToken : (X(this.refreshToken, e, "user-token-expired"), this.refreshToken ? (await this.refresh(e, this.refreshToken), this.accessToken) : null)
    }
    clearRefreshToken() {
        this.refreshToken = null
    }
    async refresh(e, n) {
        const {
            accessToken: r,
            refreshToken: i,
            expiresIn: s
        } = await ML(e, n);
        this.updateTokensAndExpiration(r, i, Number(s))
    }
    updateTokensAndExpiration(e, n, r) {
        this.refreshToken = n || null, this.accessToken = e || null, this.expirationTime = Date.now() + r * 1e3
    }
    static fromJSON(e, n) {
        const {
            refreshToken: r,
            accessToken: i,
            expirationTime: s
        } = n, o = new Ss;
        return r && (X(typeof r == "string", "internal-error", {
            appName: e
        }), o.refreshToken = r), i && (X(typeof i == "string", "internal-error", {
            appName: e
        }), o.accessToken = i), s && (X(typeof s == "number", "internal-error", {
            appName: e
        }), o.expirationTime = s), o
    }
    toJSON() {
        return {
            refreshToken: this.refreshToken,
            accessToken: this.accessToken,
            expirationTime: this.expirationTime
        }
    }
    _assign(e) {
        this.accessToken = e.accessToken, this.refreshToken = e.refreshToken, this.expirationTime = e.expirationTime
    }
    _clone() {
        return Object.assign(new Ss, this.toJSON())
    }
    _performRefresh() {
        return Mn("not implemented")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function dr(t, e) {
    X(typeof t == "string" || typeof t > "u", "internal-error", {
        appName: e
    })
}
class Fn {
    constructor(e) {
        var {
            uid: n,
            auth: r,
            stsTokenManager: i
        } = e, s = ug(e, ["uid", "auth", "stsTokenManager"]);
        this.providerId = "firebase", this.proactiveRefresh = new VL(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = n, this.auth = r, this.stsTokenManager = i, this.accessToken = i.accessToken, this.displayName = s.displayName || null, this.email = s.email || null, this.emailVerified = s.emailVerified || !1, this.phoneNumber = s.phoneNumber || null, this.photoURL = s.photoURL || null, this.isAnonymous = s.isAnonymous || !1, this.tenantId = s.tenantId || null, this.providerData = s.providerData ? [...s.providerData] : [], this.metadata = new sp(s.createdAt || void 0, s.lastLoginAt || void 0)
    }
    async getIdToken(e) {
        const n = await Na(this, this.stsTokenManager.getToken(this.auth, e));
        return X(n, this.auth, "internal-error"), this.accessToken !== n && (this.accessToken = n, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), n
    }
    getIdTokenResult(e) {
        return NL(this, e)
    }
    reload() {
        return OL(this)
    }
    _assign(e) {
        this !== e && (X(this.uid === e.uid, this.auth, "internal-error"), this.displayName = e.displayName, this.photoURL = e.photoURL, this.email = e.email, this.emailVerified = e.emailVerified, this.phoneNumber = e.phoneNumber, this.isAnonymous = e.isAnonymous, this.tenantId = e.tenantId, this.providerData = e.providerData.map(n => Object.assign({}, n)), this.metadata._copy(e.metadata), this.stsTokenManager._assign(e.stsTokenManager))
    }
    _clone(e) {
        const n = new Fn(Object.assign(Object.assign({}, this), {
            auth: e,
            stsTokenManager: this.stsTokenManager._clone()
        }));
        return n.metadata._copy(this.metadata), n
    }
    _onReload(e) {
        X(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = e, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null)
    }
    _notifyReloadListener(e) {
        this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e
    }
    _startProactiveRefresh() {
        this.proactiveRefresh._start()
    }
    _stopProactiveRefresh() {
        this.proactiveRefresh._stop()
    }
    async _updateTokensIfNecessary(e, n = !1) {
        let r = !1;
        e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e), r = !0), n && await oc(this), await this.auth._persistUserIfCurrent(this), r && this.auth._notifyListenersIfCurrent(this)
    }
    async delete() {
        if (Sr(this.auth.app)) return Promise.reject(Ii(this.auth));
        const e = await this.getIdToken();
        return await Na(this, bL(this.auth, {
            idToken: e
        })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut()
    }
    toJSON() {
        return Object.assign(Object.assign({
            uid: this.uid,
            email: this.email || void 0,
            emailVerified: this.emailVerified,
            displayName: this.displayName || void 0,
            isAnonymous: this.isAnonymous,
            photoURL: this.photoURL || void 0,
            phoneNumber: this.phoneNumber || void 0,
            tenantId: this.tenantId || void 0,
            providerData: this.providerData.map(e => Object.assign({}, e)),
            stsTokenManager: this.stsTokenManager.toJSON(),
            _redirectEventId: this._redirectEventId
        }, this.metadata.toJSON()), {
            apiKey: this.auth.config.apiKey,
            appName: this.auth.name
        })
    }
    get refreshToken() {
        return this.stsTokenManager.refreshToken || ""
    }
    static _fromJSON(e, n) {
        var r, i, s, o, a, u, c, h;
        const f = (r = n.displayName) !== null && r !== void 0 ? r : void 0,
            m = (i = n.email) !== null && i !== void 0 ? i : void 0,
            _ = (s = n.phoneNumber) !== null && s !== void 0 ? s : void 0,
            I = (o = n.photoURL) !== null && o !== void 0 ? o : void 0,
            R = (a = n.tenantId) !== null && a !== void 0 ? a : void 0,
            k = (u = n._redirectEventId) !== null && u !== void 0 ? u : void 0,
            w = (c = n.createdAt) !== null && c !== void 0 ? c : void 0,
            v = (h = n.lastLoginAt) !== null && h !== void 0 ? h : void 0,
            {
                uid: T,
                emailVerified: x,
                isAnonymous: O,
                providerData: U,
                stsTokenManager: S
            } = n;
        X(T && S, e, "internal-error");
        const g = Ss.fromJSON(this.name, S);
        X(typeof T == "string", e, "internal-error"), dr(f, e.name), dr(m, e.name), X(typeof x == "boolean", e, "internal-error"), X(typeof O == "boolean", e, "internal-error"), dr(_, e.name), dr(I, e.name), dr(R, e.name), dr(k, e.name), dr(w, e.name), dr(v, e.name);
        const E = new Fn({
            uid: T,
            auth: e,
            email: m,
            emailVerified: x,
            displayName: f,
            isAnonymous: O,
            photoURL: I,
            phoneNumber: _,
            tenantId: R,
            stsTokenManager: g,
            createdAt: w,
            lastLoginAt: v
        });
        return U && Array.isArray(U) && (E.providerData = U.map(A => Object.assign({}, A))), k && (E._redirectEventId = k), E
    }
    static async _fromIdTokenResponse(e, n, r = !1) {
        const i = new Ss;
        i.updateFromServerResponse(n);
        const s = new Fn({
            uid: n.localId,
            auth: e,
            stsTokenManager: i,
            isAnonymous: r
        });
        return await oc(s), s
    }
    static async _fromGetAccountInfoResponse(e, n, r) {
        const i = n.users[0];
        X(i.localId !== void 0, "internal-error");
        const s = i.providerUserInfo !== void 0 ? $1(i.providerUserInfo) : [],
            o = !(i.email && i.passwordHash) && !(s != null && s.length),
            a = new Ss;
        a.updateFromIdToken(r);
        const u = new Fn({
                uid: i.localId,
                auth: e,
                stsTokenManager: a,
                isAnonymous: o
            }),
            c = {
                uid: i.localId,
                displayName: i.displayName || null,
                photoURL: i.photoUrl || null,
                email: i.email || null,
                emailVerified: i.emailVerified || !1,
                phoneNumber: i.phoneNumber || null,
                tenantId: i.tenantId || null,
                providerData: s,
                metadata: new sp(i.createdAt, i.lastLoginAt),
                isAnonymous: !(i.email && i.passwordHash) && !(s != null && s.length)
            };
        return Object.assign(u, c), u
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _0 = new Map;

function Un(t) {
    nr(t instanceof Function, "Expected a class definition");
    let e = _0.get(t);
    return e ? (nr(e instanceof t, "Instance stored in cache mismatched with class"), e) : (e = new t, _0.set(t, e), e)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class z1 {
    constructor() {
        this.type = "NONE", this.storage = {}
    }
    async _isAvailable() {
        return !0
    }
    async _set(e, n) {
        this.storage[e] = n
    }
    async _get(e) {
        const n = this.storage[e];
        return n === void 0 ? null : n
    }
    async _remove(e) {
        delete this.storage[e]
    }
    _addListener(e, n) {}
    _removeListener(e, n) {}
}
z1.type = "NONE";
const w0 = z1;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function pu(t, e, n) {
    return `firebase:${t}:${e}:${n}`
}
class As {
    constructor(e, n, r) {
        this.persistence = e, this.auth = n, this.userKey = r;
        const {
            config: i,
            name: s
        } = this.auth;
        this.fullUserKey = pu(this.userKey, i.apiKey, s), this.fullPersistenceKey = pu("persistence", i.apiKey, s), this.boundEventHandler = n._onStorageEvent.bind(n), this.persistence._addListener(this.fullUserKey, this.boundEventHandler)
    }
    setCurrentUser(e) {
        return this.persistence._set(this.fullUserKey, e.toJSON())
    }
    async getCurrentUser() {
        const e = await this.persistence._get(this.fullUserKey);
        return e ? Fn._fromJSON(this.auth, e) : null
    }
    removeCurrentUser() {
        return this.persistence._remove(this.fullUserKey)
    }
    savePersistenceForRedirect() {
        return this.persistence._set(this.fullPersistenceKey, this.persistence.type)
    }
    async setPersistence(e) {
        if (this.persistence === e) return;
        const n = await this.getCurrentUser();
        if (await this.removeCurrentUser(), this.persistence = e, n) return this.setCurrentUser(n)
    }
    delete() {
        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler)
    }
    static async create(e, n, r = "authUser") {
        if (!n.length) return new As(Un(w0), e, r);
        const i = (await Promise.all(n.map(async c => {
            if (await c._isAvailable()) return c
        }))).filter(c => c);
        let s = i[0] || Un(w0);
        const o = pu(r, e.config.apiKey, e.name);
        let a = null;
        for (const c of n) try {
            const h = await c._get(o);
            if (h) {
                const f = Fn._fromJSON(e, h);
                c !== s && (a = f), s = c;
                break
            }
        } catch {}
        const u = i.filter(c => c._shouldAllowMigration);
        return !s._shouldAllowMigration || !u.length ? new As(s, e, r) : (s = u[0], a && await s._set(o, a.toJSON()), await Promise.all(n.map(async c => {
            if (c !== s) try {
                await c._remove(o)
            } catch {}
        })), new As(s, e, r))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function T0(t) {
    const e = t.toLowerCase();
    if (e.includes("opera/") || e.includes("opr/") || e.includes("opios/")) return "Opera";
    if (K1(e)) return "IEMobile";
    if (e.includes("msie") || e.includes("trident/")) return "IE";
    if (e.includes("edge/")) return "Edge";
    if (W1(e)) return "Firefox";
    if (e.includes("silk/")) return "Silk";
    if (Q1(e)) return "Blackberry";
    if (Y1(e)) return "Webos";
    if (q1(e)) return "Safari";
    if ((e.includes("chrome/") || H1(e)) && !e.includes("edge/")) return "Chrome";
    if (G1(e)) return "Android"; {
        const n = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,
            r = t.match(n);
        if ((r == null ? void 0 : r.length) === 2) return r[1]
    }
    return "Other"
}

function W1(t = pt()) {
    return /firefox\//i.test(t)
}

function q1(t = pt()) {
    const e = t.toLowerCase();
    return e.includes("safari/") && !e.includes("chrome/") && !e.includes("crios/") && !e.includes("android")
}

function H1(t = pt()) {
    return /crios\//i.test(t)
}

function K1(t = pt()) {
    return /iemobile/i.test(t)
}

function G1(t = pt()) {
    return /android/i.test(t)
}

function Q1(t = pt()) {
    return /blackberry/i.test(t)
}

function Y1(t = pt()) {
    return /webos/i.test(t)
}

function pg(t = pt()) {
    return /iphone|ipad|ipod/i.test(t) || /macintosh/i.test(t) && /mobile/i.test(t)
}

function UL(t = pt()) {
    var e;
    return pg(t) && !!(!((e = window.navigator) === null || e === void 0) && e.standalone)
}

function jL() {
    return Ax() && document.documentMode === 10
}

function X1(t = pt()) {
    return pg(t) || G1(t) || Y1(t) || Q1(t) || /windows phone/i.test(t) || K1(t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function J1(t, e = []) {
    let n;
    switch (t) {
        case "Browser":
            n = T0(pt());
            break;
        case "Worker":
            n = `${T0(pt())}-${t}`;
            break;
        default:
            n = t
    }
    const r = e.length ? e.join(",") : "FirebaseCore-web";
    return `${n}/JsCore/${Li}/${r}`
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BL {
    constructor(e) {
        this.auth = e, this.queue = []
    }
    pushCallback(e, n) {
        const r = s => new Promise((o, a) => {
            try {
                const u = e(s);
                o(u)
            } catch (u) {
                a(u)
            }
        });
        r.onAbort = n, this.queue.push(r);
        const i = this.queue.length - 1;
        return () => {
            this.queue[i] = () => Promise.resolve()
        }
    }
    async runMiddleware(e) {
        if (this.auth.currentUser === e) return;
        const n = [];
        try {
            for (const r of this.queue) await r(e), r.onAbort && n.push(r.onAbort)
        } catch (r) {
            n.reverse();
            for (const i of n) try {
                i()
            } catch {}
            throw this.auth._errorFactory.create("login-blocked", {
                originalMessage: r == null ? void 0 : r.message
            })
        }
    }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function $L(t, e = {}) {
    return Zs(t, "GET", "/v2/passwordPolicy", dg(t, e))
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const zL = 6;
class WL {
    constructor(e) {
        var n, r, i, s;
        const o = e.customStrengthOptions;
        this.customStrengthOptions = {}, this.customStrengthOptions.minPasswordLength = (n = o.minPasswordLength) !== null && n !== void 0 ? n : zL, o.maxPasswordLength && (this.customStrengthOptions.maxPasswordLength = o.maxPasswordLength), o.containsLowercaseCharacter !== void 0 && (this.customStrengthOptions.containsLowercaseLetter = o.containsLowercaseCharacter), o.containsUppercaseCharacter !== void 0 && (this.customStrengthOptions.containsUppercaseLetter = o.containsUppercaseCharacter), o.containsNumericCharacter !== void 0 && (this.customStrengthOptions.containsNumericCharacter = o.containsNumericCharacter), o.containsNonAlphanumericCharacter !== void 0 && (this.customStrengthOptions.containsNonAlphanumericCharacter = o.containsNonAlphanumericCharacter), this.enforcementState = e.enforcementState, this.enforcementState === "ENFORCEMENT_STATE_UNSPECIFIED" && (this.enforcementState = "OFF"), this.allowedNonAlphanumericCharacters = (i = (r = e.allowedNonAlphanumericCharacters) === null || r === void 0 ? void 0 : r.join("")) !== null && i !== void 0 ? i : "", this.forceUpgradeOnSignin = (s = e.forceUpgradeOnSignin) !== null && s !== void 0 ? s : !1, this.schemaVersion = e.schemaVersion
    }
    validatePassword(e) {
        var n, r, i, s, o, a;
        const u = {
            isValid: !0,
            passwordPolicy: this
        };
        return this.validatePasswordLengthOptions(e, u), this.validatePasswordCharacterOptions(e, u), u.isValid && (u.isValid = (n = u.meetsMinPasswordLength) !== null && n !== void 0 ? n : !0), u.isValid && (u.isValid = (r = u.meetsMaxPasswordLength) !== null && r !== void 0 ? r : !0), u.isValid && (u.isValid = (i = u.containsLowercaseLetter) !== null && i !== void 0 ? i : !0), u.isValid && (u.isValid = (s = u.containsUppercaseLetter) !== null && s !== void 0 ? s : !0), u.isValid && (u.isValid = (o = u.containsNumericCharacter) !== null && o !== void 0 ? o : !0), u.isValid && (u.isValid = (a = u.containsNonAlphanumericCharacter) !== null && a !== void 0 ? a : !0), u
    }
    validatePasswordLengthOptions(e, n) {
        const r = this.customStrengthOptions.minPasswordLength,
            i = this.customStrengthOptions.maxPasswordLength;
        r && (n.meetsMinPasswordLength = e.length >= r), i && (n.meetsMaxPasswordLength = e.length <= i)
    }
    validatePasswordCharacterOptions(e, n) {
        this.updatePasswordCharacterOptionsStatuses(n, !1, !1, !1, !1);
        let r;
        for (let i = 0; i < e.length; i++) r = e.charAt(i), this.updatePasswordCharacterOptionsStatuses(n, r >= "a" && r <= "z", r >= "A" && r <= "Z", r >= "0" && r <= "9", this.allowedNonAlphanumericCharacters.includes(r))
    }
    updatePasswordCharacterOptionsStatuses(e, n, r, i, s) {
        this.customStrengthOptions.containsLowercaseLetter && (e.containsLowercaseLetter || (e.containsLowercaseLetter = n)), this.customStrengthOptions.containsUppercaseLetter && (e.containsUppercaseLetter || (e.containsUppercaseLetter = r)), this.customStrengthOptions.containsNumericCharacter && (e.containsNumericCharacter || (e.containsNumericCharacter = i)), this.customStrengthOptions.containsNonAlphanumericCharacter && (e.containsNonAlphanumericCharacter || (e.containsNonAlphanumericCharacter = s))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qL {
    constructor(e, n, r, i) {
        this.app = e, this.heartbeatServiceProvider = n, this.appCheckServiceProvider = r, this.config = i, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new E0(this), this.idTokenSubscription = new E0(this), this.beforeStateQueue = new BL(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = L1, this._agentRecaptchaConfig = null, this._tenantRecaptchaConfigs = {}, this._projectPasswordPolicy = null, this._tenantPasswordPolicies = {}, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = {
            appVerificationDisabledForTesting: !1
        }, this.frameworks = [], this.name = e.name, this.clientVersion = i.sdkClientVersion
    }
    _initializeWithPersistence(e, n) {
        return n && (this._popupRedirectResolver = Un(n)), this._initializationPromise = this.queue(async () => {
            var r, i;
            if (!this._deleted && (this.persistenceManager = await As.create(this, e), !this._deleted)) {
                if (!((r = this._popupRedirectResolver) === null || r === void 0) && r._shouldInitProactively) try {
                    await this._popupRedirectResolver._initialize(this)
                } catch {}
                await this.initializeCurrentUser(n), this.lastNotifiedUid = ((i = this.currentUser) === null || i === void 0 ? void 0 : i.uid) || null, !this._deleted && (this._isInitialized = !0)
            }
        }), this._initializationPromise
    }
    async _onStorageEvent() {
        if (this._deleted) return;
        const e = await this.assertedPersistence.getCurrentUser();
        if (!(!this.currentUser && !e)) {
            if (this.currentUser && e && this.currentUser.uid === e.uid) {
                this._currentUser._assign(e), await this.currentUser.getIdToken();
                return
            }
            await this._updateCurrentUser(e, !0)
        }
    }
    async initializeCurrentUserFromIdToken(e) {
        try {
            const n = await B1(this, {
                    idToken: e
                }),
                r = await Fn._fromGetAccountInfoResponse(this, n, e);
            await this.directlySetCurrentUser(r)
        } catch (n) {
            console.warn("FirebaseServerApp could not login user with provided authIdToken: ", n), await this.directlySetCurrentUser(null)
        }
    }
    async initializeCurrentUser(e) {
        var n;
        if (Sr(this.app)) {
            const o = this.app.settings.authIdToken;
            return o ? new Promise(a => {
                setTimeout(() => this.initializeCurrentUserFromIdToken(o).then(a, a))
            }) : this.directlySetCurrentUser(null)
        }
        const r = await this.assertedPersistence.getCurrentUser();
        let i = r,
            s = !1;
        if (e && this.config.authDomain) {
            await this.getOrInitRedirectPersistenceManager();
            const o = (n = this.redirectUser) === null || n === void 0 ? void 0 : n._redirectEventId,
                a = i == null ? void 0 : i._redirectEventId,
                u = await this.tryRedirectSignIn(e);
            (!o || o === a) && (u != null && u.user) && (i = u.user, s = !0)
        }
        if (!i) return this.directlySetCurrentUser(null);
        if (!i._redirectEventId) {
            if (s) try {
                await this.beforeStateQueue.runMiddleware(i)
            } catch (o) {
                i = r, this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(o))
            }
            return i ? this.reloadAndSetCurrentUserOrClear(i) : this.directlySetCurrentUser(null)
        }
        return X(this._popupRedirectResolver, this, "argument-error"), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === i._redirectEventId ? this.directlySetCurrentUser(i) : this.reloadAndSetCurrentUserOrClear(i)
    }
    async tryRedirectSignIn(e) {
        let n = null;
        try {
            n = await this._popupRedirectResolver._completeRedirectFn(this, e, !0)
        } catch {
            await this._setRedirectUser(null)
        }
        return n
    }
    async reloadAndSetCurrentUserOrClear(e) {
        try {
            await oc(e)
        } catch (n) {
            if ((n == null ? void 0 : n.code) !== "auth/network-request-failed") return this.directlySetCurrentUser(null)
        }
        return this.directlySetCurrentUser(e)
    }
    useDeviceLanguage() {
        this.languageCode = PL()
    }
    async _delete() {
        this._deleted = !0
    }
    async updateCurrentUser(e) {
        if (Sr(this.app)) return Promise.reject(Ii(this));
        const n = e ? Ce(e) : null;
        return n && X(n.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"), this._updateCurrentUser(n && n._clone(this))
    }
    async _updateCurrentUser(e, n = !1) {
        if (!this._deleted) return e && X(this.tenantId === e.tenantId, this, "tenant-id-mismatch"), n || await this.beforeStateQueue.runMiddleware(e), this.queue(async () => {
            await this.directlySetCurrentUser(e), this.notifyAuthListeners()
        })
    }
    async signOut() {
        return Sr(this.app) ? Promise.reject(Ii(this)) : (await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(null, !0))
    }
    setPersistence(e) {
        return Sr(this.app) ? Promise.reject(Ii(this)) : this.queue(async () => {
            await this.assertedPersistence.setPersistence(Un(e))
        })
    }
    _getRecaptchaConfig() {
        return this.tenantId == null ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId]
    }
    async validatePassword(e) {
        this._getPasswordPolicyInternal() || await this._updatePasswordPolicy();
        const n = this._getPasswordPolicyInternal();
        return n.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION ? Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {})) : n.validatePassword(e)
    }
    _getPasswordPolicyInternal() {
        return this.tenantId === null ? this._projectPasswordPolicy : this._tenantPasswordPolicies[this.tenantId]
    }
    async _updatePasswordPolicy() {
        const e = await $L(this),
            n = new WL(e);
        this.tenantId === null ? this._projectPasswordPolicy = n : this._tenantPasswordPolicies[this.tenantId] = n
    }
    _getPersistence() {
        return this.assertedPersistence.persistence.type
    }
    _updateErrorMap(e) {
        this._errorFactory = new Xr("auth", "Firebase", e())
    }
    onAuthStateChanged(e, n, r) {
        return this.registerStateListener(this.authStateSubscription, e, n, r)
    }
    beforeAuthStateChanged(e, n) {
        return this.beforeStateQueue.pushCallback(e, n)
    }
    onIdTokenChanged(e, n, r) {
        return this.registerStateListener(this.idTokenSubscription, e, n, r)
    }
    authStateReady() {
        return new Promise((e, n) => {
            if (this.currentUser) e();
            else {
                const r = this.onAuthStateChanged(() => {
                    r(), e()
                }, n)
            }
        })
    }
    async revokeAccessToken(e) {
        if (this.currentUser) {
            const n = await this.currentUser.getIdToken(),
                r = {
                    providerId: "apple.com",
                    tokenType: "ACCESS_TOKEN",
                    token: e,
                    idToken: n
                };
            this.tenantId != null && (r.tenantId = this.tenantId), await FL(this, r)
        }
    }
    toJSON() {
        var e;
        return {
            apiKey: this.config.apiKey,
            authDomain: this.config.authDomain,
            appName: this.name,
            currentUser: (e = this._currentUser) === null || e === void 0 ? void 0 : e.toJSON()
        }
    }
    async _setRedirectUser(e, n) {
        const r = await this.getOrInitRedirectPersistenceManager(n);
        return e === null ? r.removeCurrentUser() : r.setCurrentUser(e)
    }
    async getOrInitRedirectPersistenceManager(e) {
        if (!this.redirectPersistenceManager) {
            const n = e && Un(e) || this._popupRedirectResolver;
            X(n, this, "argument-error"), this.redirectPersistenceManager = await As.create(this, [Un(n._redirectPersistence)], "redirectUser"), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser()
        }
        return this.redirectPersistenceManager
    }
    async _redirectUserForId(e) {
        var n, r;
        return this._isInitialized && await this.queue(async () => {}), ((n = this._currentUser) === null || n === void 0 ? void 0 : n._redirectEventId) === e ? this._currentUser : ((r = this.redirectUser) === null || r === void 0 ? void 0 : r._redirectEventId) === e ? this.redirectUser : null
    }
    async _persistUserIfCurrent(e) {
        if (e === this.currentUser) return this.queue(async () => this.directlySetCurrentUser(e))
    }
    _notifyListenersIfCurrent(e) {
        e === this.currentUser && this.notifyAuthListeners()
    }
    _key() {
        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`
    }
    _startProactiveRefresh() {
        this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh()
    }
    _stopProactiveRefresh() {
        this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh()
    }
    get _currentUser() {
        return this.currentUser
    }
    notifyAuthListeners() {
        var e, n;
        if (!this._isInitialized) return;
        this.idTokenSubscription.next(this.currentUser);
        const r = (n = (e = this.currentUser) === null || e === void 0 ? void 0 : e.uid) !== null && n !== void 0 ? n : null;
        this.lastNotifiedUid !== r && (this.lastNotifiedUid = r, this.authStateSubscription.next(this.currentUser))
    }
    registerStateListener(e, n, r, i) {
        if (this._deleted) return () => {};
        const s = typeof n == "function" ? n : n.next.bind(n);
        let o = !1;
        const a = this._isInitialized ? Promise.resolve() : this._initializationPromise;
        if (X(a, this, "internal-error"), a.then(() => {
                o || s(this.currentUser)
            }), typeof n == "function") {
            const u = e.addObserver(n, r, i);
            return () => {
                o = !0, u()
            }
        } else {
            const u = e.addObserver(n);
            return () => {
                o = !0, u()
            }
        }
    }
    async directlySetCurrentUser(e) {
        this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(), e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(), this.currentUser = e, e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser()
    }
    queue(e) {
        return this.operations = this.operations.then(e, e), this.operations
    }
    get assertedPersistence() {
        return X(this.persistenceManager, this, "internal-error"), this.persistenceManager
    }
    _logFramework(e) {
        !e || this.frameworks.includes(e) || (this.frameworks.push(e), this.frameworks.sort(), this.clientVersion = J1(this.config.clientPlatform, this._getFrameworks()))
    }
    _getFrameworks() {
        return this.frameworks
    }
    async _getAdditionalHeaders() {
        var e;
        const n = {
            "X-Client-Version": this.clientVersion
        };
        this.app.options.appId && (n["X-Firebase-gmpid"] = this.app.options.appId);
        const r = await ((e = this.heartbeatServiceProvider.getImmediate({
            optional: !0
        })) === null || e === void 0 ? void 0 : e.getHeartbeatsHeader());
        r && (n["X-Firebase-Client"] = r);
        const i = await this._getAppCheckToken();
        return i && (n["X-Firebase-AppCheck"] = i), n
    }
    async _getAppCheckToken() {
        var e;
        const n = await ((e = this.appCheckServiceProvider.getImmediate({
            optional: !0
        })) === null || e === void 0 ? void 0 : e.getToken());
        return n != null && n.error && IL(`Error while retrieving App Check token: ${n.error}`), n == null ? void 0 : n.token
    }
}

function mg(t) {
    return Ce(t)
}
class E0 {
    constructor(e) {
        this.auth = e, this.observer = null, this.addObserver = bx(n => this.observer = n)
    }
    get next() {
        return X(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let gg = {
    async loadJS() {
        throw new Error("Unable to load external scripts")
    },
    recaptchaV2Script: "",
    recaptchaEnterpriseScript: "",
    gapiScript: ""
};

function HL(t) {
    gg = t
}

function KL(t) {
    return gg.loadJS(t)
}

function GL() {
    return gg.gapiScript
}

function QL(t) {
    return `__${t}${Math.floor(Math.random()*1e6)}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function YL(t, e) {
    const n = ir(t, "auth");
    if (n.isInitialized()) {
        const i = n.getImmediate(),
            s = n.getOptions();
        if (Ia(s, e ? ? {})) return i;
        tr(i, "already-initialized")
    }
    return n.initialize({
        options: e
    })
}

function XL(t, e) {
    const n = (e == null ? void 0 : e.persistence) || [],
        r = (Array.isArray(n) ? n : [n]).map(Un);
    e != null && e.errorMap && t._updateErrorMap(e.errorMap), t._initializeWithPersistence(r, e == null ? void 0 : e.popupRedirectResolver)
}

function JL(t, e, n) {
    const r = mg(t);
    X(r._canInitEmulator, r, "emulator-config-failed"), X(/^https?:\/\//.test(e), r, "invalid-emulator-scheme");
    const i = !1,
        s = Z1(e),
        {
            host: o,
            port: a
        } = ZL(e),
        u = a === null ? "" : `:${a}`;
    r.config.emulator = {
        url: `${s}//${o}${u}/`
    }, r.settings.appVerificationDisabledForTesting = !0, r.emulatorConfig = Object.freeze({
        host: o,
        port: a,
        protocol: s.replace(":", ""),
        options: Object.freeze({
            disableWarnings: i
        })
    }), eM()
}

function Z1(t) {
    const e = t.indexOf(":");
    return e < 0 ? "" : t.substr(0, e + 1)
}

function ZL(t) {
    const e = Z1(t),
        n = /(\/\/)?([^?#/]+)/.exec(t.substr(e.length));
    if (!n) return {
        host: "",
        port: null
    };
    const r = n[2].split("@").pop() || "",
        i = /^(\[[^\]]+\])(:|$)/.exec(r);
    if (i) {
        const s = i[1];
        return {
            host: s,
            port: I0(r.substr(s.length + 1))
        }
    } else {
        const [s, o] = r.split(":");
        return {
            host: s,
            port: I0(o)
        }
    }
}

function I0(t) {
    if (!t) return null;
    const e = Number(t);
    return isNaN(e) ? null : e
}

function eM() {
    function t() {
        const e = document.createElement("p"),
            n = e.style;
        e.innerText = "Running in emulator mode. Do not use with production credentials.", n.position = "fixed", n.width = "100%", n.backgroundColor = "#ffffff", n.border = ".1em solid #000000", n.color = "#b50000", n.bottom = "0px", n.left = "0px", n.margin = "0px", n.zIndex = "10000", n.textAlign = "center", e.classList.add("firebase-emulator-warning"), document.body.appendChild(e)
    }
    typeof console < "u" && typeof console.info == "function" && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."), typeof window < "u" && typeof document < "u" && (document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", t) : t())
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class eA {
    constructor(e, n) {
        this.providerId = e, this.signInMethod = n
    }
    toJSON() {
        return Mn("not implemented")
    }
    _getIdTokenResponse(e) {
        return Mn("not implemented")
    }
    _linkToIdToken(e, n) {
        return Mn("not implemented")
    }
    _getReauthenticationResolver(e) {
        return Mn("not implemented")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Ps(t, e) {
    return kL(t, "POST", "/v1/accounts:signInWithIdp", dg(t, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tM = "http://localhost";
class Di extends eA {
    constructor() {
        super(...arguments), this.pendingToken = null
    }
    static _fromParams(e) {
        const n = new Di(e.providerId, e.signInMethod);
        return e.idToken || e.accessToken ? (e.idToken && (n.idToken = e.idToken), e.accessToken && (n.accessToken = e.accessToken), e.nonce && !e.pendingToken && (n.nonce = e.nonce), e.pendingToken && (n.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (n.accessToken = e.oauthToken, n.secret = e.oauthTokenSecret) : tr("argument-error"), n
    }
    toJSON() {
        return {
            idToken: this.idToken,
            accessToken: this.accessToken,
            secret: this.secret,
            nonce: this.nonce,
            pendingToken: this.pendingToken,
            providerId: this.providerId,
            signInMethod: this.signInMethod
        }
    }
    static fromJSON(e) {
        const n = typeof e == "string" ? JSON.parse(e) : e,
            {
                providerId: r,
                signInMethod: i
            } = n,
            s = ug(n, ["providerId", "signInMethod"]);
        if (!r || !i) return null;
        const o = new Di(r, i);
        return o.idToken = s.idToken || void 0, o.accessToken = s.accessToken || void 0, o.secret = s.secret, o.nonce = s.nonce, o.pendingToken = s.pendingToken || null, o
    }
    _getIdTokenResponse(e) {
        const n = this.buildRequest();
        return Ps(e, n)
    }
    _linkToIdToken(e, n) {
        const r = this.buildRequest();
        return r.idToken = n, Ps(e, r)
    }
    _getReauthenticationResolver(e) {
        const n = this.buildRequest();
        return n.autoCreate = !1, Ps(e, n)
    }
    buildRequest() {
        const e = {
            requestUri: tM,
            returnSecureToken: !0
        };
        if (this.pendingToken) e.pendingToken = this.pendingToken;
        else {
            const n = {};
            this.idToken && (n.id_token = this.idToken), this.accessToken && (n.access_token = this.accessToken), this.secret && (n.oauth_token_secret = this.secret), n.providerId = this.providerId, this.nonce && !this.pendingToken && (n.nonce = this.nonce), e.postBody = Wa(n)
        }
        return e
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class tA {
    constructor(e) {
        this.providerId = e, this.defaultLanguageCode = null, this.customParameters = {}
    }
    setDefaultLanguage(e) {
        this.defaultLanguageCode = e
    }
    setCustomParameters(e) {
        return this.customParameters = e, this
    }
    getCustomParameters() {
        return this.customParameters
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Za extends tA {
    constructor() {
        super(...arguments), this.scopes = []
    }
    addScope(e) {
        return this.scopes.includes(e) || this.scopes.push(e), this
    }
    getScopes() {
        return [...this.scopes]
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vr extends Za {
    constructor() {
        super("facebook.com")
    }
    static credential(e) {
        return Di._fromParams({
            providerId: vr.PROVIDER_ID,
            signInMethod: vr.FACEBOOK_SIGN_IN_METHOD,
            accessToken: e
        })
    }
    static credentialFromResult(e) {
        return vr.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return vr.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({
        _tokenResponse: e
    }) {
        if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken) return null;
        try {
            return vr.credential(e.oauthAccessToken)
        } catch {
            return null
        }
    }
}
vr.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
vr.PROVIDER_ID = "facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _r extends Za {
    constructor() {
        super("google.com"), this.addScope("profile")
    }
    static credential(e, n) {
        return Di._fromParams({
            providerId: _r.PROVIDER_ID,
            signInMethod: _r.GOOGLE_SIGN_IN_METHOD,
            idToken: e,
            accessToken: n
        })
    }
    static credentialFromResult(e) {
        return _r.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return _r.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({
        _tokenResponse: e
    }) {
        if (!e) return null;
        const {
            oauthIdToken: n,
            oauthAccessToken: r
        } = e;
        if (!n && !r) return null;
        try {
            return _r.credential(n, r)
        } catch {
            return null
        }
    }
}
_r.GOOGLE_SIGN_IN_METHOD = "google.com";
_r.PROVIDER_ID = "google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wr extends Za {
    constructor() {
        super("github.com")
    }
    static credential(e) {
        return Di._fromParams({
            providerId: wr.PROVIDER_ID,
            signInMethod: wr.GITHUB_SIGN_IN_METHOD,
            accessToken: e
        })
    }
    static credentialFromResult(e) {
        return wr.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return wr.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({
        _tokenResponse: e
    }) {
        if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken) return null;
        try {
            return wr.credential(e.oauthAccessToken)
        } catch {
            return null
        }
    }
}
wr.GITHUB_SIGN_IN_METHOD = "github.com";
wr.PROVIDER_ID = "github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Tr extends Za {
    constructor() {
        super("twitter.com")
    }
    static credential(e, n) {
        return Di._fromParams({
            providerId: Tr.PROVIDER_ID,
            signInMethod: Tr.TWITTER_SIGN_IN_METHOD,
            oauthToken: e,
            oauthTokenSecret: n
        })
    }
    static credentialFromResult(e) {
        return Tr.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return Tr.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({
        _tokenResponse: e
    }) {
        if (!e) return null;
        const {
            oauthAccessToken: n,
            oauthTokenSecret: r
        } = e;
        if (!n || !r) return null;
        try {
            return Tr.credential(n, r)
        } catch {
            return null
        }
    }
}
Tr.TWITTER_SIGN_IN_METHOD = "twitter.com";
Tr.PROVIDER_ID = "twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bs {
    constructor(e) {
        this.user = e.user, this.providerId = e.providerId, this._tokenResponse = e._tokenResponse, this.operationType = e.operationType
    }
    static async _fromIdTokenResponse(e, n, r, i = !1) {
        const s = await Fn._fromIdTokenResponse(e, r, i),
            o = S0(r);
        return new Bs({
            user: s,
            providerId: o,
            _tokenResponse: r,
            operationType: n
        })
    }
    static async _forOperation(e, n, r) {
        await e._updateTokensIfNecessary(r, !0);
        const i = S0(r);
        return new Bs({
            user: e,
            providerId: i,
            _tokenResponse: r,
            operationType: n
        })
    }
}

function S0(t) {
    return t.providerId ? t.providerId : "phoneNumber" in t ? "phone" : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ac extends en {
    constructor(e, n, r, i) {
        var s;
        super(n.code, n.message), this.operationType = r, this.user = i, Object.setPrototypeOf(this, ac.prototype), this.customData = {
            appName: e.name,
            tenantId: (s = e.tenantId) !== null && s !== void 0 ? s : void 0,
            _serverResponse: n.customData._serverResponse,
            operationType: r
        }
    }
    static _fromErrorAndOperation(e, n, r, i) {
        return new ac(e, n, r, i)
    }
}

function nA(t, e, n, r) {
    return (e === "reauthenticate" ? n._getReauthenticationResolver(t) : n._getIdTokenResponse(t)).catch(s => {
        throw s.code === "auth/multi-factor-auth-required" ? ac._fromErrorAndOperation(t, s, e, r) : s
    })
}
async function nM(t, e, n = !1) {
    const r = await Na(t, e._linkToIdToken(t.auth, await t.getIdToken()), n);
    return Bs._forOperation(t, "link", r)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function rM(t, e, n = !1) {
    const {
        auth: r
    } = t;
    if (Sr(r.app)) return Promise.reject(Ii(r));
    const i = "reauthenticate";
    try {
        const s = await Na(t, nA(r, i, e, t), n);
        X(s.idToken, r, "internal-error");
        const o = fg(s.idToken);
        X(o, r, "internal-error");
        const {
            sub: a
        } = o;
        return X(t.uid === a, r, "user-mismatch"), Bs._forOperation(t, i, s)
    } catch (s) {
        throw (s == null ? void 0 : s.code) === "auth/user-not-found" && tr(r, "user-mismatch"), s
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function iM(t, e, n = !1) {
    if (Sr(t.app)) return Promise.reject(Ii(t));
    const r = "signIn",
        i = await nA(t, r, e),
        s = await Bs._fromIdTokenResponse(t, r, i);
    return n || await t._updateCurrentUser(s.user), s
}

function sM(t, e, n, r) {
    return Ce(t).onIdTokenChanged(e, n, r)
}

function oM(t, e, n) {
    return Ce(t).beforeAuthStateChanged(e, n)
}
const lc = "__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class rA {
    constructor(e, n) {
        this.storageRetriever = e, this.type = n
    }
    _isAvailable() {
        try {
            return this.storage ? (this.storage.setItem(lc, "1"), this.storage.removeItem(lc), Promise.resolve(!0)) : Promise.resolve(!1)
        } catch {
            return Promise.resolve(!1)
        }
    }
    _set(e, n) {
        return this.storage.setItem(e, JSON.stringify(n)), Promise.resolve()
    }
    _get(e) {
        const n = this.storage.getItem(e);
        return Promise.resolve(n ? JSON.parse(n) : null)
    }
    _remove(e) {
        return this.storage.removeItem(e), Promise.resolve()
    }
    get storage() {
        return this.storageRetriever()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const aM = 1e3,
    lM = 10;
class iA extends rA {
    constructor() {
        super(() => window.localStorage, "LOCAL"), this.boundEventHandler = (e, n) => this.onStorageEvent(e, n), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.fallbackToPolling = X1(), this._shouldAllowMigration = !0
    }
    forAllChangedKeys(e) {
        for (const n of Object.keys(this.listeners)) {
            const r = this.storage.getItem(n),
                i = this.localCache[n];
            r !== i && e(n, i, r)
        }
    }
    onStorageEvent(e, n = !1) {
        if (!e.key) {
            this.forAllChangedKeys((o, a, u) => {
                this.notifyListeners(o, u)
            });
            return
        }
        const r = e.key;
        n ? this.detachListener() : this.stopPolling();
        const i = () => {
                const o = this.storage.getItem(r);
                !n && this.localCache[r] === o || this.notifyListeners(r, o)
            },
            s = this.storage.getItem(r);
        jL() && s !== e.newValue && e.newValue !== e.oldValue ? setTimeout(i, lM) : i()
    }
    notifyListeners(e, n) {
        this.localCache[e] = n;
        const r = this.listeners[e];
        if (r)
            for (const i of Array.from(r)) i(n && JSON.parse(n))
    }
    startPolling() {
        this.stopPolling(), this.pollTimer = setInterval(() => {
            this.forAllChangedKeys((e, n, r) => {
                this.onStorageEvent(new StorageEvent("storage", {
                    key: e,
                    oldValue: n,
                    newValue: r
                }), !0)
            })
        }, aM)
    }
    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null)
    }
    attachListener() {
        window.addEventListener("storage", this.boundEventHandler)
    }
    detachListener() {
        window.removeEventListener("storage", this.boundEventHandler)
    }
    _addListener(e, n) {
        Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[e] || (this.listeners[e] = new Set, this.localCache[e] = this.storage.getItem(e)), this.listeners[e].add(n)
    }
    _removeListener(e, n) {
        this.listeners[e] && (this.listeners[e].delete(n), this.listeners[e].size === 0 && delete this.listeners[e]), Object.keys(this.listeners).length === 0 && (this.detachListener(), this.stopPolling())
    }
    async _set(e, n) {
        await super._set(e, n), this.localCache[e] = JSON.stringify(n)
    }
    async _get(e) {
        const n = await super._get(e);
        return this.localCache[e] = JSON.stringify(n), n
    }
    async _remove(e) {
        await super._remove(e), delete this.localCache[e]
    }
}
iA.type = "LOCAL";
const uM = iA;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sA extends rA {
    constructor() {
        super(() => window.sessionStorage, "SESSION")
    }
    _addListener(e, n) {}
    _removeListener(e, n) {}
}
sA.type = "SESSION";
const oA = sA;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function cM(t) {
    return Promise.all(t.map(async e => {
        try {
            return {
                fulfilled: !0,
                value: await e
            }
        } catch (n) {
            return {
                fulfilled: !1,
                reason: n
            }
        }
    }))
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lh {
    constructor(e) {
        this.eventTarget = e, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this)
    }
    static _getInstance(e) {
        const n = this.receivers.find(i => i.isListeningto(e));
        if (n) return n;
        const r = new lh(e);
        return this.receivers.push(r), r
    }
    isListeningto(e) {
        return this.eventTarget === e
    }
    async handleEvent(e) {
        const n = e,
            {
                eventId: r,
                eventType: i,
                data: s
            } = n.data,
            o = this.handlersMap[i];
        if (!(o != null && o.size)) return;
        n.ports[0].postMessage({
            status: "ack",
            eventId: r,
            eventType: i
        });
        const a = Array.from(o).map(async c => c(n.origin, s)),
            u = await cM(a);
        n.ports[0].postMessage({
            status: "done",
            eventId: r,
            eventType: i,
            response: u
        })
    }
    _subscribe(e, n) {
        Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[e] || (this.handlersMap[e] = new Set), this.handlersMap[e].add(n)
    }
    _unsubscribe(e, n) {
        this.handlersMap[e] && n && this.handlersMap[e].delete(n), (!n || this.handlersMap[e].size === 0) && delete this.handlersMap[e], Object.keys(this.handlersMap).length === 0 && this.eventTarget.removeEventListener("message", this.boundEventHandler)
    }
}
lh.receivers = [];
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function yg(t = "", e = 10) {
    let n = "";
    for (let r = 0; r < e; r++) n += Math.floor(Math.random() * 10);
    return t + n
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hM {
    constructor(e) {
        this.target = e, this.handlers = new Set
    }
    removeMessageHandler(e) {
        e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage), e.messageChannel.port1.close()), this.handlers.delete(e)
    }
    async _send(e, n, r = 50) {
        const i = typeof MessageChannel < "u" ? new MessageChannel : null;
        if (!i) throw new Error("connection_unavailable");
        let s, o;
        return new Promise((a, u) => {
            const c = yg("", 20);
            i.port1.start();
            const h = setTimeout(() => {
                u(new Error("unsupported_event"))
            }, r);
            o = {
                messageChannel: i,
                onMessage(f) {
                    const m = f;
                    if (m.data.eventId === c) switch (m.data.status) {
                        case "ack":
                            clearTimeout(h), s = setTimeout(() => {
                                u(new Error("timeout"))
                            }, 3e3);
                            break;
                        case "done":
                            clearTimeout(s), a(m.data.response);
                            break;
                        default:
                            clearTimeout(h), clearTimeout(s), u(new Error("invalid_response"));
                            break
                    }
                }
            }, this.handlers.add(o), i.port1.addEventListener("message", o.onMessage), this.target.postMessage({
                eventType: e,
                eventId: c,
                data: n
            }, [i.port2])
        }).finally(() => {
            o && this.removeMessageHandler(o)
        })
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function In() {
    return window
}

function dM(t) {
    In().location.href = t
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function aA() {
    return typeof In().WorkerGlobalScope < "u" && typeof In().importScripts == "function"
}
async function fM() {
    if (!(navigator != null && navigator.serviceWorker)) return null;
    try {
        return (await navigator.serviceWorker.ready).active
    } catch {
        return null
    }
}

function pM() {
    var t;
    return ((t = navigator == null ? void 0 : navigator.serviceWorker) === null || t === void 0 ? void 0 : t.controller) || null
}

function mM() {
    return aA() ? self : null
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const lA = "firebaseLocalStorageDb",
    gM = 1,
    uc = "firebaseLocalStorage",
    uA = "fbase_key";
class el {
    constructor(e) {
        this.request = e
    }
    toPromise() {
        return new Promise((e, n) => {
            this.request.addEventListener("success", () => {
                e(this.request.result)
            }), this.request.addEventListener("error", () => {
                n(this.request.error)
            })
        })
    }
}

function uh(t, e) {
    return t.transaction([uc], e ? "readwrite" : "readonly").objectStore(uc)
}

function yM() {
    const t = indexedDB.deleteDatabase(lA);
    return new el(t).toPromise()
}

function op() {
    const t = indexedDB.open(lA, gM);
    return new Promise((e, n) => {
        t.addEventListener("error", () => {
            n(t.error)
        }), t.addEventListener("upgradeneeded", () => {
            const r = t.result;
            try {
                r.createObjectStore(uc, {
                    keyPath: uA
                })
            } catch (i) {
                n(i)
            }
        }), t.addEventListener("success", async () => {
            const r = t.result;
            r.objectStoreNames.contains(uc) ? e(r) : (r.close(), await yM(), e(await op()))
        })
    })
}
async function A0(t, e, n) {
    const r = uh(t, !0).put({
        [uA]: e,
        value: n
    });
    return new el(r).toPromise()
}
async function vM(t, e) {
    const n = uh(t, !1).get(e),
        r = await new el(n).toPromise();
    return r === void 0 ? null : r.value
}

function P0(t, e) {
    const n = uh(t, !0).delete(e);
    return new el(n).toPromise()
}
const _M = 800,
    wM = 3;
class cA {
    constructor() {
        this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {}, () => {})
    }
    async _openDb() {
        return this.db ? this.db : (this.db = await op(), this.db)
    }
    async _withRetries(e) {
        let n = 0;
        for (;;) try {
            const r = await this._openDb();
            return await e(r)
        } catch (r) {
            if (n++ > wM) throw r;
            this.db && (this.db.close(), this.db = void 0)
        }
    }
    async initializeServiceWorkerMessaging() {
        return aA() ? this.initializeReceiver() : this.initializeSender()
    }
    async initializeReceiver() {
        this.receiver = lh._getInstance(mM()), this.receiver._subscribe("keyChanged", async (e, n) => ({
            keyProcessed: (await this._poll()).includes(n.key)
        })), this.receiver._subscribe("ping", async (e, n) => ["keyChanged"])
    }
    async initializeSender() {
        var e, n;
        if (this.activeServiceWorker = await fM(), !this.activeServiceWorker) return;
        this.sender = new hM(this.activeServiceWorker);
        const r = await this.sender._send("ping", {}, 800);
        r && !((e = r[0]) === null || e === void 0) && e.fulfilled && !((n = r[0]) === null || n === void 0) && n.value.includes("keyChanged") && (this.serviceWorkerReceiverAvailable = !0)
    }
    async notifyServiceWorker(e) {
        if (!(!this.sender || !this.activeServiceWorker || pM() !== this.activeServiceWorker)) try {
            await this.sender._send("keyChanged", {
                key: e
            }, this.serviceWorkerReceiverAvailable ? 800 : 50)
        } catch {}
    }
    async _isAvailable() {
        try {
            if (!indexedDB) return !1;
            const e = await op();
            return await A0(e, lc, "1"), await P0(e, lc), !0
        } catch {}
        return !1
    }
    async _withPendingWrite(e) {
        this.pendingWrites++;
        try {
            await e()
        } finally {
            this.pendingWrites--
        }
    }
    async _set(e, n) {
        return this._withPendingWrite(async () => (await this._withRetries(r => A0(r, e, n)), this.localCache[e] = n, this.notifyServiceWorker(e)))
    }
    async _get(e) {
        const n = await this._withRetries(r => vM(r, e));
        return this.localCache[e] = n, n
    }
    async _remove(e) {
        return this._withPendingWrite(async () => (await this._withRetries(n => P0(n, e)), delete this.localCache[e], this.notifyServiceWorker(e)))
    }
    async _poll() {
        const e = await this._withRetries(i => {
            const s = uh(i, !1).getAll();
            return new el(s).toPromise()
        });
        if (!e) return [];
        if (this.pendingWrites !== 0) return [];
        const n = [],
            r = new Set;
        if (e.length !== 0)
            for (const {
                    fbase_key: i,
                    value: s
                } of e) r.add(i), JSON.stringify(this.localCache[i]) !== JSON.stringify(s) && (this.notifyListeners(i, s), n.push(i));
        for (const i of Object.keys(this.localCache)) this.localCache[i] && !r.has(i) && (this.notifyListeners(i, null), n.push(i));
        return n
    }
    notifyListeners(e, n) {
        this.localCache[e] = n;
        const r = this.listeners[e];
        if (r)
            for (const i of Array.from(r)) i(n)
    }
    startPolling() {
        this.stopPolling(), this.pollTimer = setInterval(async () => this._poll(), _M)
    }
    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null)
    }
    _addListener(e, n) {
        Object.keys(this.listeners).length === 0 && this.startPolling(), this.listeners[e] || (this.listeners[e] = new Set, this._get(e)), this.listeners[e].add(n)
    }
    _removeListener(e, n) {
        this.listeners[e] && (this.listeners[e].delete(n), this.listeners[e].size === 0 && delete this.listeners[e]), Object.keys(this.listeners).length === 0 && this.stopPolling()
    }
}
cA.type = "LOCAL";
const TM = cA;
new Ja(3e4, 6e4);
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function EM(t, e) {
    return e ? Un(e) : (X(t._popupRedirectResolver, t, "argument-error"), t._popupRedirectResolver)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vg extends eA {
    constructor(e) {
        super("custom", "custom"), this.params = e
    }
    _getIdTokenResponse(e) {
        return Ps(e, this._buildIdpRequest())
    }
    _linkToIdToken(e, n) {
        return Ps(e, this._buildIdpRequest(n))
    }
    _getReauthenticationResolver(e) {
        return Ps(e, this._buildIdpRequest())
    }
    _buildIdpRequest(e) {
        const n = {
            requestUri: this.params.requestUri,
            sessionId: this.params.sessionId,
            postBody: this.params.postBody,
            tenantId: this.params.tenantId,
            pendingToken: this.params.pendingToken,
            returnSecureToken: !0,
            returnIdpCredential: !0
        };
        return e && (n.idToken = e), n
    }
}

function IM(t) {
    return iM(t.auth, new vg(t), t.bypassAuthState)
}

function SM(t) {
    const {
        auth: e,
        user: n
    } = t;
    return X(n, e, "internal-error"), rM(n, new vg(t), t.bypassAuthState)
}
async function AM(t) {
    const {
        auth: e,
        user: n
    } = t;
    return X(n, e, "internal-error"), nM(n, new vg(t), t.bypassAuthState)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hA {
    constructor(e, n, r, i, s = !1) {
        this.auth = e, this.resolver = r, this.user = i, this.bypassAuthState = s, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(n) ? n : [n]
    }
    execute() {
        return new Promise(async (e, n) => {
            this.pendingPromise = {
                resolve: e,
                reject: n
            };
            try {
                this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this)
            } catch (r) {
                this.reject(r)
            }
        })
    }
    async onAuthEvent(e) {
        const {
            urlResponse: n,
            sessionId: r,
            postBody: i,
            tenantId: s,
            error: o,
            type: a
        } = e;
        if (o) {
            this.reject(o);
            return
        }
        const u = {
            auth: this.auth,
            requestUri: n,
            sessionId: r,
            tenantId: s || void 0,
            postBody: i || void 0,
            user: this.user,
            bypassAuthState: this.bypassAuthState
        };
        try {
            this.resolve(await this.getIdpTask(a)(u))
        } catch (c) {
            this.reject(c)
        }
    }
    onError(e) {
        this.reject(e)
    }
    getIdpTask(e) {
        switch (e) {
            case "signInViaPopup":
            case "signInViaRedirect":
                return IM;
            case "linkViaPopup":
            case "linkViaRedirect":
                return AM;
            case "reauthViaPopup":
            case "reauthViaRedirect":
                return SM;
            default:
                tr(this.auth, "internal-error")
        }
    }
    resolve(e) {
        nr(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(e), this.unregisterAndCleanUp()
    }
    reject(e) {
        nr(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(e), this.unregisterAndCleanUp()
    }
    unregisterAndCleanUp() {
        this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PM = new Ja(2e3, 1e4);
class hs extends hA {
    constructor(e, n, r, i, s) {
        super(e, n, i, s), this.provider = r, this.authWindow = null, this.pollId = null, hs.currentPopupAction && hs.currentPopupAction.cancel(), hs.currentPopupAction = this
    }
    async executeNotNull() {
        const e = await this.execute();
        return X(e, this.auth, "internal-error"), e
    }
    async onExecution() {
        nr(this.filter.length === 1, "Popup operations only handle one event");
        const e = yg();
        this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], e), this.authWindow.associatedEvent = e, this.resolver._originValidation(this.auth).catch(n => {
            this.reject(n)
        }), this.resolver._isIframeWebStorageSupported(this.auth, n => {
            n || this.reject(En(this.auth, "web-storage-unsupported"))
        }), this.pollUserCancellation()
    }
    get eventId() {
        var e;
        return ((e = this.authWindow) === null || e === void 0 ? void 0 : e.associatedEvent) || null
    }
    cancel() {
        this.reject(En(this.auth, "cancelled-popup-request"))
    }
    cleanUp() {
        this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, hs.currentPopupAction = null
    }
    pollUserCancellation() {
        const e = () => {
            var n, r;
            if (!((r = (n = this.authWindow) === null || n === void 0 ? void 0 : n.window) === null || r === void 0) && r.closed) {
                this.pollId = window.setTimeout(() => {
                    this.pollId = null, this.reject(En(this.auth, "popup-closed-by-user"))
                }, 8e3);
                return
            }
            this.pollId = window.setTimeout(e, PM.get())
        };
        e()
    }
}
hs.currentPopupAction = null;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RM = "pendingRedirect",
    mu = new Map;
class CM extends hA {
    constructor(e, n, r = !1) {
        super(e, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], n, void 0, r), this.eventId = null
    }
    async execute() {
        let e = mu.get(this.auth._key());
        if (!e) {
            try {
                const r = await kM(this.resolver, this.auth) ? await super.execute() : null;
                e = () => Promise.resolve(r)
            } catch (n) {
                e = () => Promise.reject(n)
            }
            mu.set(this.auth._key(), e)
        }
        return this.bypassAuthState || mu.set(this.auth._key(), () => Promise.resolve(null)), e()
    }
    async onAuthEvent(e) {
        if (e.type === "signInViaRedirect") return super.onAuthEvent(e);
        if (e.type === "unknown") {
            this.resolve(null);
            return
        }
        if (e.eventId) {
            const n = await this.auth._redirectUserForId(e.eventId);
            if (n) return this.user = n, super.onAuthEvent(e);
            this.resolve(null)
        }
    }
    async onExecution() {}
    cleanUp() {}
}
async function kM(t, e) {
    const n = NM(e),
        r = bM(t);
    if (!await r._isAvailable()) return !1;
    const i = await r._get(n) === "true";
    return await r._remove(n), i
}

function xM(t, e) {
    mu.set(t._key(), e)
}

function bM(t) {
    return Un(t._redirectPersistence)
}

function NM(t) {
    return pu(RM, t.config.apiKey, t.name)
}
async function DM(t, e, n = !1) {
    if (Sr(t.app)) return Promise.reject(Ii(t));
    const r = mg(t),
        i = EM(r, e),
        o = await new CM(r, i, n).execute();
    return o && !n && (delete o.user._redirectEventId, await r._persistUserIfCurrent(o.user), await r._setRedirectUser(null, e)), o
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VM = 10 * 60 * 1e3;
class OM {
    constructor(e) {
        this.auth = e, this.cachedEventUids = new Set, this.consumers = new Set, this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now()
    }
    registerConsumer(e) {
        this.consumers.add(e), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null)
    }
    unregisterConsumer(e) {
        this.consumers.delete(e)
    }
    onEvent(e) {
        if (this.hasEventBeenHandled(e)) return !1;
        let n = !1;
        return this.consumers.forEach(r => {
            this.isEventForConsumer(e, r) && (n = !0, this.sendToConsumer(e, r), this.saveEventToCache(e))
        }), this.hasHandledPotentialRedirect || !LM(e) || (this.hasHandledPotentialRedirect = !0, n || (this.queuedRedirectEvent = e, n = !0)), n
    }
    sendToConsumer(e, n) {
        var r;
        if (e.error && !dA(e)) {
            const i = ((r = e.error.code) === null || r === void 0 ? void 0 : r.split("auth/")[1]) || "internal-error";
            n.onError(En(this.auth, i))
        } else n.onAuthEvent(e)
    }
    isEventForConsumer(e, n) {
        const r = n.eventId === null || !!e.eventId && e.eventId === n.eventId;
        return n.filter.includes(e.type) && r
    }
    hasEventBeenHandled(e) {
        return Date.now() - this.lastProcessedEventTime >= VM && this.cachedEventUids.clear(), this.cachedEventUids.has(R0(e))
    }
    saveEventToCache(e) {
        this.cachedEventUids.add(R0(e)), this.lastProcessedEventTime = Date.now()
    }
}

function R0(t) {
    return [t.type, t.eventId, t.sessionId, t.tenantId].filter(e => e).join("-")
}

function dA({
    type: t,
    error: e
}) {
    return t === "unknown" && (e == null ? void 0 : e.code) === "auth/no-auth-event"
}

function LM(t) {
    switch (t.type) {
        case "signInViaRedirect":
        case "linkViaRedirect":
        case "reauthViaRedirect":
            return !0;
        case "unknown":
            return dA(t);
        default:
            return !1
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function MM(t, e = {}) {
    return Zs(t, "GET", "/v1/projects", e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const FM = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
    UM = /^https?/;
async function jM(t) {
    if (t.config.emulator) return;
    const {
        authorizedDomains: e
    } = await MM(t);
    for (const n of e) try {
        if (BM(n)) return
    } catch {}
    tr(t, "unauthorized-domain")
}

function BM(t) {
    const e = ip(),
        {
            protocol: n,
            hostname: r
        } = new URL(e);
    if (t.startsWith("chrome-extension://")) {
        const o = new URL(t);
        return o.hostname === "" && r === "" ? n === "chrome-extension:" && t.replace("chrome-extension://", "") === e.replace("chrome-extension://", "") : n === "chrome-extension:" && o.hostname === r
    }
    if (!UM.test(n)) return !1;
    if (FM.test(t)) return r === t;
    const i = t.replace(/\./g, "\\.");
    return new RegExp("^(.+\\." + i + "|" + i + ")$", "i").test(r)
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $M = new Ja(3e4, 6e4);

function C0() {
    const t = In().___jsl;
    if (t != null && t.H) {
        for (const e of Object.keys(t.H))
            if (t.H[e].r = t.H[e].r || [], t.H[e].L = t.H[e].L || [], t.H[e].r = [...t.H[e].L], t.CP)
                for (let n = 0; n < t.CP.length; n++) t.CP[n] = null
    }
}

function zM(t) {
    return new Promise((e, n) => {
        var r, i, s;

        function o() {
            C0(), gapi.load("gapi.iframes", {
                callback: () => {
                    e(gapi.iframes.getContext())
                },
                ontimeout: () => {
                    C0(), n(En(t, "network-request-failed"))
                },
                timeout: $M.get()
            })
        }
        if (!((i = (r = In().gapi) === null || r === void 0 ? void 0 : r.iframes) === null || i === void 0) && i.Iframe) e(gapi.iframes.getContext());
        else if (!((s = In().gapi) === null || s === void 0) && s.load) o();
        else {
            const a = QL("iframefcb");
            return In()[a] = () => {
                gapi.load ? o() : n(En(t, "network-request-failed"))
            }, KL(`${GL()}?onload=${a}`).catch(u => n(u))
        }
    }).catch(e => {
        throw gu = null, e
    })
}
let gu = null;

function WM(t) {
    return gu = gu || zM(t), gu
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const qM = new Ja(5e3, 15e3),
    HM = "__/auth/iframe",
    KM = "emulator/auth/iframe",
    GM = {
        style: {
            position: "absolute",
            top: "-100px",
            width: "1px",
            height: "1px"
        },
        "aria-hidden": "true",
        tabindex: "-1"
    },
    QM = new Map([
        ["identitytoolkit.googleapis.com", "p"],
        ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
        ["test-identitytoolkit.sandbox.googleapis.com", "t"]
    ]);

function YM(t) {
    const e = t.config;
    X(e.authDomain, t, "auth-domain-config-required");
    const n = e.emulator ? hg(e, KM) : `https://${t.config.authDomain}/${HM}`,
        r = {
            apiKey: e.apiKey,
            appName: t.name,
            v: Li
        },
        i = QM.get(t.config.apiHost);
    i && (r.eid = i);
    const s = t._getFrameworks();
    return s.length && (r.fw = s.join(",")), `${n}?${Wa(r).slice(1)}`
}
async function XM(t) {
    const e = await WM(t),
        n = In().gapi;
    return X(n, t, "internal-error"), e.open({
        where: document.body,
        url: YM(t),
        messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
        attributes: GM,
        dontclear: !0
    }, r => new Promise(async (i, s) => {
        await r.restyle({
            setHideOnLeave: !1
        });
        const o = En(t, "network-request-failed"),
            a = In().setTimeout(() => {
                s(o)
            }, qM.get());

        function u() {
            In().clearTimeout(a), i(r)
        }
        r.ping(u).then(u, () => {
            s(o)
        })
    }))
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const JM = {
        location: "yes",
        resizable: "yes",
        statusbar: "yes",
        toolbar: "no"
    },
    ZM = 500,
    e2 = 600,
    t2 = "_blank",
    n2 = "http://localhost";
class k0 {
    constructor(e) {
        this.window = e, this.associatedEvent = null
    }
    close() {
        if (this.window) try {
            this.window.close()
        } catch {}
    }
}

function r2(t, e, n, r = ZM, i = e2) {
    const s = Math.max((window.screen.availHeight - i) / 2, 0).toString(),
        o = Math.max((window.screen.availWidth - r) / 2, 0).toString();
    let a = "";
    const u = Object.assign(Object.assign({}, JM), {
            width: r.toString(),
            height: i.toString(),
            top: s,
            left: o
        }),
        c = pt().toLowerCase();
    n && (a = H1(c) ? t2 : n), W1(c) && (e = e || n2, u.scrollbars = "yes");
    const h = Object.entries(u).reduce((m, [_, I]) => `${m}${_}=${I},`, "");
    if (UL(c) && a !== "_self") return i2(e || "", a), new k0(null);
    const f = window.open(e || "", a, h);
    X(f, t, "popup-blocked");
    try {
        f.focus()
    } catch {}
    return new k0(f)
}

function i2(t, e) {
    const n = document.createElement("a");
    n.href = t, n.target = e;
    const r = document.createEvent("MouseEvent");
    r.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), n.dispatchEvent(r)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const s2 = "__/auth/handler",
    o2 = "emulator/auth/handler",
    a2 = encodeURIComponent("fac");
async function x0(t, e, n, r, i, s) {
    X(t.config.authDomain, t, "auth-domain-config-required"), X(t.config.apiKey, t, "invalid-api-key");
    const o = {
        apiKey: t.config.apiKey,
        appName: t.name,
        authType: n,
        redirectUrl: r,
        v: Li,
        eventId: i
    };
    if (e instanceof tA) {
        e.setDefaultLanguage(t.languageCode), o.providerId = e.providerId || "", xx(e.getCustomParameters()) || (o.customParameters = JSON.stringify(e.getCustomParameters()));
        for (const [h, f] of Object.entries({})) o[h] = f
    }
    if (e instanceof Za) {
        const h = e.getScopes().filter(f => f !== "");
        h.length > 0 && (o.scopes = h.join(","))
    }
    t.tenantId && (o.tid = t.tenantId);
    const a = o;
    for (const h of Object.keys(a)) a[h] === void 0 && delete a[h];
    const u = await t._getAppCheckToken(),
        c = u ? `#${a2}=${encodeURIComponent(u)}` : "";
    return `${l2(t)}?${Wa(a).slice(1)}${c}`
}

function l2({
    config: t
}) {
    return t.emulator ? hg(t, o2) : `https://${t.authDomain}/${s2}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ad = "webStorageSupport";
class u2 {
    constructor() {
        this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = oA, this._completeRedirectFn = DM, this._overrideRedirectResult = xM
    }
    async _openPopup(e, n, r, i) {
        var s;
        nr((s = this.eventManagers[e._key()]) === null || s === void 0 ? void 0 : s.manager, "_initialize() not called before _openPopup()");
        const o = await x0(e, n, r, ip(), i);
        return r2(e, o, yg())
    }
    async _openRedirect(e, n, r, i) {
        await this._originValidation(e);
        const s = await x0(e, n, r, ip(), i);
        return dM(s), new Promise(() => {})
    }
    _initialize(e) {
        const n = e._key();
        if (this.eventManagers[n]) {
            const {
                manager: i,
                promise: s
            } = this.eventManagers[n];
            return i ? Promise.resolve(i) : (nr(s, "If manager is not set, promise should be"), s)
        }
        const r = this.initAndGetManager(e);
        return this.eventManagers[n] = {
            promise: r
        }, r.catch(() => {
            delete this.eventManagers[n]
        }), r
    }
    async initAndGetManager(e) {
        const n = await XM(e),
            r = new OM(e);
        return n.register("authEvent", i => (X(i == null ? void 0 : i.authEvent, e, "invalid-auth-event"), {
            status: r.onEvent(i.authEvent) ? "ACK" : "ERROR"
        }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[e._key()] = {
            manager: r
        }, this.iframes[e._key()] = n, r
    }
    _isIframeWebStorageSupported(e, n) {
        this.iframes[e._key()].send(Ad, {
            type: Ad
        }, i => {
            var s;
            const o = (s = i == null ? void 0 : i[0]) === null || s === void 0 ? void 0 : s[Ad];
            o !== void 0 && n(!!o), tr(e, "internal-error")
        }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)
    }
    _originValidation(e) {
        const n = e._key();
        return this.originValidationPromises[n] || (this.originValidationPromises[n] = jM(e)), this.originValidationPromises[n]
    }
    get _shouldInitProactively() {
        return X1() || q1() || pg()
    }
}
const c2 = u2;
var b0 = "@firebase/auth",
    N0 = "1.8.1";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class h2 {
    constructor(e) {
        this.auth = e, this.internalListeners = new Map
    }
    getUid() {
        var e;
        return this.assertAuthConfigured(), ((e = this.auth.currentUser) === null || e === void 0 ? void 0 : e.uid) || null
    }
    async getToken(e) {
        return this.assertAuthConfigured(), await this.auth._initializationPromise, this.auth.currentUser ? {
            accessToken: await this.auth.currentUser.getIdToken(e)
        } : null
    }
    addAuthTokenListener(e) {
        if (this.assertAuthConfigured(), this.internalListeners.has(e)) return;
        const n = this.auth.onIdTokenChanged(r => {
            e((r == null ? void 0 : r.stsTokenManager.accessToken) || null)
        });
        this.internalListeners.set(e, n), this.updateProactiveRefresh()
    }
    removeAuthTokenListener(e) {
        this.assertAuthConfigured();
        const n = this.internalListeners.get(e);
        n && (this.internalListeners.delete(e), n(), this.updateProactiveRefresh())
    }
    assertAuthConfigured() {
        X(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth")
    }
    updateProactiveRefresh() {
        this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function d2(t) {
    switch (t) {
        case "Node":
            return "node";
        case "ReactNative":
            return "rn";
        case "Worker":
            return "webworker";
        case "Cordova":
            return "cordova";
        case "WebExtension":
            return "web-extension";
        default:
            return
    }
}

function f2(t) {
    jt(new Nt("auth", (e, {
        options: n
    }) => {
        const r = e.getProvider("app").getImmediate(),
            i = e.getProvider("heartbeat"),
            s = e.getProvider("app-check-internal"),
            {
                apiKey: o,
                authDomain: a
            } = r.options;
        X(o && !o.includes(":"), "invalid-api-key", {
            appName: r.name
        });
        const u = {
                apiKey: o,
                authDomain: a,
                clientPlatform: t,
                apiHost: "identitytoolkit.googleapis.com",
                tokenApiHost: "securetoken.googleapis.com",
                apiScheme: "https",
                sdkClientVersion: J1(t)
            },
            c = new qL(r, i, s, u);
        return XL(c, n), c
    }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e, n, r) => {
        e.getProvider("auth-internal").initialize()
    })), jt(new Nt("auth-internal", e => {
        const n = mg(e.getProvider("auth").getImmediate());
        return (r => new h2(r))(n)
    }, "PRIVATE").setInstantiationMode("EXPLICIT")), ct(b0, N0, d2(t)), ct(b0, N0, "esm2017")
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const p2 = 5 * 60,
    m2 = kI("authIdTokenMaxAge") || p2;
let D0 = null;
const g2 = t => async e => {
    const n = e && await e.getIdTokenResult(),
        r = n && (new Date().getTime() - Date.parse(n.issuedAtTime)) / 1e3;
    if (r && r > m2) return;
    const i = n == null ? void 0 : n.token;
    D0 !== i && (D0 = i, await fetch(t, {
        method: i ? "POST" : "DELETE",
        headers: i ? {
            Authorization: `Bearer ${i}`
        } : {}
    }))
};

function y2(t = qa()) {
    const e = ir(t, "auth");
    if (e.isInitialized()) return e.getImmediate();
    const n = YL(t, {
            popupRedirectResolver: c2,
            persistence: [TM, uM, oA]
        }),
        r = kI("authTokenSyncURL");
    if (r && typeof isSecureContext == "boolean" && isSecureContext) {
        const s = new URL(r, location.origin);
        if (location.origin === s.origin) {
            const o = g2(s.toString());
            oM(n, o, () => o(n.currentUser)), sM(n, a => o(a))
        }
    }
    const i = PI("auth");
    return i && JL(n, `http://${i}`), n
}

function v2() {
    var t, e;
    return (e = (t = document.getElementsByTagName("head")) === null || t === void 0 ? void 0 : t[0]) !== null && e !== void 0 ? e : document
}
HL({
    loadJS(t) {
        return new Promise((e, n) => {
            const r = document.createElement("script");
            r.setAttribute("src", t), r.onload = e, r.onerror = i => {
                const s = En("internal-error");
                s.customData = i, n(s)
            }, r.type = "text/javascript", r.charset = "UTF-8", v2().appendChild(r)
        })
    },
    gapiScript: "https://apis.google.com/js/api.js",
    recaptchaV2Script: "https://www.google.com/recaptcha/api.js",
    recaptchaEnterpriseScript: "https://www.google.com/recaptcha/enterprise.js?render="
});
f2("Browser");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fA = "firebasestorage.googleapis.com",
    _2 = "storageBucket",
    w2 = 2 * 60 * 1e3,
    T2 = 10 * 60 * 1e3;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Cn extends en {
    constructor(e, n, r = 0) {
        super(Pd(e), `Firebase Storage: ${n} (${Pd(e)})`), this.status_ = r, this.customData = {
            serverResponse: null
        }, this._baseMessage = this.message, Object.setPrototypeOf(this, Cn.prototype)
    }
    get status() {
        return this.status_
    }
    set status(e) {
        this.status_ = e
    }
    _codeEquals(e) {
        return Pd(e) === this.code
    }
    get serverResponse() {
        return this.customData.serverResponse
    }
    set serverResponse(e) {
        this.customData.serverResponse = e, this.customData.serverResponse ? this.message = `${this._baseMessage}
${this.customData.serverResponse}` : this.message = this._baseMessage
    }
}
var Rn;
(function(t) {
    t.UNKNOWN = "unknown", t.OBJECT_NOT_FOUND = "object-not-found", t.BUCKET_NOT_FOUND = "bucket-not-found", t.PROJECT_NOT_FOUND = "project-not-found", t.QUOTA_EXCEEDED = "quota-exceeded", t.UNAUTHENTICATED = "unauthenticated", t.UNAUTHORIZED = "unauthorized", t.UNAUTHORIZED_APP = "unauthorized-app", t.RETRY_LIMIT_EXCEEDED = "retry-limit-exceeded", t.INVALID_CHECKSUM = "invalid-checksum", t.CANCELED = "canceled", t.INVALID_EVENT_NAME = "invalid-event-name", t.INVALID_URL = "invalid-url", t.INVALID_DEFAULT_BUCKET = "invalid-default-bucket", t.NO_DEFAULT_BUCKET = "no-default-bucket", t.CANNOT_SLICE_BLOB = "cannot-slice-blob", t.SERVER_FILE_WRONG_SIZE = "server-file-wrong-size", t.NO_DOWNLOAD_URL = "no-download-url", t.INVALID_ARGUMENT = "invalid-argument", t.INVALID_ARGUMENT_COUNT = "invalid-argument-count", t.APP_DELETED = "app-deleted", t.INVALID_ROOT_OPERATION = "invalid-root-operation", t.INVALID_FORMAT = "invalid-format", t.INTERNAL_ERROR = "internal-error", t.UNSUPPORTED_ENVIRONMENT = "unsupported-environment"
})(Rn || (Rn = {}));

function Pd(t) {
    return "storage/" + t
}

function E2() {
    const t = "An unknown error occurred, please check the error payload for server response.";
    return new Cn(Rn.UNKNOWN, t)
}

function I2() {
    return new Cn(Rn.RETRY_LIMIT_EXCEEDED, "Max retry time for operation exceeded, please try again.")
}

function S2() {
    return new Cn(Rn.CANCELED, "User canceled the upload/download.")
}

function A2(t) {
    return new Cn(Rn.INVALID_URL, "Invalid URL '" + t + "'.")
}

function P2(t) {
    return new Cn(Rn.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + t + "'.")
}

function V0(t) {
    return new Cn(Rn.INVALID_ARGUMENT, t)
}

function pA() {
    return new Cn(Rn.APP_DELETED, "The Firebase app was deleted.")
}

function R2(t) {
    return new Cn(Rn.INVALID_ROOT_OPERATION, "The operation '" + t + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').")
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class an {
    constructor(e, n) {
        this.bucket = e, this.path_ = n
    }
    get path() {
        return this.path_
    }
    get isRoot() {
        return this.path.length === 0
    }
    fullServerUrl() {
        const e = encodeURIComponent;
        return "/b/" + e(this.bucket) + "/o/" + e(this.path)
    }
    bucketOnlyServerUrl() {
        return "/b/" + encodeURIComponent(this.bucket) + "/o"
    }
    static makeFromBucketSpec(e, n) {
        let r;
        try {
            r = an.makeFromUrl(e, n)
        } catch {
            return new an(e, "")
        }
        if (r.path === "") return r;
        throw P2(e)
    }
    static makeFromUrl(e, n) {
        let r = null;
        const i = "([A-Za-z0-9.\\-_]+)";

        function s(x) {
            x.path.charAt(x.path.length - 1) === "/" && (x.path_ = x.path_.slice(0, -1))
        }
        const o = "(/(.*))?$",
            a = new RegExp("^gs://" + i + o, "i"),
            u = {
                bucket: 1,
                path: 3
            };

        function c(x) {
            x.path_ = decodeURIComponent(x.path)
        }
        const h = "v[A-Za-z0-9_]+",
            f = n.replace(/[.]/g, "\\."),
            m = "(/([^?#]*).*)?$",
            _ = new RegExp(`^https?://${f}/${h}/b/${i}/o${m}`, "i"),
            I = {
                bucket: 1,
                path: 3
            },
            R = n === fA ? "(?:storage.googleapis.com|storage.cloud.google.com)" : n,
            k = "([^?#]*)",
            w = new RegExp(`^https?://${R}/${i}/${k}`, "i"),
            T = [{
                regex: a,
                indices: u,
                postModify: s
            }, {
                regex: _,
                indices: I,
                postModify: c
            }, {
                regex: w,
                indices: {
                    bucket: 1,
                    path: 2
                },
                postModify: c
            }];
        for (let x = 0; x < T.length; x++) {
            const O = T[x],
                U = O.regex.exec(e);
            if (U) {
                const S = U[O.indices.bucket];
                let g = U[O.indices.path];
                g || (g = ""), r = new an(S, g), O.postModify(r);
                break
            }
        }
        if (r == null) throw A2(e);
        return r
    }
}
class C2 {
    constructor(e) {
        this.promise_ = Promise.reject(e)
    }
    getPromise() {
        return this.promise_
    }
    cancel(e = !1) {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function k2(t, e, n) {
    let r = 1,
        i = null,
        s = null,
        o = !1,
        a = 0;

    function u() {
        return a === 2
    }
    let c = !1;

    function h(...k) {
        c || (c = !0, e.apply(null, k))
    }

    function f(k) {
        i = setTimeout(() => {
            i = null, t(_, u())
        }, k)
    }

    function m() {
        s && clearTimeout(s)
    }

    function _(k, ...w) {
        if (c) {
            m();
            return
        }
        if (k) {
            m(), h.call(null, k, ...w);
            return
        }
        if (u() || o) {
            m(), h.call(null, k, ...w);
            return
        }
        r < 64 && (r *= 2);
        let T;
        a === 1 ? (a = 2, T = 0) : T = (r + Math.random()) * 1e3, f(T)
    }
    let I = !1;

    function R(k) {
        I || (I = !0, m(), !c && (i !== null ? (k || (a = 2), clearTimeout(i), f(0)) : k || (a = 1)))
    }
    return f(0), s = setTimeout(() => {
        o = !0, R(!0)
    }, n), R
}

function x2(t) {
    t(!1)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function b2(t) {
    return t !== void 0
}

function O0(t, e, n, r) {
    if (r < e) throw V0(`Invalid value for '${t}'. Expected ${e} or greater.`);
    if (r > n) throw V0(`Invalid value for '${t}'. Expected ${n} or less.`)
}

function N2(t) {
    const e = encodeURIComponent;
    let n = "?";
    for (const r in t)
        if (t.hasOwnProperty(r)) {
            const i = e(r) + "=" + e(t[r]);
            n = n + i + "&"
        }
    return n = n.slice(0, -1), n
}
var cc;
(function(t) {
    t[t.NO_ERROR = 0] = "NO_ERROR", t[t.NETWORK_ERROR = 1] = "NETWORK_ERROR", t[t.ABORT = 2] = "ABORT"
})(cc || (cc = {}));
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function D2(t, e) {
    const n = t >= 500 && t < 600,
        i = [408, 429].indexOf(t) !== -1,
        s = e.indexOf(t) !== -1;
    return n || i || s
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class V2 {
    constructor(e, n, r, i, s, o, a, u, c, h, f, m = !0) {
        this.url_ = e, this.method_ = n, this.headers_ = r, this.body_ = i, this.successCodes_ = s, this.additionalRetryCodes_ = o, this.callback_ = a, this.errorCallback_ = u, this.timeout_ = c, this.progressCallback_ = h, this.connectionFactory_ = f, this.retry = m, this.pendingConnection_ = null, this.backoffId_ = null, this.canceled_ = !1, this.appDelete_ = !1, this.promise_ = new Promise((_, I) => {
            this.resolve_ = _, this.reject_ = I, this.start_()
        })
    }
    start_() {
        const e = (r, i) => {
                if (i) {
                    r(!1, new Wl(!1, null, !0));
                    return
                }
                const s = this.connectionFactory_();
                this.pendingConnection_ = s;
                const o = a => {
                    const u = a.loaded,
                        c = a.lengthComputable ? a.total : -1;
                    this.progressCallback_ !== null && this.progressCallback_(u, c)
                };
                this.progressCallback_ !== null && s.addUploadProgressListener(o), s.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
                    this.progressCallback_ !== null && s.removeUploadProgressListener(o), this.pendingConnection_ = null;
                    const a = s.getErrorCode() === cc.NO_ERROR,
                        u = s.getStatus();
                    if (!a || D2(u, this.additionalRetryCodes_) && this.retry) {
                        const h = s.getErrorCode() === cc.ABORT;
                        r(!1, new Wl(!1, null, h));
                        return
                    }
                    const c = this.successCodes_.indexOf(u) !== -1;
                    r(!0, new Wl(c, s))
                })
            },
            n = (r, i) => {
                const s = this.resolve_,
                    o = this.reject_,
                    a = i.connection;
                if (i.wasSuccessCode) try {
                    const u = this.callback_(a, a.getResponse());
                    b2(u) ? s(u) : s()
                } catch (u) {
                    o(u)
                } else if (a !== null) {
                    const u = E2();
                    u.serverResponse = a.getErrorText(), this.errorCallback_ ? o(this.errorCallback_(a, u)) : o(u)
                } else if (i.canceled) {
                    const u = this.appDelete_ ? pA() : S2();
                    o(u)
                } else {
                    const u = I2();
                    o(u)
                }
            };
        this.canceled_ ? n(!1, new Wl(!1, null, !0)) : this.backoffId_ = k2(e, n, this.timeout_)
    }
    getPromise() {
        return this.promise_
    }
    cancel(e) {
        this.canceled_ = !0, this.appDelete_ = e || !1, this.backoffId_ !== null && x2(this.backoffId_), this.pendingConnection_ !== null && this.pendingConnection_.abort()
    }
}
class Wl {
    constructor(e, n, r) {
        this.wasSuccessCode = e, this.connection = n, this.canceled = !!r
    }
}

function O2(t, e) {
    e !== null && e.length > 0 && (t.Authorization = "Firebase " + e)
}

function L2(t, e) {
    t["X-Firebase-Storage-Version"] = "webjs/" + (e ? ? "AppManager")
}

function M2(t, e) {
    e && (t["X-Firebase-GMPID"] = e)
}

function F2(t, e) {
    e !== null && (t["X-Firebase-AppCheck"] = e)
}

function U2(t, e, n, r, i, s, o = !0) {
    const a = N2(t.urlParams),
        u = t.url + a,
        c = Object.assign({}, t.headers);
    return M2(c, e), O2(c, n), L2(c, s), F2(c, r), new V2(u, t.method, c, t.body, t.successCodes, t.additionalRetryCodes, t.handler, t.errorHandler, t.timeout, t.progressCallback, i, o)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function j2(t) {
    if (t.length === 0) return null;
    const e = t.lastIndexOf("/");
    return e === -1 ? "" : t.slice(0, e)
}

function B2(t) {
    const e = t.lastIndexOf("/", t.length - 2);
    return e === -1 ? t : t.slice(e + 1)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hc {
    constructor(e, n) {
        this._service = e, n instanceof an ? this._location = n : this._location = an.makeFromUrl(n, e.host)
    }
    toString() {
        return "gs://" + this._location.bucket + "/" + this._location.path
    }
    _newRef(e, n) {
        return new hc(e, n)
    }
    get root() {
        const e = new an(this._location.bucket, "");
        return this._newRef(this._service, e)
    }
    get bucket() {
        return this._location.bucket
    }
    get fullPath() {
        return this._location.path
    }
    get name() {
        return B2(this._location.path)
    }
    get storage() {
        return this._service
    }
    get parent() {
        const e = j2(this._location.path);
        if (e === null) return null;
        const n = new an(this._location.bucket, e);
        return new hc(this._service, n)
    }
    _throwIfRoot(e) {
        if (this._location.path === "") throw R2(e)
    }
}

function L0(t, e) {
    const n = e == null ? void 0 : e[_2];
    return n == null ? null : an.makeFromBucketSpec(n, t)
}

function $2(t, e, n, r = {}) {
    t.host = `${e}:${n}`, t._protocol = "http";
    const {
        mockUserToken: i
    } = r;
    i && (t._overrideAuthToken = typeof i == "string" ? i : xI(i, t.app.options.projectId))
}
class z2 {
    constructor(e, n, r, i, s) {
        this.app = e, this._authProvider = n, this._appCheckProvider = r, this._url = i, this._firebaseVersion = s, this._bucket = null, this._host = fA, this._protocol = "https", this._appId = null, this._deleted = !1, this._maxOperationRetryTime = w2, this._maxUploadRetryTime = T2, this._requests = new Set, i != null ? this._bucket = an.makeFromBucketSpec(i, this._host) : this._bucket = L0(this._host, this.app.options)
    }
    get host() {
        return this._host
    }
    set host(e) {
        this._host = e, this._url != null ? this._bucket = an.makeFromBucketSpec(this._url, e) : this._bucket = L0(e, this.app.options)
    }
    get maxUploadRetryTime() {
        return this._maxUploadRetryTime
    }
    set maxUploadRetryTime(e) {
        O0("time", 0, Number.POSITIVE_INFINITY, e), this._maxUploadRetryTime = e
    }
    get maxOperationRetryTime() {
        return this._maxOperationRetryTime
    }
    set maxOperationRetryTime(e) {
        O0("time", 0, Number.POSITIVE_INFINITY, e), this._maxOperationRetryTime = e
    }
    async _getAuthToken() {
        if (this._overrideAuthToken) return this._overrideAuthToken;
        const e = this._authProvider.getImmediate({
            optional: !0
        });
        if (e) {
            const n = await e.getToken();
            if (n !== null) return n.accessToken
        }
        return null
    }
    async _getAppCheckToken() {
        const e = this._appCheckProvider.getImmediate({
            optional: !0
        });
        return e ? (await e.getToken()).token : null
    }
    _delete() {
        return this._deleted || (this._deleted = !0, this._requests.forEach(e => e.cancel()), this._requests.clear()), Promise.resolve()
    }
    _makeStorageReference(e) {
        return new hc(this, e)
    }
    _makeRequest(e, n, r, i, s = !0) {
        if (this._deleted) return new C2(pA()); {
            const o = U2(e, this._appId, r, i, n, this._firebaseVersion, s);
            return this._requests.add(o), o.getPromise().then(() => this._requests.delete(o), () => this._requests.delete(o)), o
        }
    }
    async makeRequestWithTokens(e, n) {
        const [r, i] = await Promise.all([this._getAuthToken(), this._getAppCheckToken()]);
        return this._makeRequest(e, n, r, i).getPromise()
    }
}
const M0 = "@firebase/storage",
    F0 = "0.13.4";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mA = "storage";

function W2(t = qa(), e) {
    t = Ce(t);
    const r = ir(t, mA).getImmediate({
            identifier: e
        }),
        i = RI("storage");
    return i && q2(r, ...i), r
}

function q2(t, e, n, r = {}) {
    $2(t, e, n, r)
}

function H2(t, {
    instanceIdentifier: e
}) {
    const n = t.getProvider("app").getImmediate(),
        r = t.getProvider("auth-internal"),
        i = t.getProvider("app-check-internal");
    return new z2(n, r, i, e, Li)
}

function K2() {
    jt(new Nt(mA, H2, "PUBLIC").setMultipleInstances(!0)), ct(M0, F0, ""), ct(M0, F0, "esm2017")
}
K2();
const G2 = {
        apiKey: "AIzaSyATokp3Q0z-Z_4Pa90BX08bfbS2vakSSks",
        authDomain: "qayyimahlearning.firebaseapp.com",
        projectId: "qayyimahlearning",
        storageBucket: "qayyimahlearning.firebasestorage.app",
        messagingSenderId: "706212511881",
        appId: "1:706212511881:web:043a4c9db1371571b60658",
        measurementId: "G-VL0Y6CNV02"
    },
    eo = OI(G2),
    U0 = aD(eo),
    Q2 = w1(eo);
y2(eo);
W2(eo);
const to = () => (M.useEffect(() => {
        $f(U0, "page_view", {
            page_path: window.location.pathname,
            page_title: document.title
        })
    }, []), {
        trackEvent: M.useCallback((e, n = {}) => {
            $f(U0, e, n)
        }, [])
    }),
    Y2 = () => {
        const {
            trackEvent: t
        } = to(), [e, n] = It.useState(sessionStorage.getItem("language") || "ml"), r = () => {
            const s = e === "ml" ? "en" : "ml";
            sessionStorage.setItem("language", s), n(s), t("language_change", {
                from_language: e,
                to_language: s,
                method: "button_click"
            }), window.dispatchEvent(new Event("languageChange"))
        }, i = {
            ml: "മലയാളം",
            en: "English",
            ar: "عربي"
        };
        return D.jsx("button", {
            className: "language-toggle-btn",
            onClick: r,
            "aria-label": "Toggle language",
            style: {
                background: "none",
                border: "none",
                padding: "8px",
                cursor: "pointer",
                fontSize: "0.9rem",
                fontWeight: "bold",
                textTransform: "uppercase"
            },
            children: i[e]
        })
    },
    X2 = () => {
        const [t, e] = M.useState(!1), {
            isDarkMode: n,
            toggleTheme: r
        } = Fc(), [i, s] = M.useState(sessionStorage.getItem("language") || "ml"), o = () => e(!1), a = () => {
            const u = i === "ml" ? "en" : "ml";
            sessionStorage.setItem("language", u), s(u), window.dispatchEvent(new Event("languageChange"))
        };
        return D.jsxs(D.Fragment, {
            children: [D.jsx("div", {
                className: "mobile-menu-container",
                children: D.jsx("button", {
                    className: "hamburger-btn",
                    onClick: () => e(!t),
                    "aria-label": "Toggle menu",
                    children: D.jsx("i", {
                        className: `bi ${t?"bi-x-lg":"bi-list"}`
                    })
                })
            }), D.jsx("div", {
                className: `mobile-menu-overlay ${t?"open":""}`,
                onClick: o
            }), D.jsxs("div", {
                className: `mobile-menu ${t?"open":""}`,
                children: [D.jsx("button", {
                    className: "mobile-menu-close",
                    onClick: o,
                    "aria-label": "Close menu",
                    children: D.jsx("i", {
                        className: "bi bi-x-lg"
                    })
                }), D.jsxs("div", {
                    className: "mobile-menu-item",
                    children: [D.jsx("span", {
                        className: "mobile-menu-label",
                        children: "Theme"
                    }), D.jsx("button", {
                        onClick: r,
                        className: "btn",
                        style: {
                            background: n ? "white" : "linear-gradient(135deg, #2c3e50 0%, #1a252f 100%)",
                            color: n ? "#1e1e1e" : "white",
                            border: "none",
                            transition: "all 0.3s ease"
                        },
                        children: n ? D.jsx("i", {
                            className: "bi bi-sun-fill"
                        }) : D.jsx("i", {
                            className: "bi bi-moon-fill"
                        })
                    })]
                }), D.jsxs("div", {
                    className: "mobile-menu-item",
                    children: [D.jsx("span", {
                        className: "mobile-menu-label",
                        children: "Language"
                    }), D.jsx("button", {
                        onClick: a,
                        className: "btn",
                        style: {
                            background: n ? "white" : "linear-gradient(135deg, #2c3e50 0%, #1a252f 100%)",
                            color: n ? "#1e1e1e" : "white",
                            border: "none",
                            transition: "all 0.3s ease"
                        },
                        children: i === "ml" ? "മലയാളം" : "English"
                    })]
                })]
            })]
        })
    };

function J2(t) {
    if (typeof Proxy > "u") return t;
    const e = new Map,
        n = (...r) => t(...r);
    return new Proxy(n, {
        get: (r, i) => i === "create" ? t : (e.has(i) || e.set(i, t(i)), e.get(i))
    })
}

function ch(t) {
    return t !== null && typeof t == "object" && typeof t.start == "function"
}
const ap = t => Array.isArray(t);

function gA(t, e) {
    if (!Array.isArray(e)) return !1;
    const n = e.length;
    if (n !== t.length) return !1;
    for (let r = 0; r < n; r++)
        if (e[r] !== t[r]) return !1;
    return !0
}

function Da(t) {
    return typeof t == "string" || Array.isArray(t)
}

function j0(t) {
    const e = [{}, {}];
    return t == null || t.values.forEach((n, r) => {
        e[0][r] = n.get(), e[1][r] = n.getVelocity()
    }), e
}

function _g(t, e, n, r) {
    if (typeof e == "function") {
        const [i, s] = j0(r);
        e = e(n !== void 0 ? n : t.custom, i, s)
    }
    if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") {
        const [i, s] = j0(r);
        e = e(n !== void 0 ? n : t.custom, i, s)
    }
    return e
}

function hh(t, e, n) {
    const r = t.getProps();
    return _g(r, e, n !== void 0 ? n : r.custom, t)
}
const wg = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
    Tg = ["initial", ...wg],
    tl = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
    Ui = new Set(tl),
    Wn = t => t * 1e3,
    qn = t => t / 1e3,
    Z2 = {
        type: "spring",
        stiffness: 500,
        damping: 25,
        restSpeed: 10
    },
    eF = t => ({
        type: "spring",
        stiffness: 550,
        damping: t === 0 ? 2 * Math.sqrt(550) : 30,
        restSpeed: 10
    }),
    tF = {
        type: "keyframes",
        duration: .8
    },
    nF = {
        type: "keyframes",
        ease: [.25, .1, .35, 1],
        duration: .3
    },
    rF = (t, {
        keyframes: e
    }) => e.length > 2 ? tF : Ui.has(t) ? t.startsWith("scale") ? eF(e[1]) : Z2 : nF;

function Eg(t, e) {
    return t ? t[e] || t.default || t : void 0
}
const iF = {
        useManualTiming: !1
    },
    sF = t => t !== null;

function dh(t, {
    repeat: e,
    repeatType: n = "loop"
}, r) {
    const i = t.filter(sF),
        s = e && n !== "loop" && e % 2 === 1 ? 0 : i.length - 1;
    return !s || r === void 0 ? i[s] : r
}
const ht = t => t;

function oF(t) {
    let e = new Set,
        n = new Set,
        r = !1,
        i = !1;
    const s = new WeakSet;
    let o = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    };

    function a(c) {
        s.has(c) && (u.schedule(c), t()), c(o)
    }
    const u = {
        schedule: (c, h = !1, f = !1) => {
            const _ = f && r ? e : n;
            return h && s.add(c), _.has(c) || _.add(c), c
        },
        cancel: c => {
            n.delete(c), s.delete(c)
        },
        process: c => {
            if (o = c, r) {
                i = !0;
                return
            }
            r = !0, [e, n] = [n, e], n.clear(), e.forEach(a), r = !1, i && (i = !1, u.process(c))
        }
    };
    return u
}
const ql = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"],
    aF = 40;

function yA(t, e) {
    let n = !1,
        r = !0;
    const i = {
            delta: 0,
            timestamp: 0,
            isProcessing: !1
        },
        s = () => n = !0,
        o = ql.reduce((w, v) => (w[v] = oF(s), w), {}),
        {
            read: a,
            resolveKeyframes: u,
            update: c,
            preRender: h,
            render: f,
            postRender: m
        } = o,
        _ = () => {
            const w = performance.now();
            n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(w - i.timestamp, aF), 1), i.timestamp = w, i.isProcessing = !0, a.process(i), u.process(i), c.process(i), h.process(i), f.process(i), m.process(i), i.isProcessing = !1, n && e && (r = !1, t(_))
        },
        I = () => {
            n = !0, r = !0, i.isProcessing || t(_)
        };
    return {
        schedule: ql.reduce((w, v) => {
            const T = o[v];
            return w[v] = (x, O = !1, U = !1) => (n || I(), T.schedule(x, O, U)), w
        }, {}),
        cancel: w => {
            for (let v = 0; v < ql.length; v++) o[ql[v]].cancel(w)
        },
        state: i,
        steps: o
    }
}
const {
    schedule: he,
    cancel: qr,
    state: He,
    steps: Rd
} = yA(typeof requestAnimationFrame < "u" ? requestAnimationFrame : ht, !0), vA = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, lF = 1e-7, uF = 12;

function cF(t, e, n, r, i) {
    let s, o, a = 0;
    do o = e + (n - e) / 2, s = vA(o, r, i) - t, s > 0 ? n = o : e = o; while (Math.abs(s) > lF && ++a < uF);
    return o
}

function nl(t, e, n, r) {
    if (t === e && n === r) return ht;
    const i = s => cF(s, 0, 1, t, n);
    return s => s === 0 || s === 1 ? s : vA(i(s), e, r)
}
const _A = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2,
    wA = t => e => 1 - t(1 - e),
    TA = nl(.33, 1.53, .69, .99),
    Ig = wA(TA),
    EA = _A(Ig),
    IA = t => (t *= 2) < 1 ? .5 * Ig(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))),
    Sg = t => 1 - Math.sin(Math.acos(t)),
    SA = wA(Sg),
    AA = _A(Sg),
    PA = t => /^0[^.\s]+$/u.test(t);

function hF(t) {
    return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || PA(t) : !0
}
let lp = ht;
const RA = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),
    CA = t => e => typeof e == "string" && e.startsWith(t),
    kA = CA("--"),
    dF = CA("var(--"),
    Ag = t => dF(t) ? fF.test(t.split("/*")[0].trim()) : !1,
    fF = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
    pF = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;

function mF(t) {
    const e = pF.exec(t);
    if (!e) return [, ];
    const [, n, r, i] = e;
    return [`--${n??r}`, i]
}

function xA(t, e, n = 1) {
    const [r, i] = mF(t);
    if (!r) return;
    const s = window.getComputedStyle(e).getPropertyValue(r);
    if (s) {
        const o = s.trim();
        return RA(o) ? parseFloat(o) : o
    }
    return Ag(i) ? xA(i, e, n + 1) : i
}
const Hr = (t, e, n) => n > e ? e : n < t ? t : n,
    no = {
        test: t => typeof t == "number",
        parse: parseFloat,
        transform: t => t
    },
    Va = { ...no,
        transform: t => Hr(0, 1, t)
    },
    Hl = { ...no,
        default: 1
    },
    rl = t => ({
        test: e => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
        parse: parseFloat,
        transform: e => `${e}${t}`
    }),
    fr = rl("deg"),
    Sn = rl("%"),
    G = rl("px"),
    gF = rl("vh"),
    yF = rl("vw"),
    B0 = { ...Sn,
        parse: t => Sn.parse(t) / 100,
        transform: t => Sn.transform(t * 100)
    },
    vF = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]),
    $0 = t => t === no || t === G,
    z0 = (t, e) => parseFloat(t.split(", ")[e]),
    W0 = (t, e) => (n, {
        transform: r
    }) => {
        if (r === "none" || !r) return 0;
        const i = r.match(/^matrix3d\((.+)\)$/u);
        if (i) return z0(i[1], e); {
            const s = r.match(/^matrix\((.+)\)$/u);
            return s ? z0(s[1], t) : 0
        }
    },
    _F = new Set(["x", "y", "z"]),
    wF = tl.filter(t => !_F.has(t));

function TF(t) {
    const e = [];
    return wF.forEach(n => {
        const r = t.getValue(n);
        r !== void 0 && (e.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0))
    }), e
}
const $s = {
    width: ({
        x: t
    }, {
        paddingLeft: e = "0",
        paddingRight: n = "0"
    }) => t.max - t.min - parseFloat(e) - parseFloat(n),
    height: ({
        y: t
    }, {
        paddingTop: e = "0",
        paddingBottom: n = "0"
    }) => t.max - t.min - parseFloat(e) - parseFloat(n),
    top: (t, {
        top: e
    }) => parseFloat(e),
    left: (t, {
        left: e
    }) => parseFloat(e),
    bottom: ({
        y: t
    }, {
        top: e
    }) => parseFloat(e) + (t.max - t.min),
    right: ({
        x: t
    }, {
        left: e
    }) => parseFloat(e) + (t.max - t.min),
    x: W0(4, 13),
    y: W0(5, 14)
};
$s.translateX = $s.x;
$s.translateY = $s.y;
const bA = t => e => e.test(t),
    EF = {
        test: t => t === "auto",
        parse: t => t
    },
    NA = [no, G, Sn, fr, yF, gF, EF],
    q0 = t => NA.find(bA(t)),
    Si = new Set;
let up = !1,
    cp = !1;

function DA() {
    if (cp) {
        const t = Array.from(Si).filter(r => r.needsMeasurement),
            e = new Set(t.map(r => r.element)),
            n = new Map;
        e.forEach(r => {
            const i = TF(r);
            i.length && (n.set(r, i), r.render())
        }), t.forEach(r => r.measureInitialState()), e.forEach(r => {
            r.render();
            const i = n.get(r);
            i && i.forEach(([s, o]) => {
                var a;
                (a = r.getValue(s)) === null || a === void 0 || a.set(o)
            })
        }), t.forEach(r => r.measureEndState()), t.forEach(r => {
            r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY)
        })
    }
    cp = !1, up = !1, Si.forEach(t => t.complete()), Si.clear()
}

function VA() {
    Si.forEach(t => {
        t.readKeyframes(), t.needsMeasurement && (cp = !0)
    })
}

function IF() {
    VA(), DA()
}
class Pg {
    constructor(e, n, r, i, s, o = !1) {
        this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = n, this.name = r, this.motionValue = i, this.element = s, this.isAsync = o
    }
    scheduleResolve() {
        this.isScheduled = !0, this.isAsync ? (Si.add(this), up || (up = !0, he.read(VA), he.resolveKeyframes(DA))) : (this.readKeyframes(), this.complete())
    }
    readKeyframes() {
        const {
            unresolvedKeyframes: e,
            name: n,
            element: r,
            motionValue: i
        } = this;
        for (let s = 0; s < e.length; s++)
            if (e[s] === null)
                if (s === 0) {
                    const o = i == null ? void 0 : i.get(),
                        a = e[e.length - 1];
                    if (o !== void 0) e[0] = o;
                    else if (r && n) {
                        const u = r.readValue(n, a);
                        u != null && (e[0] = u)
                    }
                    e[0] === void 0 && (e[0] = a), i && o === void 0 && i.set(e[0])
                } else e[s] = e[s - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Si.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1, Si.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
const ta = t => Math.round(t * 1e5) / 1e5,
    Rg = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

function SF(t) {
    return t == null
}
const AF = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
    Cg = (t, e) => n => !!(typeof n == "string" && AF.test(n) && n.startsWith(t) || e && !SF(n) && Object.prototype.hasOwnProperty.call(n, e)),
    OA = (t, e, n) => r => {
        if (typeof r != "string") return r;
        const [i, s, o, a] = r.match(Rg);
        return {
            [t]: parseFloat(i),
            [e]: parseFloat(s),
            [n]: parseFloat(o),
            alpha: a !== void 0 ? parseFloat(a) : 1
        }
    },
    PF = t => Hr(0, 255, t),
    Cd = { ...no,
        transform: t => Math.round(PF(t))
    },
    _i = {
        test: Cg("rgb", "red"),
        parse: OA("red", "green", "blue"),
        transform: ({
            red: t,
            green: e,
            blue: n,
            alpha: r = 1
        }) => "rgba(" + Cd.transform(t) + ", " + Cd.transform(e) + ", " + Cd.transform(n) + ", " + ta(Va.transform(r)) + ")"
    };

function RF(t) {
    let e = "",
        n = "",
        r = "",
        i = "";
    return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), r = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), r = t.substring(3, 4), i = t.substring(4, 5), e += e, n += n, r += r, i += i), {
        red: parseInt(e, 16),
        green: parseInt(n, 16),
        blue: parseInt(r, 16),
        alpha: i ? parseInt(i, 16) / 255 : 1
    }
}
const hp = {
        test: Cg("#"),
        parse: RF,
        transform: _i.transform
    },
    ds = {
        test: Cg("hsl", "hue"),
        parse: OA("hue", "saturation", "lightness"),
        transform: ({
            hue: t,
            saturation: e,
            lightness: n,
            alpha: r = 1
        }) => "hsla(" + Math.round(t) + ", " + Sn.transform(ta(e)) + ", " + Sn.transform(ta(n)) + ", " + ta(Va.transform(r)) + ")"
    },
    st = {
        test: t => _i.test(t) || hp.test(t) || ds.test(t),
        parse: t => _i.test(t) ? _i.parse(t) : ds.test(t) ? ds.parse(t) : hp.parse(t),
        transform: t => typeof t == "string" ? t : t.hasOwnProperty("red") ? _i.transform(t) : ds.transform(t)
    },
    CF = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

function kF(t) {
    var e, n;
    return isNaN(t) && typeof t == "string" && (((e = t.match(Rg)) === null || e === void 0 ? void 0 : e.length) || 0) + (((n = t.match(CF)) === null || n === void 0 ? void 0 : n.length) || 0) > 0
}
const LA = "number",
    MA = "color",
    xF = "var",
    bF = "var(",
    H0 = "${}",
    NF = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;

function Oa(t) {
    const e = t.toString(),
        n = [],
        r = {
            color: [],
            number: [],
            var: []
        },
        i = [];
    let s = 0;
    const a = e.replace(NF, u => (st.test(u) ? (r.color.push(s), i.push(MA), n.push(st.parse(u))) : u.startsWith(bF) ? (r.var.push(s), i.push(xF), n.push(u)) : (r.number.push(s), i.push(LA), n.push(parseFloat(u))), ++s, H0)).split(H0);
    return {
        values: n,
        split: a,
        indexes: r,
        types: i
    }
}

function FA(t) {
    return Oa(t).values
}

function UA(t) {
    const {
        split: e,
        types: n
    } = Oa(t), r = e.length;
    return i => {
        let s = "";
        for (let o = 0; o < r; o++)
            if (s += e[o], i[o] !== void 0) {
                const a = n[o];
                a === LA ? s += ta(i[o]) : a === MA ? s += st.transform(i[o]) : s += i[o]
            }
        return s
    }
}
const DF = t => typeof t == "number" ? 0 : t;

function VF(t) {
    const e = FA(t);
    return UA(t)(e.map(DF))
}
const Kr = {
        test: kF,
        parse: FA,
        createTransformer: UA,
        getAnimatableNone: VF
    },
    OF = new Set(["brightness", "contrast", "saturate", "opacity"]);

function LF(t) {
    const [e, n] = t.slice(0, -1).split("(");
    if (e === "drop-shadow") return t;
    const [r] = n.match(Rg) || [];
    if (!r) return t;
    const i = n.replace(r, "");
    let s = OF.has(e) ? 1 : 0;
    return r !== n && (s *= 100), e + "(" + s + i + ")"
}
const MF = /\b([a-z-]*)\(.*?\)/gu,
    dp = { ...Kr,
        getAnimatableNone: t => {
            const e = t.match(MF);
            return e ? e.map(LF).join(" ") : t
        }
    },
    FF = {
        borderWidth: G,
        borderTopWidth: G,
        borderRightWidth: G,
        borderBottomWidth: G,
        borderLeftWidth: G,
        borderRadius: G,
        radius: G,
        borderTopLeftRadius: G,
        borderTopRightRadius: G,
        borderBottomRightRadius: G,
        borderBottomLeftRadius: G,
        width: G,
        maxWidth: G,
        height: G,
        maxHeight: G,
        top: G,
        right: G,
        bottom: G,
        left: G,
        padding: G,
        paddingTop: G,
        paddingRight: G,
        paddingBottom: G,
        paddingLeft: G,
        margin: G,
        marginTop: G,
        marginRight: G,
        marginBottom: G,
        marginLeft: G,
        backgroundPositionX: G,
        backgroundPositionY: G
    },
    UF = {
        rotate: fr,
        rotateX: fr,
        rotateY: fr,
        rotateZ: fr,
        scale: Hl,
        scaleX: Hl,
        scaleY: Hl,
        scaleZ: Hl,
        skew: fr,
        skewX: fr,
        skewY: fr,
        distance: G,
        translateX: G,
        translateY: G,
        translateZ: G,
        x: G,
        y: G,
        z: G,
        perspective: G,
        transformPerspective: G,
        opacity: Va,
        originX: B0,
        originY: B0,
        originZ: G
    },
    K0 = { ...no,
        transform: Math.round
    },
    kg = { ...FF,
        ...UF,
        zIndex: K0,
        size: G,
        fillOpacity: Va,
        strokeOpacity: Va,
        numOctaves: K0
    },
    jF = { ...kg,
        color: st,
        backgroundColor: st,
        outlineColor: st,
        fill: st,
        stroke: st,
        borderColor: st,
        borderTopColor: st,
        borderRightColor: st,
        borderBottomColor: st,
        borderLeftColor: st,
        filter: dp,
        WebkitFilter: dp
    },
    xg = t => jF[t];

function jA(t, e) {
    let n = xg(t);
    return n !== dp && (n = Kr), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0
}
const BF = new Set(["auto", "none", "0"]);

function $F(t, e, n) {
    let r = 0,
        i;
    for (; r < t.length && !i;) {
        const s = t[r];
        typeof s == "string" && !BF.has(s) && Oa(s).values.length && (i = t[r]), r++
    }
    if (i && n)
        for (const s of e) t[s] = jA(n, i)
}
class BA extends Pg {
    constructor(e, n, r, i, s) {
        super(e, n, r, i, s, !0)
    }
    readKeyframes() {
        const {
            unresolvedKeyframes: e,
            element: n,
            name: r
        } = this;
        if (!n || !n.current) return;
        super.readKeyframes();
        for (let u = 0; u < e.length; u++) {
            let c = e[u];
            if (typeof c == "string" && (c = c.trim(), Ag(c))) {
                const h = xA(c, n.current);
                h !== void 0 && (e[u] = h), u === e.length - 1 && (this.finalKeyframe = c)
            }
        }
        if (this.resolveNoneKeyframes(), !vF.has(r) || e.length !== 2) return;
        const [i, s] = e, o = q0(i), a = q0(s);
        if (o !== a)
            if ($0(o) && $0(a))
                for (let u = 0; u < e.length; u++) {
                    const c = e[u];
                    typeof c == "string" && (e[u] = parseFloat(c))
                } else this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        const {
            unresolvedKeyframes: e,
            name: n
        } = this, r = [];
        for (let i = 0; i < e.length; i++) hF(e[i]) && r.push(i);
        r.length && $F(e, r, n)
    }
    measureInitialState() {
        const {
            element: e,
            unresolvedKeyframes: n,
            name: r
        } = this;
        if (!e || !e.current) return;
        r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = $s[r](e.measureViewportBox(), window.getComputedStyle(e.current)), n[0] = this.measuredOrigin;
        const i = n[n.length - 1];
        i !== void 0 && e.getValue(r, i).jump(i, !1)
    }
    measureEndState() {
        var e;
        const {
            element: n,
            name: r,
            unresolvedKeyframes: i
        } = this;
        if (!n || !n.current) return;
        const s = n.getValue(r);
        s && s.jump(this.measuredOrigin, !1);
        const o = i.length - 1,
            a = i[o];
        i[o] = $s[r](n.measureViewportBox(), window.getComputedStyle(n.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([u, c]) => {
            n.getValue(u).set(c)
        }), this.resolveNoneKeyframes()
    }
}

function bg(t) {
    return typeof t == "function"
}
let yu;

function zF() {
    yu = void 0
}
const An = {
        now: () => (yu === void 0 && An.set(He.isProcessing || iF.useManualTiming ? He.timestamp : performance.now()), yu),
        set: t => {
            yu = t, queueMicrotask(zF)
        }
    },
    G0 = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (Kr.test(t) || t === "0") && !t.startsWith("url("));

function WF(t) {
    const e = t[0];
    if (t.length === 1) return !0;
    for (let n = 0; n < t.length; n++)
        if (t[n] !== e) return !0
}

function qF(t, e, n, r) {
    const i = t[0];
    if (i === null) return !1;
    if (e === "display" || e === "visibility") return !0;
    const s = t[t.length - 1],
        o = G0(i, e),
        a = G0(s, e);
    return !o || !a ? !1 : WF(t) || (n === "spring" || bg(n)) && r
}
const HF = 40;
class $A {
    constructor({
        autoplay: e = !0,
        delay: n = 0,
        type: r = "keyframes",
        repeat: i = 0,
        repeatDelay: s = 0,
        repeatType: o = "loop",
        ...a
    }) {
        this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = An.now(), this.options = {
            autoplay: e,
            delay: n,
            type: r,
            repeat: i,
            repeatDelay: s,
            repeatType: o,
            ...a
        }, this.updateFinishedPromise()
    }
    calcStartTime() {
        return this.resolvedAt ? this.resolvedAt - this.createdAt > HF ? this.resolvedAt : this.createdAt : this.createdAt
    }
    get resolved() {
        return !this._resolved && !this.hasAttemptedResolve && IF(), this._resolved
    }
    onKeyframesResolved(e, n) {
        this.resolvedAt = An.now(), this.hasAttemptedResolve = !0;
        const {
            name: r,
            type: i,
            velocity: s,
            delay: o,
            onComplete: a,
            onUpdate: u,
            isGenerator: c
        } = this.options;
        if (!c && !qF(e, r, i, s))
            if (o) this.options.duration = 0;
            else {
                u == null || u(dh(e, this.options, n)), a == null || a(), this.resolveFinishedPromise();
                return
            }
        const h = this.initPlayback(e, n);
        h !== !1 && (this._resolved = {
            keyframes: e,
            finalKeyframe: n,
            ...h
        }, this.onPostResolved())
    }
    onPostResolved() {}
    then(e, n) {
        return this.currentFinishedPromise.then(e, n)
    }
    flatten() {
        this.options.type = "keyframes", this.options.ease = "linear"
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(e => {
            this.resolveFinishedPromise = e
        })
    }
}

function zA(t, e) {
    return e ? t * (1e3 / e) : 0
}
const KF = 5;

function WA(t, e, n) {
    const r = Math.max(e - KF, 0);
    return zA(n - t(r), e - r)
}
const kd = .001,
    GF = .01,
    QF = 10,
    YF = .05,
    XF = 1;

function JF({
    duration: t = 800,
    bounce: e = .25,
    velocity: n = 0,
    mass: r = 1
}) {
    let i, s, o = 1 - e;
    o = Hr(YF, XF, o), t = Hr(GF, QF, qn(t)), o < 1 ? (i = c => {
        const h = c * o,
            f = h * t,
            m = h - n,
            _ = fp(c, o),
            I = Math.exp(-f);
        return kd - m / _ * I
    }, s = c => {
        const f = c * o * t,
            m = f * n + n,
            _ = Math.pow(o, 2) * Math.pow(c, 2) * t,
            I = Math.exp(-f),
            R = fp(Math.pow(c, 2), o);
        return (-i(c) + kd > 0 ? -1 : 1) * ((m - _) * I) / R
    }) : (i = c => {
        const h = Math.exp(-c * t),
            f = (c - n) * t + 1;
        return -kd + h * f
    }, s = c => {
        const h = Math.exp(-c * t),
            f = (n - c) * (t * t);
        return h * f
    });
    const a = 5 / t,
        u = eU(i, s, a);
    if (t = Wn(t), isNaN(u)) return {
        stiffness: 100,
        damping: 10,
        duration: t
    }; {
        const c = Math.pow(u, 2) * r;
        return {
            stiffness: c,
            damping: o * 2 * Math.sqrt(r * c),
            duration: t
        }
    }
}
const ZF = 12;

function eU(t, e, n) {
    let r = n;
    for (let i = 1; i < ZF; i++) r = r - t(r) / e(r);
    return r
}

function fp(t, e) {
    return t * Math.sqrt(1 - e * e)
}
const tU = ["duration", "bounce"],
    nU = ["stiffness", "damping", "mass"];

function Q0(t, e) {
    return e.some(n => t[n] !== void 0)
}

function rU(t) {
    let e = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...t
    };
    if (!Q0(t, nU) && Q0(t, tU)) {
        const n = JF(t);
        e = { ...e,
            ...n,
            mass: 1
        }, e.isResolvedFromDuration = !0
    }
    return e
}

function qA({
    keyframes: t,
    restDelta: e,
    restSpeed: n,
    ...r
}) {
    const i = t[0],
        s = t[t.length - 1],
        o = {
            done: !1,
            value: i
        },
        {
            stiffness: a,
            damping: u,
            mass: c,
            duration: h,
            velocity: f,
            isResolvedFromDuration: m
        } = rU({ ...r,
            velocity: -qn(r.velocity || 0)
        }),
        _ = f || 0,
        I = u / (2 * Math.sqrt(a * c)),
        R = s - i,
        k = qn(Math.sqrt(a / c)),
        w = Math.abs(R) < 5;
    n || (n = w ? .01 : 2), e || (e = w ? .005 : .5);
    let v;
    if (I < 1) {
        const T = fp(k, I);
        v = x => {
            const O = Math.exp(-I * k * x);
            return s - O * ((_ + I * k * R) / T * Math.sin(T * x) + R * Math.cos(T * x))
        }
    } else if (I === 1) v = T => s - Math.exp(-k * T) * (R + (_ + k * R) * T);
    else {
        const T = k * Math.sqrt(I * I - 1);
        v = x => {
            const O = Math.exp(-I * k * x),
                U = Math.min(T * x, 300);
            return s - O * ((_ + I * k * R) * Math.sinh(U) + T * R * Math.cosh(U)) / T
        }
    }
    return {
        calculatedDuration: m && h || null,
        next: T => {
            const x = v(T);
            if (m) o.done = T >= h;
            else {
                let O = 0;
                I < 1 && (O = T === 0 ? Wn(_) : WA(v, T, x));
                const U = Math.abs(O) <= n,
                    S = Math.abs(s - x) <= e;
                o.done = U && S
            }
            return o.value = o.done ? s : x, o
        }
    }
}

function Y0({
    keyframes: t,
    velocity: e = 0,
    power: n = .8,
    timeConstant: r = 325,
    bounceDamping: i = 10,
    bounceStiffness: s = 500,
    modifyTarget: o,
    min: a,
    max: u,
    restDelta: c = .5,
    restSpeed: h
}) {
    const f = t[0],
        m = {
            done: !1,
            value: f
        },
        _ = g => a !== void 0 && g < a || u !== void 0 && g > u,
        I = g => a === void 0 ? u : u === void 0 || Math.abs(a - g) < Math.abs(u - g) ? a : u;
    let R = n * e;
    const k = f + R,
        w = o === void 0 ? k : o(k);
    w !== k && (R = w - f);
    const v = g => -R * Math.exp(-g / r),
        T = g => w + v(g),
        x = g => {
            const E = v(g),
                A = T(g);
            m.done = Math.abs(E) <= c, m.value = m.done ? w : A
        };
    let O, U;
    const S = g => {
        _(m.value) && (O = g, U = qA({
            keyframes: [m.value, I(m.value)],
            velocity: WA(T, g, m.value),
            damping: i,
            stiffness: s,
            restDelta: c,
            restSpeed: h
        }))
    };
    return S(0), {
        calculatedDuration: null,
        next: g => {
            let E = !1;
            return !U && O === void 0 && (E = !0, x(g), S(g)), O !== void 0 && g >= O ? U.next(g - O) : (!E && x(g), m)
        }
    }
}
const iU = nl(.42, 0, 1, 1),
    sU = nl(0, 0, .58, 1),
    HA = nl(.42, 0, .58, 1),
    oU = t => Array.isArray(t) && typeof t[0] != "number",
    Ng = t => Array.isArray(t) && typeof t[0] == "number",
    X0 = {
        linear: ht,
        easeIn: iU,
        easeInOut: HA,
        easeOut: sU,
        circIn: Sg,
        circInOut: AA,
        circOut: SA,
        backIn: Ig,
        backInOut: EA,
        backOut: TA,
        anticipate: IA
    },
    J0 = t => {
        if (Ng(t)) {
            lp(t.length === 4);
            const [e, n, r, i] = t;
            return nl(e, n, r, i)
        } else if (typeof t == "string") return lp(X0[t] !== void 0), X0[t];
        return t
    },
    aU = (t, e) => n => e(t(n)),
    Hn = (...t) => t.reduce(aU),
    zs = (t, e, n) => {
        const r = e - t;
        return r === 0 ? 1 : (n - t) / r
    },
    Ee = (t, e, n) => t + (e - t) * n;

function xd(t, e, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
}

function lU({
    hue: t,
    saturation: e,
    lightness: n,
    alpha: r
}) {
    t /= 360, e /= 100, n /= 100;
    let i = 0,
        s = 0,
        o = 0;
    if (!e) i = s = o = n;
    else {
        const a = n < .5 ? n * (1 + e) : n + e - n * e,
            u = 2 * n - a;
        i = xd(u, a, t + 1 / 3), s = xd(u, a, t), o = xd(u, a, t - 1 / 3)
    }
    return {
        red: Math.round(i * 255),
        green: Math.round(s * 255),
        blue: Math.round(o * 255),
        alpha: r
    }
}

function dc(t, e) {
    return n => n > 0 ? e : t
}
const bd = (t, e, n) => {
        const r = t * t,
            i = n * (e * e - r) + r;
        return i < 0 ? 0 : Math.sqrt(i)
    },
    uU = [hp, _i, ds],
    cU = t => uU.find(e => e.test(t));

function Z0(t) {
    const e = cU(t);
    if (!e) return !1;
    let n = e.parse(t);
    return e === ds && (n = lU(n)), n
}
const ew = (t, e) => {
        const n = Z0(t),
            r = Z0(e);
        if (!n || !r) return dc(t, e);
        const i = { ...n
        };
        return s => (i.red = bd(n.red, r.red, s), i.green = bd(n.green, r.green, s), i.blue = bd(n.blue, r.blue, s), i.alpha = Ee(n.alpha, r.alpha, s), _i.transform(i))
    },
    pp = new Set(["none", "hidden"]);

function hU(t, e) {
    return pp.has(t) ? n => n <= 0 ? t : e : n => n >= 1 ? e : t
}

function dU(t, e) {
    return n => Ee(t, e, n)
}

function Dg(t) {
    return typeof t == "number" ? dU : typeof t == "string" ? Ag(t) ? dc : st.test(t) ? ew : mU : Array.isArray(t) ? KA : typeof t == "object" ? st.test(t) ? ew : fU : dc
}

function KA(t, e) {
    const n = [...t],
        r = n.length,
        i = t.map((s, o) => Dg(s)(s, e[o]));
    return s => {
        for (let o = 0; o < r; o++) n[o] = i[o](s);
        return n
    }
}

function fU(t, e) {
    const n = { ...t,
            ...e
        },
        r = {};
    for (const i in n) t[i] !== void 0 && e[i] !== void 0 && (r[i] = Dg(t[i])(t[i], e[i]));
    return i => {
        for (const s in r) n[s] = r[s](i);
        return n
    }
}

function pU(t, e) {
    var n;
    const r = [],
        i = {
            color: 0,
            var: 0,
            number: 0
        };
    for (let s = 0; s < e.values.length; s++) {
        const o = e.types[s],
            a = t.indexes[o][i[o]],
            u = (n = t.values[a]) !== null && n !== void 0 ? n : 0;
        r[s] = u, i[o]++
    }
    return r
}
const mU = (t, e) => {
    const n = Kr.createTransformer(e),
        r = Oa(t),
        i = Oa(e);
    return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? pp.has(t) && !i.values.length || pp.has(e) && !r.values.length ? hU(t, e) : Hn(KA(pU(r, i), i.values), n) : dc(t, e)
};

function GA(t, e, n) {
    return typeof t == "number" && typeof e == "number" && typeof n == "number" ? Ee(t, e, n) : Dg(t)(t, e)
}

function gU(t, e, n) {
    const r = [],
        i = n || GA,
        s = t.length - 1;
    for (let o = 0; o < s; o++) {
        let a = i(t[o], t[o + 1]);
        if (e) {
            const u = Array.isArray(e) ? e[o] || ht : e;
            a = Hn(u, a)
        }
        r.push(a)
    }
    return r
}

function yU(t, e, {
    clamp: n = !0,
    ease: r,
    mixer: i
} = {}) {
    const s = t.length;
    if (lp(s === e.length), s === 1) return () => e[0];
    if (s === 2 && t[0] === t[1]) return () => e[1];
    t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse());
    const o = gU(e, r, i),
        a = o.length,
        u = c => {
            let h = 0;
            if (a > 1)
                for (; h < t.length - 2 && !(c < t[h + 1]); h++);
            const f = zs(t[h], t[h + 1], c);
            return o[h](f)
        };
    return n ? c => u(Hr(t[0], t[s - 1], c)) : u
}

function vU(t, e) {
    const n = t[t.length - 1];
    for (let r = 1; r <= e; r++) {
        const i = zs(0, e, r);
        t.push(Ee(n, 1, i))
    }
}

function _U(t) {
    const e = [0];
    return vU(e, t.length - 1), e
}

function wU(t, e) {
    return t.map(n => n * e)
}

function TU(t, e) {
    return t.map(() => e || HA).splice(0, t.length - 1)
}

function fc({
    duration: t = 300,
    keyframes: e,
    times: n,
    ease: r = "easeInOut"
}) {
    const i = oU(r) ? r.map(J0) : J0(r),
        s = {
            done: !1,
            value: e[0]
        },
        o = wU(n && n.length === e.length ? n : _U(e), t),
        a = yU(o, e, {
            ease: Array.isArray(i) ? i : TU(e, i)
        });
    return {
        calculatedDuration: t,
        next: u => (s.value = a(u), s.done = u >= t, s)
    }
}
const tw = 2e4;

function EU(t) {
    let e = 0;
    const n = 50;
    let r = t.next(e);
    for (; !r.done && e < tw;) e += n, r = t.next(e);
    return e >= tw ? 1 / 0 : e
}
const IU = t => {
        const e = ({
            timestamp: n
        }) => t(n);
        return {
            start: () => he.update(e, !0),
            stop: () => qr(e),
            now: () => He.isProcessing ? He.timestamp : An.now()
        }
    },
    SU = {
        decay: Y0,
        inertia: Y0,
        tween: fc,
        keyframes: fc,
        spring: qA
    },
    AU = t => t / 100;
class Vg extends $A {
    constructor(e) {
        super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
            if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return;
            this.teardown();
            const {
                onStop: u
            } = this.options;
            u && u()
        };
        const {
            name: n,
            motionValue: r,
            element: i,
            keyframes: s
        } = this.options, o = (i == null ? void 0 : i.KeyframeResolver) || Pg, a = (u, c) => this.onKeyframesResolved(u, c);
        this.resolver = new o(s, a, n, r, i), this.resolver.scheduleResolve()
    }
    flatten() {
        super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes))
    }
    initPlayback(e) {
        const {
            type: n = "keyframes",
            repeat: r = 0,
            repeatDelay: i = 0,
            repeatType: s,
            velocity: o = 0
        } = this.options, a = bg(n) ? n : SU[n] || fc;
        let u, c;
        a !== fc && typeof e[0] != "number" && (u = Hn(AU, GA(e[0], e[1])), e = [0, 100]);
        const h = a({ ...this.options,
            keyframes: e
        });
        s === "mirror" && (c = a({ ...this.options,
            keyframes: [...e].reverse(),
            velocity: -o
        })), h.calculatedDuration === null && (h.calculatedDuration = EU(h));
        const {
            calculatedDuration: f
        } = h, m = f + i, _ = m * (r + 1) - i;
        return {
            generator: h,
            mirroredGenerator: c,
            mapPercentToKeyframes: u,
            calculatedDuration: f,
            resolvedDuration: m,
            totalDuration: _
        }
    }
    onPostResolved() {
        const {
            autoplay: e = !0
        } = this.options;
        this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState
    }
    tick(e, n = !1) {
        const {
            resolved: r
        } = this;
        if (!r) {
            const {
                keyframes: g
            } = this.options;
            return {
                done: !0,
                value: g[g.length - 1]
            }
        }
        const {
            finalKeyframe: i,
            generator: s,
            mirroredGenerator: o,
            mapPercentToKeyframes: a,
            keyframes: u,
            calculatedDuration: c,
            totalDuration: h,
            resolvedDuration: f
        } = r;
        if (this.startTime === null) return s.next(0);
        const {
            delay: m,
            repeat: _,
            repeatType: I,
            repeatDelay: R,
            onUpdate: k
        } = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - h / this.speed, this.startTime)), n ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
        const w = this.currentTime - m * (this.speed >= 0 ? 1 : -1),
            v = this.speed >= 0 ? w < 0 : w > h;
        this.currentTime = Math.max(w, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = h);
        let T = this.currentTime,
            x = s;
        if (_) {
            const g = Math.min(this.currentTime, h) / f;
            let E = Math.floor(g),
                A = g % 1;
            !A && g >= 1 && (A = 1), A === 1 && E--, E = Math.min(E, _ + 1), !!(E % 2) && (I === "reverse" ? (A = 1 - A, R && (A -= R / f)) : I === "mirror" && (x = o)), T = Hr(0, 1, A) * f
        }
        const O = v ? {
            done: !1,
            value: u[0]
        } : x.next(T);
        a && (O.value = a(O.value));
        let {
            done: U
        } = O;
        !v && c !== null && (U = this.speed >= 0 ? this.currentTime >= h : this.currentTime <= 0);
        const S = this.holdTime === null && (this.state === "finished" || this.state === "running" && U);
        return S && i !== void 0 && (O.value = dh(u, this.options, i)), k && k(O.value), S && this.finish(), O
    }
    get duration() {
        const {
            resolved: e
        } = this;
        return e ? qn(e.calculatedDuration) : 0
    }
    get time() {
        return qn(this.currentTime)
    }
    set time(e) {
        e = Wn(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(e) {
        const n = this.playbackSpeed !== e;
        this.playbackSpeed = e, n && (this.time = qn(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped) return;
        const {
            driver: e = IU,
            onPlay: n,
            startTime: r
        } = this.options;
        this.driver || (this.driver = e(s => this.tick(s))), n && n();
        const i = this.driver.now();
        this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = r ? ? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start()
    }
    pause() {
        var e;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0
    }
    complete() {
        this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null
    }
    finish() {
        this.teardown(), this.state = "finished";
        const {
            onComplete: e
        } = this.options;
        e && e()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(), this.driver = void 0)
    }
    sample(e) {
        return this.startTime = 0, this.tick(e, !0)
    }
}
const PU = new Set(["opacity", "clipPath", "filter", "transform"]),
    RU = 10,
    CU = (t, e) => {
        let n = "";
        const r = Math.max(Math.round(e / RU), 2);
        for (let i = 0; i < r; i++) n += t(zs(0, r - 1, i)) + ", ";
        return `linear(${n.substring(0,n.length-2)})`
    };

function Og(t) {
    let e;
    return () => (e === void 0 && (e = t()), e)
}
const kU = {
    linearEasing: void 0
};

function xU(t, e) {
    const n = Og(t);
    return () => {
        var r;
        return (r = kU[e]) !== null && r !== void 0 ? r : n()
    }
}
const pc = xU(() => {
    try {
        document.createElement("div").animate({
            opacity: 0
        }, {
            easing: "linear(0, 1)"
        })
    } catch {
        return !1
    }
    return !0
}, "linearEasing");

function QA(t) {
    return !!(typeof t == "function" && pc() || !t || typeof t == "string" && (t in mp || pc()) || Ng(t) || Array.isArray(t) && t.every(QA))
}
const Mo = ([t, e, n, r]) => `cubic-bezier(${t}, ${e}, ${n}, ${r})`,
    mp = {
        linear: "linear",
        ease: "ease",
        easeIn: "ease-in",
        easeOut: "ease-out",
        easeInOut: "ease-in-out",
        circIn: Mo([0, .65, .55, 1]),
        circOut: Mo([.55, 0, 1, .45]),
        backIn: Mo([.31, .01, .66, -.59]),
        backOut: Mo([.33, 1.53, .69, .99])
    };

function YA(t, e) {
    if (t) return typeof t == "function" && pc() ? CU(t, e) : Ng(t) ? Mo(t) : Array.isArray(t) ? t.map(n => YA(n, e) || mp.easeOut) : mp[t]
}

function bU(t, e, n, {
    delay: r = 0,
    duration: i = 300,
    repeat: s = 0,
    repeatType: o = "loop",
    ease: a = "easeInOut",
    times: u
} = {}) {
    const c = {
        [e]: n
    };
    u && (c.offset = u);
    const h = YA(a, i);
    return Array.isArray(h) && (c.easing = h), t.animate(c, {
        delay: r,
        duration: i,
        easing: Array.isArray(h) ? "linear" : h,
        fill: "both",
        iterations: s + 1,
        direction: o === "reverse" ? "alternate" : "normal"
    })
}

function nw(t, e) {
    t.timeline = e, t.onfinish = null
}
const NU = Og(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
    mc = 10,
    DU = 2e4;

function VU(t) {
    return bg(t.type) || t.type === "spring" || !QA(t.ease)
}

function OU(t, e) {
    const n = new Vg({ ...e,
        keyframes: t,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    });
    let r = {
        done: !1,
        value: t[0]
    };
    const i = [];
    let s = 0;
    for (; !r.done && s < DU;) r = n.sample(s), i.push(r.value), s += mc;
    return {
        times: void 0,
        keyframes: i,
        duration: s - mc,
        ease: "linear"
    }
}
const XA = {
    anticipate: IA,
    backInOut: EA,
    circInOut: AA
};

function LU(t) {
    return t in XA
}
class rw extends $A {
    constructor(e) {
        super(e);
        const {
            name: n,
            motionValue: r,
            element: i,
            keyframes: s
        } = this.options;
        this.resolver = new BA(s, (o, a) => this.onKeyframesResolved(o, a), n, r, i), this.resolver.scheduleResolve()
    }
    initPlayback(e, n) {
        var r;
        let {
            duration: i = 300,
            times: s,
            ease: o,
            type: a,
            motionValue: u,
            name: c,
            startTime: h
        } = this.options;
        if (!(!((r = u.owner) === null || r === void 0) && r.current)) return !1;
        if (typeof o == "string" && pc() && LU(o) && (o = XA[o]), VU(this.options)) {
            const {
                onComplete: m,
                onUpdate: _,
                motionValue: I,
                element: R,
                ...k
            } = this.options, w = OU(e, k);
            e = w.keyframes, e.length === 1 && (e[1] = e[0]), i = w.duration, s = w.times, o = w.ease, a = "keyframes"
        }
        const f = bU(u.owner.current, c, e, { ...this.options,
            duration: i,
            times: s,
            ease: o
        });
        return f.startTime = h ? ? this.calcStartTime(), this.pendingTimeline ? (nw(f, this.pendingTimeline), this.pendingTimeline = void 0) : f.onfinish = () => {
            const {
                onComplete: m
            } = this.options;
            u.set(dh(e, this.options, n)), m && m(), this.cancel(), this.resolveFinishedPromise()
        }, {
            animation: f,
            duration: i,
            times: s,
            type: a,
            ease: o,
            keyframes: e
        }
    }
    get duration() {
        const {
            resolved: e
        } = this;
        if (!e) return 0;
        const {
            duration: n
        } = e;
        return qn(n)
    }
    get time() {
        const {
            resolved: e
        } = this;
        if (!e) return 0;
        const {
            animation: n
        } = e;
        return qn(n.currentTime || 0)
    }
    set time(e) {
        const {
            resolved: n
        } = this;
        if (!n) return;
        const {
            animation: r
        } = n;
        r.currentTime = Wn(e)
    }
    get speed() {
        const {
            resolved: e
        } = this;
        if (!e) return 1;
        const {
            animation: n
        } = e;
        return n.playbackRate
    }
    set speed(e) {
        const {
            resolved: n
        } = this;
        if (!n) return;
        const {
            animation: r
        } = n;
        r.playbackRate = e
    }
    get state() {
        const {
            resolved: e
        } = this;
        if (!e) return "idle";
        const {
            animation: n
        } = e;
        return n.playState
    }
    get startTime() {
        const {
            resolved: e
        } = this;
        if (!e) return null;
        const {
            animation: n
        } = e;
        return n.startTime
    }
    attachTimeline(e) {
        if (!this._resolved) this.pendingTimeline = e;
        else {
            const {
                resolved: n
            } = this;
            if (!n) return ht;
            const {
                animation: r
            } = n;
            nw(r, e)
        }
        return ht
    }
    play() {
        if (this.isStopped) return;
        const {
            resolved: e
        } = this;
        if (!e) return;
        const {
            animation: n
        } = e;
        n.playState === "finished" && this.updateFinishedPromise(), n.play()
    }
    pause() {
        const {
            resolved: e
        } = this;
        if (!e) return;
        const {
            animation: n
        } = e;
        n.pause()
    }
    stop() {
        if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return;
        this.resolveFinishedPromise(), this.updateFinishedPromise();
        const {
            resolved: e
        } = this;
        if (!e) return;
        const {
            animation: n,
            keyframes: r,
            duration: i,
            type: s,
            ease: o,
            times: a
        } = e;
        if (n.playState === "idle" || n.playState === "finished") return;
        if (this.time) {
            const {
                motionValue: c,
                onUpdate: h,
                onComplete: f,
                element: m,
                ..._
            } = this.options, I = new Vg({ ..._,
                keyframes: r,
                duration: i,
                type: s,
                ease: o,
                times: a,
                isGenerator: !0
            }), R = Wn(this.time);
            c.setWithVelocity(I.sample(R - mc).value, I.sample(R).value, mc)
        }
        const {
            onStop: u
        } = this.options;
        u && u(), this.cancel()
    }
    complete() {
        const {
            resolved: e
        } = this;
        e && e.animation.finish()
    }
    cancel() {
        const {
            resolved: e
        } = this;
        e && e.animation.cancel()
    }
    static supports(e) {
        const {
            motionValue: n,
            name: r,
            repeatDelay: i,
            repeatType: s,
            damping: o,
            type: a
        } = e;
        return NU() && r && PU.has(r) && n && n.owner && n.owner.current instanceof HTMLElement && !n.owner.getProps().onUpdate && !i && s !== "mirror" && o !== 0 && a !== "inertia"
    }
}
const MU = Og(() => window.ScrollTimeline !== void 0);
class FU {
    constructor(e) {
        this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean)
    }
    then(e, n) {
        return Promise.all(this.animations).then(e).catch(n)
    }
    getAll(e) {
        return this.animations[0][e]
    }
    setAll(e, n) {
        for (let r = 0; r < this.animations.length; r++) this.animations[r][e] = n
    }
    attachTimeline(e, n) {
        const r = this.animations.map(i => MU() && i.attachTimeline ? i.attachTimeline(e) : n(i));
        return () => {
            r.forEach((i, s) => {
                i && i(), this.animations[s].stop()
            })
        }
    }
    get time() {
        return this.getAll("time")
    }
    set time(e) {
        this.setAll("time", e)
    }
    get speed() {
        return this.getAll("speed")
    }
    set speed(e) {
        this.setAll("speed", e)
    }
    get startTime() {
        return this.getAll("startTime")
    }
    get duration() {
        let e = 0;
        for (let n = 0; n < this.animations.length; n++) e = Math.max(e, this.animations[n].duration);
        return e
    }
    runAll(e) {
        this.animations.forEach(n => n[e]())
    }
    flatten() {
        this.runAll("flatten")
    }
    play() {
        this.runAll("play")
    }
    pause() {
        this.runAll("pause")
    }
    cancel() {
        this.runAll("cancel")
    }
    complete() {
        this.runAll("complete")
    }
}

function UU({
    when: t,
    delay: e,
    delayChildren: n,
    staggerChildren: r,
    staggerDirection: i,
    repeat: s,
    repeatType: o,
    repeatDelay: a,
    from: u,
    elapsed: c,
    ...h
}) {
    return !!Object.keys(h).length
}
const Lg = (t, e, n, r = {}, i, s) => o => {
        const a = Eg(r, t) || {},
            u = a.delay || r.delay || 0;
        let {
            elapsed: c = 0
        } = r;
        c = c - Wn(u);
        let h = {
            keyframes: Array.isArray(n) ? n : [null, n],
            ease: "easeOut",
            velocity: e.getVelocity(),
            ...a,
            delay: -c,
            onUpdate: m => {
                e.set(m), a.onUpdate && a.onUpdate(m)
            },
            onComplete: () => {
                o(), a.onComplete && a.onComplete()
            },
            name: t,
            motionValue: e,
            element: s ? void 0 : i
        };
        UU(a) || (h = { ...h,
            ...rF(t, h)
        }), h.duration && (h.duration = Wn(h.duration)), h.repeatDelay && (h.repeatDelay = Wn(h.repeatDelay)), h.from !== void 0 && (h.keyframes[0] = h.from);
        let f = !1;
        if ((h.type === !1 || h.duration === 0 && !h.repeatDelay) && (h.duration = 0, h.delay === 0 && (f = !0)), f && !s && e.get() !== void 0) {
            const m = dh(h.keyframes, a);
            if (m !== void 0) return he.update(() => {
                h.onUpdate(m), h.onComplete()
            }), new FU([])
        }
        return !s && rw.supports(h) ? new rw(h) : new Vg(h)
    },
    jU = t => !!(t && typeof t == "object" && t.mix && t.toValue),
    BU = t => ap(t) ? t[t.length - 1] || 0 : t;

function Mg(t, e) {
    t.indexOf(e) === -1 && t.push(e)
}

function Fg(t, e) {
    const n = t.indexOf(e);
    n > -1 && t.splice(n, 1)
}
class Ug {
    constructor() {
        this.subscriptions = []
    }
    add(e) {
        return Mg(this.subscriptions, e), () => Fg(this.subscriptions, e)
    }
    notify(e, n, r) {
        const i = this.subscriptions.length;
        if (i)
            if (i === 1) this.subscriptions[0](e, n, r);
            else
                for (let s = 0; s < i; s++) {
                    const o = this.subscriptions[s];
                    o && o(e, n, r)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const iw = 30,
    $U = t => !isNaN(parseFloat(t));
class zU {
    constructor(e, n = {}) {
        this.version = "11.11.17", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, i = !0) => {
            const s = An.now();
            this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }, this.hasAnimated = !1, this.setCurrent(e), this.owner = n.owner
    }
    setCurrent(e) {
        this.current = e, this.updatedAt = An.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = $U(this.current))
    }
    setPrevFrameValue(e = this.current) {
        this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt
    }
    onChange(e) {
        return this.on("change", e)
    }
    on(e, n) {
        this.events[e] || (this.events[e] = new Ug);
        const r = this.events[e].add(n);
        return e === "change" ? () => {
            r(), he.read(() => {
                this.events.change.getSize() || this.stop()
            })
        } : r
    }
    clearListeners() {
        for (const e in this.events) this.events[e].clear()
    }
    attach(e, n) {
        this.passiveEffect = e, this.stopPassiveEffect = n
    }
    set(e, n = !0) {
        !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify)
    }
    setWithVelocity(e, n, r) {
        this.set(n), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - r
    }
    jump(e, n = !0) {
        this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const e = An.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > iw) return 0;
        const n = Math.min(this.updatedAt - this.prevUpdatedAt, iw);
        return zA(parseFloat(this.current) - parseFloat(this.prevFrameValue), n)
    }
    start(e) {
        return this.stop(), new Promise(n => {
            this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify()
        }).then(() => {
            this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
        })
    }
    stop() {
        this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
}

function La(t, e) {
    return new zU(t, e)
}

function WU(t, e, n) {
    t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, La(n))
}

function jg(t, e) {
    const n = hh(t, e);
    let {
        transitionEnd: r = {},
        transition: i = {},
        ...s
    } = n || {};
    s = { ...s,
        ...r
    };
    for (const o in s) {
        const a = BU(s[o]);
        WU(t, o, a)
    }
}
const Bg = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
    qU = "framerAppearId",
    JA = "data-" + Bg(qU);

function ZA(t) {
    return t.props[JA]
}
const ut = t => !!(t && t.getVelocity);

function HU(t) {
    return !!(ut(t) && t.add)
}

function gp(t, e) {
    const n = t.getValue("willChange");
    if (HU(n)) return n.add(e)
}

function KU({
    protectedKeys: t,
    needsAnimating: e
}, n) {
    const r = t.hasOwnProperty(n) && e[n] !== !0;
    return e[n] = !1, r
}

function eP(t, e, {
    delay: n = 0,
    transitionOverride: r,
    type: i
} = {}) {
    var s;
    let {
        transition: o = t.getDefaultTransition(),
        transitionEnd: a,
        ...u
    } = e;
    r && (o = r);
    const c = [],
        h = i && t.animationState && t.animationState.getState()[i];
    for (const f in u) {
        const m = t.getValue(f, (s = t.latestValues[f]) !== null && s !== void 0 ? s : null),
            _ = u[f];
        if (_ === void 0 || h && KU(h, f)) continue;
        const I = {
            delay: n,
            ...Eg(o || {}, f)
        };
        let R = !1;
        if (window.MotionHandoffAnimation) {
            const w = ZA(t);
            if (w) {
                const v = window.MotionHandoffAnimation(w, f, he);
                v !== null && (I.startTime = v, R = !0)
            }
        }
        gp(t, f), m.start(Lg(f, m, _, t.shouldReduceMotion && Ui.has(f) ? {
            type: !1
        } : I, t, R));
        const k = m.animation;
        k && c.push(k)
    }
    return a && Promise.all(c).then(() => {
        he.update(() => {
            a && jg(t, a)
        })
    }), c
}

function yp(t, e, n = {}) {
    var r;
    const i = hh(t, e, n.type === "exit" ? (r = t.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0);
    let {
        transition: s = t.getDefaultTransition() || {}
    } = i || {};
    n.transitionOverride && (s = n.transitionOverride);
    const o = i ? () => Promise.all(eP(t, i, n)) : () => Promise.resolve(),
        a = t.variantChildren && t.variantChildren.size ? (c = 0) => {
            const {
                delayChildren: h = 0,
                staggerChildren: f,
                staggerDirection: m
            } = s;
            return GU(t, e, h + c, f, m, n)
        } : () => Promise.resolve(),
        {
            when: u
        } = s;
    if (u) {
        const [c, h] = u === "beforeChildren" ? [o, a] : [a, o];
        return c().then(() => h())
    } else return Promise.all([o(), a(n.delay)])
}

function GU(t, e, n = 0, r = 0, i = 1, s) {
    const o = [],
        a = (t.variantChildren.size - 1) * r,
        u = i === 1 ? (c = 0) => c * r : (c = 0) => a - c * r;
    return Array.from(t.variantChildren).sort(QU).forEach((c, h) => {
        c.notify("AnimationStart", e), o.push(yp(c, e, { ...s,
            delay: n + u(h)
        }).then(() => c.notify("AnimationComplete", e)))
    }), Promise.all(o)
}

function QU(t, e) {
    return t.sortNodePosition(e)
}

function tP(t, e, n = {}) {
    t.notify("AnimationStart", e);
    let r;
    if (Array.isArray(e)) {
        const i = e.map(s => yp(t, s, n));
        r = Promise.all(i)
    } else if (typeof e == "string") r = yp(t, e, n);
    else {
        const i = typeof e == "function" ? hh(t, e, n.custom) : e;
        r = Promise.all(eP(t, i, n))
    }
    return r.then(() => {
        t.notify("AnimationComplete", e)
    })
}
const YU = Tg.length;

function nP(t) {
    if (!t) return;
    if (!t.isControllingVariants) {
        const n = t.parent ? nP(t.parent) || {} : {};
        return t.props.initial !== void 0 && (n.initial = t.props.initial), n
    }
    const e = {};
    for (let n = 0; n < YU; n++) {
        const r = Tg[n],
            i = t.props[r];
        (Da(i) || i === !1) && (e[r] = i)
    }
    return e
}
const XU = [...wg].reverse(),
    JU = wg.length;

function ZU(t) {
    return e => Promise.all(e.map(({
        animation: n,
        options: r
    }) => tP(t, n, r)))
}

function e4(t) {
    let e = ZU(t),
        n = sw(),
        r = !0;
    const i = u => (c, h) => {
        var f;
        const m = hh(t, h, u === "exit" ? (f = t.presenceContext) === null || f === void 0 ? void 0 : f.custom : void 0);
        if (m) {
            const {
                transition: _,
                transitionEnd: I,
                ...R
            } = m;
            c = { ...c,
                ...R,
                ...I
            }
        }
        return c
    };

    function s(u) {
        e = u(t)
    }

    function o(u) {
        const {
            props: c
        } = t, h = nP(t.parent) || {}, f = [], m = new Set;
        let _ = {},
            I = 1 / 0;
        for (let k = 0; k < JU; k++) {
            const w = XU[k],
                v = n[w],
                T = c[w] !== void 0 ? c[w] : h[w],
                x = Da(T),
                O = w === u ? v.isActive : null;
            O === !1 && (I = k);
            let U = T === h[w] && T !== c[w] && x;
            if (U && r && t.manuallyAnimateOnMount && (U = !1), v.protectedKeys = { ..._
                }, !v.isActive && O === null || !T && !v.prevProp || ch(T) || typeof T == "boolean") continue;
            const S = t4(v.prevProp, T);
            let g = S || w === u && v.isActive && !U && x || k > I && x,
                E = !1;
            const A = Array.isArray(T) ? T : [T];
            let C = A.reduce(i(w), {});
            O === !1 && (C = {});
            const {
                prevResolvedValues: b = {}
            } = v, P = { ...b,
                ...C
            }, ze = le => {
                g = !0, m.has(le) && (E = !0, m.delete(le)), v.needsAnimating[le] = !0;
                const B = t.getValue(le);
                B && (B.liveStyle = !1)
            };
            for (const le in P) {
                const B = C[le],
                    K = b[le];
                if (_.hasOwnProperty(le)) continue;
                let Q = !1;
                ap(B) && ap(K) ? Q = !gA(B, K) : Q = B !== K, Q ? B != null ? ze(le) : m.add(le) : B !== void 0 && m.has(le) ? ze(le) : v.protectedKeys[le] = !0
            }
            v.prevProp = T, v.prevResolvedValues = C, v.isActive && (_ = { ..._,
                ...C
            }), r && t.blockInitialAnimation && (g = !1), g && (!(U && S) || E) && f.push(...A.map(le => ({
                animation: le,
                options: {
                    type: w
                }
            })))
        }
        if (m.size) {
            const k = {};
            m.forEach(w => {
                const v = t.getBaseTarget(w),
                    T = t.getValue(w);
                T && (T.liveStyle = !0), k[w] = v ? ? null
            }), f.push({
                animation: k
            })
        }
        let R = !!f.length;
        return r && (c.initial === !1 || c.initial === c.animate) && !t.manuallyAnimateOnMount && (R = !1), r = !1, R ? e(f) : Promise.resolve()
    }

    function a(u, c) {
        var h;
        if (n[u].isActive === c) return Promise.resolve();
        (h = t.variantChildren) === null || h === void 0 || h.forEach(m => {
            var _;
            return (_ = m.animationState) === null || _ === void 0 ? void 0 : _.setActive(u, c)
        }), n[u].isActive = c;
        const f = o(u);
        for (const m in n) n[m].protectedKeys = {};
        return f
    }
    return {
        animateChanges: o,
        setActive: a,
        setAnimateFunction: s,
        getState: () => n,
        reset: () => {
            n = sw(), r = !0
        }
    }
}

function t4(t, e) {
    return typeof e == "string" ? e !== t : Array.isArray(e) ? !gA(e, t) : !1
}

function li(t = !1) {
    return {
        isActive: t,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}

function sw() {
    return {
        animate: li(!0),
        whileInView: li(),
        whileHover: li(),
        whileTap: li(),
        whileDrag: li(),
        whileFocus: li(),
        exit: li()
    }
}
class ti {
    constructor(e) {
        this.isMounted = !1, this.node = e
    }
    update() {}
}
class n4 extends ti {
    constructor(e) {
        super(e), e.animationState || (e.animationState = e4(e))
    }
    updateAnimationControlsSubscription() {
        const {
            animate: e
        } = this.node.getProps();
        ch(e) && (this.unmountControls = e.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {
            animate: e
        } = this.node.getProps(), {
            animate: n
        } = this.node.prevProps || {};
        e !== n && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var e;
        this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this)
    }
}
let r4 = 0;
class i4 extends ti {
    constructor() {
        super(...arguments), this.id = r4++
    }
    update() {
        if (!this.node.presenceContext) return;
        const {
            isPresent: e,
            onExitComplete: n
        } = this.node.presenceContext, {
            isPresent: r
        } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === r) return;
        const i = this.node.animationState.setActive("exit", !e);
        n && !e && i.then(() => n(this.id))
    }
    mount() {
        const {
            register: e
        } = this.node.presenceContext || {};
        e && (this.unmount = e(this.id))
    }
    unmount() {}
}
const s4 = {
        animation: {
            Feature: n4
        },
        exit: {
            Feature: i4
        }
    },
    rP = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;

function fh(t, e = "page") {
    return {
        point: {
            x: t[`${e}X`],
            y: t[`${e}Y`]
        }
    }
}
const o4 = t => e => rP(e) && t(e, fh(e));

function jn(t, e, n, r = {
    passive: !0
}) {
    return t.addEventListener(e, n, r), () => t.removeEventListener(e, n)
}

function Kn(t, e, n, r) {
    return jn(t, e, o4(n), r)
}
const ow = (t, e) => Math.abs(t - e);

function a4(t, e) {
    const n = ow(t.x, e.x),
        r = ow(t.y, e.y);
    return Math.sqrt(n ** 2 + r ** 2)
}
class iP {
    constructor(e, n, {
        transformPagePoint: r,
        contextWindow: i,
        dragSnapToOrigin: s = !1
    } = {}) {
        if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
                if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                const f = Dd(this.lastMoveEventInfo, this.history),
                    m = this.startEvent !== null,
                    _ = a4(f.offset, {
                        x: 0,
                        y: 0
                    }) >= 3;
                if (!m && !_) return;
                const {
                    point: I
                } = f, {
                    timestamp: R
                } = He;
                this.history.push({ ...I,
                    timestamp: R
                });
                const {
                    onStart: k,
                    onMove: w
                } = this.handlers;
                m || (k && k(this.lastMoveEvent, f), this.startEvent = this.lastMoveEvent), w && w(this.lastMoveEvent, f)
            }, this.handlePointerMove = (f, m) => {
                this.lastMoveEvent = f, this.lastMoveEventInfo = Nd(m, this.transformPagePoint), he.update(this.updatePoint, !0)
            }, this.handlePointerUp = (f, m) => {
                this.end();
                const {
                    onEnd: _,
                    onSessionEnd: I,
                    resumeAnimation: R
                } = this.handlers;
                if (this.dragSnapToOrigin && R && R(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                const k = Dd(f.type === "pointercancel" ? this.lastMoveEventInfo : Nd(m, this.transformPagePoint), this.history);
                this.startEvent && _ && _(f, k), I && I(f, k)
            }, !rP(e)) return;
        this.dragSnapToOrigin = s, this.handlers = n, this.transformPagePoint = r, this.contextWindow = i || window;
        const o = fh(e),
            a = Nd(o, this.transformPagePoint),
            {
                point: u
            } = a,
            {
                timestamp: c
            } = He;
        this.history = [{ ...u,
            timestamp: c
        }];
        const {
            onSessionStart: h
        } = n;
        h && h(e, Dd(a, this.history)), this.removeListeners = Hn(Kn(this.contextWindow, "pointermove", this.handlePointerMove), Kn(this.contextWindow, "pointerup", this.handlePointerUp), Kn(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(e) {
        this.handlers = e
    }
    end() {
        this.removeListeners && this.removeListeners(), qr(this.updatePoint)
    }
}

function Nd(t, e) {
    return e ? {
        point: e(t.point)
    } : t
}

function aw(t, e) {
    return {
        x: t.x - e.x,
        y: t.y - e.y
    }
}

function Dd({
    point: t
}, e) {
    return {
        point: t,
        delta: aw(t, sP(e)),
        offset: aw(t, l4(e)),
        velocity: u4(e, .1)
    }
}

function l4(t) {
    return t[0]
}

function sP(t) {
    return t[t.length - 1]
}

function u4(t, e) {
    if (t.length < 2) return {
        x: 0,
        y: 0
    };
    let n = t.length - 1,
        r = null;
    const i = sP(t);
    for (; n >= 0 && (r = t[n], !(i.timestamp - r.timestamp > Wn(e)));) n--;
    if (!r) return {
        x: 0,
        y: 0
    };
    const s = qn(i.timestamp - r.timestamp);
    if (s === 0) return {
        x: 0,
        y: 0
    };
    const o = {
        x: (i.x - r.x) / s,
        y: (i.y - r.y) / s
    };
    return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o
}

function oP(t) {
    let e = null;
    return () => {
        const n = () => {
            e = null
        };
        return e === null ? (e = t, n) : !1
    }
}
const lw = oP("dragHorizontal"),
    uw = oP("dragVertical");

function aP(t) {
    let e = !1;
    if (t === "y") e = uw();
    else if (t === "x") e = lw();
    else {
        const n = lw(),
            r = uw();
        n && r ? e = () => {
            n(), r()
        } : (n && n(), r && r())
    }
    return e
}

function lP() {
    const t = aP(!0);
    return t ? (t(), !1) : !0
}

function fs(t) {
    return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current")
}
const uP = 1e-4,
    c4 = 1 - uP,
    h4 = 1 + uP,
    cP = .01,
    d4 = 0 - cP,
    f4 = 0 + cP;

function Bt(t) {
    return t.max - t.min
}

function p4(t, e, n) {
    return Math.abs(t - e) <= n
}

function cw(t, e, n, r = .5) {
    t.origin = r, t.originPoint = Ee(e.min, e.max, t.origin), t.scale = Bt(n) / Bt(e), t.translate = Ee(n.min, n.max, t.origin) - t.originPoint, (t.scale >= c4 && t.scale <= h4 || isNaN(t.scale)) && (t.scale = 1), (t.translate >= d4 && t.translate <= f4 || isNaN(t.translate)) && (t.translate = 0)
}

function na(t, e, n, r) {
    cw(t.x, e.x, n.x, r ? r.originX : void 0), cw(t.y, e.y, n.y, r ? r.originY : void 0)
}

function hw(t, e, n) {
    t.min = n.min + e.min, t.max = t.min + Bt(e)
}

function m4(t, e, n) {
    hw(t.x, e.x, n.x), hw(t.y, e.y, n.y)
}

function dw(t, e, n) {
    t.min = e.min - n.min, t.max = t.min + Bt(e)
}

function ra(t, e, n) {
    dw(t.x, e.x, n.x), dw(t.y, e.y, n.y)
}

function g4(t, {
    min: e,
    max: n
}, r) {
    return e !== void 0 && t < e ? t = r ? Ee(e, t, r.min) : Math.max(t, e) : n !== void 0 && t > n && (t = r ? Ee(n, t, r.max) : Math.min(t, n)), t
}

function fw(t, e, n) {
    return {
        min: e !== void 0 ? t.min + e : void 0,
        max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
    }
}

function y4(t, {
    top: e,
    left: n,
    bottom: r,
    right: i
}) {
    return {
        x: fw(t.x, n, i),
        y: fw(t.y, e, r)
    }
}

function pw(t, e) {
    let n = e.min - t.min,
        r = e.max - t.max;
    return e.max - e.min < t.max - t.min && ([n, r] = [r, n]), {
        min: n,
        max: r
    }
}

function v4(t, e) {
    return {
        x: pw(t.x, e.x),
        y: pw(t.y, e.y)
    }
}

function _4(t, e) {
    let n = .5;
    const r = Bt(t),
        i = Bt(e);
    return i > r ? n = zs(e.min, e.max - r, t.min) : r > i && (n = zs(t.min, t.max - i, e.min)), Hr(0, 1, n)
}

function w4(t, e) {
    const n = {};
    return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n
}
const vp = .35;

function T4(t = vp) {
    return t === !1 ? t = 0 : t === !0 && (t = vp), {
        x: mw(t, "left", "right"),
        y: mw(t, "top", "bottom")
    }
}

function mw(t, e, n) {
    return {
        min: gw(t, e),
        max: gw(t, n)
    }
}

function gw(t, e) {
    return typeof t == "number" ? t : t[e] || 0
}
const yw = () => ({
        translate: 0,
        scale: 1,
        origin: 0,
        originPoint: 0
    }),
    ps = () => ({
        x: yw(),
        y: yw()
    }),
    vw = () => ({
        min: 0,
        max: 0
    }),
    ke = () => ({
        x: vw(),
        y: vw()
    });

function Ht(t) {
    return [t("x"), t("y")]
}

function hP({
    top: t,
    left: e,
    right: n,
    bottom: r
}) {
    return {
        x: {
            min: e,
            max: n
        },
        y: {
            min: t,
            max: r
        }
    }
}

function E4({
    x: t,
    y: e
}) {
    return {
        top: e.min,
        right: t.max,
        bottom: e.max,
        left: t.min
    }
}

function I4(t, e) {
    if (!e) return t;
    const n = e({
            x: t.left,
            y: t.top
        }),
        r = e({
            x: t.right,
            y: t.bottom
        });
    return {
        top: n.y,
        left: n.x,
        bottom: r.y,
        right: r.x
    }
}

function Vd(t) {
    return t === void 0 || t === 1
}

function _p({
    scale: t,
    scaleX: e,
    scaleY: n
}) {
    return !Vd(t) || !Vd(e) || !Vd(n)
}

function di(t) {
    return _p(t) || dP(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY
}

function dP(t) {
    return _w(t.x) || _w(t.y)
}

function _w(t) {
    return t && t !== "0%"
}

function gc(t, e, n) {
    const r = t - n,
        i = e * r;
    return n + i
}

function ww(t, e, n, r, i) {
    return i !== void 0 && (t = gc(t, i, r)), gc(t, n, r) + e
}

function wp(t, e = 0, n = 1, r, i) {
    t.min = ww(t.min, e, n, r, i), t.max = ww(t.max, e, n, r, i)
}

function fP(t, {
    x: e,
    y: n
}) {
    wp(t.x, e.translate, e.scale, e.originPoint), wp(t.y, n.translate, n.scale, n.originPoint)
}
const Tw = .999999999999,
    Ew = 1.0000000000001;

function S4(t, e, n, r = !1) {
    const i = n.length;
    if (!i) return;
    e.x = e.y = 1;
    let s, o;
    for (let a = 0; a < i; a++) {
        s = n[a], o = s.projectionDelta;
        const {
            visualElement: u
        } = s.options;
        u && u.props.style && u.props.style.display === "contents" || (r && s.options.layoutScroll && s.scroll && s !== s.root && gs(t, {
            x: -s.scroll.offset.x,
            y: -s.scroll.offset.y
        }), o && (e.x *= o.x.scale, e.y *= o.y.scale, fP(t, o)), r && di(s.latestValues) && gs(t, s.latestValues))
    }
    e.x < Ew && e.x > Tw && (e.x = 1), e.y < Ew && e.y > Tw && (e.y = 1)
}

function ms(t, e) {
    t.min = t.min + e, t.max = t.max + e
}

function Iw(t, e, n, r, i = .5) {
    const s = Ee(t.min, t.max, i);
    wp(t, e, n, s, r)
}

function gs(t, e) {
    Iw(t.x, e.x, e.scaleX, e.scale, e.originX), Iw(t.y, e.y, e.scaleY, e.scale, e.originY)
}

function pP(t, e) {
    return hP(I4(t.getBoundingClientRect(), e))
}

function A4(t, e, n) {
    const r = pP(t, n),
        {
            scroll: i
        } = e;
    return i && (ms(r.x, i.offset.x), ms(r.y, i.offset.y)), r
}
const mP = ({
        current: t
    }) => t ? t.ownerDocument.defaultView : null,
    P4 = new WeakMap;
class R4 {
    constructor(e) {
        this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
            x: 0,
            y: 0
        }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ke(), this.visualElement = e
    }
    start(e, {
        snapToCursor: n = !1
    } = {}) {
        const {
            presenceContext: r
        } = this.visualElement;
        if (r && r.isPresent === !1) return;
        const i = h => {
                const {
                    dragSnapToOrigin: f
                } = this.getProps();
                f ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(fh(h, "page").point)
            },
            s = (h, f) => {
                const {
                    drag: m,
                    dragPropagation: _,
                    onDragStart: I
                } = this.getProps();
                if (m && !_ && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = aP(m), !this.openGlobalLock)) return;
                this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Ht(k => {
                    let w = this.getAxisMotionValue(k).get() || 0;
                    if (Sn.test(w)) {
                        const {
                            projection: v
                        } = this.visualElement;
                        if (v && v.layout) {
                            const T = v.layout.layoutBox[k];
                            T && (w = Bt(T) * (parseFloat(w) / 100))
                        }
                    }
                    this.originPoint[k] = w
                }), I && he.postRender(() => I(h, f)), gp(this.visualElement, "transform");
                const {
                    animationState: R
                } = this.visualElement;
                R && R.setActive("whileDrag", !0)
            },
            o = (h, f) => {
                const {
                    dragPropagation: m,
                    dragDirectionLock: _,
                    onDirectionLock: I,
                    onDrag: R
                } = this.getProps();
                if (!m && !this.openGlobalLock) return;
                const {
                    offset: k
                } = f;
                if (_ && this.currentDirection === null) {
                    this.currentDirection = C4(k), this.currentDirection !== null && I && I(this.currentDirection);
                    return
                }
                this.updateAxis("x", f.point, k), this.updateAxis("y", f.point, k), this.visualElement.render(), R && R(h, f)
            },
            a = (h, f) => this.stop(h, f),
            u = () => Ht(h => {
                var f;
                return this.getAnimationState(h) === "paused" && ((f = this.getAxisMotionValue(h).animation) === null || f === void 0 ? void 0 : f.play())
            }),
            {
                dragSnapToOrigin: c
            } = this.getProps();
        this.panSession = new iP(e, {
            onSessionStart: i,
            onStart: s,
            onMove: o,
            onSessionEnd: a,
            resumeAnimation: u
        }, {
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: c,
            contextWindow: mP(this.visualElement)
        })
    }
    stop(e, n) {
        const r = this.isDragging;
        if (this.cancel(), !r) return;
        const {
            velocity: i
        } = n;
        this.startAnimation(i);
        const {
            onDragEnd: s
        } = this.getProps();
        s && he.postRender(() => s(e, n))
    }
    cancel() {
        this.isDragging = !1;
        const {
            projection: e,
            animationState: n
        } = this.visualElement;
        e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
        const {
            dragPropagation: r
        } = this.getProps();
        !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1)
    }
    updateAxis(e, n, r) {
        const {
            drag: i
        } = this.getProps();
        if (!r || !Kl(e, i, this.currentDirection)) return;
        const s = this.getAxisMotionValue(e);
        let o = this.originPoint[e] + r[e];
        this.constraints && this.constraints[e] && (o = g4(o, this.constraints[e], this.elastic[e])), s.set(o)
    }
    resolveConstraints() {
        var e;
        const {
            dragConstraints: n,
            dragElastic: r
        } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, s = this.constraints;
        n && fs(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && i ? this.constraints = y4(i.layoutBox, n) : this.constraints = !1, this.elastic = T4(r), s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Ht(o => {
            this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = w4(i.layoutBox[o], this.constraints[o]))
        })
    }
    resolveRefConstraints() {
        const {
            dragConstraints: e,
            onMeasureDragConstraints: n
        } = this.getProps();
        if (!e || !fs(e)) return !1;
        const r = e.current,
            {
                projection: i
            } = this.visualElement;
        if (!i || !i.layout) return !1;
        const s = A4(r, i.root, this.visualElement.getTransformPagePoint());
        let o = v4(i.layout.layoutBox, s);
        if (n) {
            const a = n(E4(o));
            this.hasMutatedConstraints = !!a, a && (o = hP(a))
        }
        return o
    }
    startAnimation(e) {
        const {
            drag: n,
            dragMomentum: r,
            dragElastic: i,
            dragTransition: s,
            dragSnapToOrigin: o,
            onDragTransitionEnd: a
        } = this.getProps(), u = this.constraints || {}, c = Ht(h => {
            if (!Kl(h, n, this.currentDirection)) return;
            let f = u && u[h] || {};
            o && (f = {
                min: 0,
                max: 0
            });
            const m = i ? 200 : 1e6,
                _ = i ? 40 : 1e7,
                I = {
                    type: "inertia",
                    velocity: r ? e[h] : 0,
                    bounceStiffness: m,
                    bounceDamping: _,
                    timeConstant: 750,
                    restDelta: 1,
                    restSpeed: 10,
                    ...s,
                    ...f
                };
            return this.startAxisValueAnimation(h, I)
        });
        return Promise.all(c).then(a)
    }
    startAxisValueAnimation(e, n) {
        const r = this.getAxisMotionValue(e);
        return gp(this.visualElement, e), r.start(Lg(e, r, 0, n, this.visualElement, !1))
    }
    stopAnimation() {
        Ht(e => this.getAxisMotionValue(e).stop())
    }
    pauseAnimation() {
        Ht(e => {
            var n;
            return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.pause()
        })
    }
    getAnimationState(e) {
        var n;
        return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.state
    }
    getAxisMotionValue(e) {
        const n = `_drag${e.toUpperCase()}`,
            r = this.visualElement.getProps(),
            i = r[n];
        return i || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0)
    }
    snapToCursor(e) {
        Ht(n => {
            const {
                drag: r
            } = this.getProps();
            if (!Kl(n, r, this.currentDirection)) return;
            const {
                projection: i
            } = this.visualElement, s = this.getAxisMotionValue(n);
            if (i && i.layout) {
                const {
                    min: o,
                    max: a
                } = i.layout.layoutBox[n];
                s.set(e[n] - Ee(o, a, .5))
            }
        })
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current) return;
        const {
            drag: e,
            dragConstraints: n
        } = this.getProps(), {
            projection: r
        } = this.visualElement;
        if (!fs(n) || !r || !this.constraints) return;
        this.stopAnimation();
        const i = {
            x: 0,
            y: 0
        };
        Ht(o => {
            const a = this.getAxisMotionValue(o);
            if (a && this.constraints !== !1) {
                const u = a.get();
                i[o] = _4({
                    min: u,
                    max: u
                }, this.constraints[o])
            }
        });
        const {
            transformTemplate: s
        } = this.visualElement.getProps();
        this.visualElement.current.style.transform = s ? s({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Ht(o => {
            if (!Kl(o, e, null)) return;
            const a = this.getAxisMotionValue(o),
                {
                    min: u,
                    max: c
                } = this.constraints[o];
            a.set(Ee(u, c, i[o]))
        })
    }
    addListeners() {
        if (!this.visualElement.current) return;
        P4.set(this.visualElement, this);
        const e = this.visualElement.current,
            n = Kn(e, "pointerdown", u => {
                const {
                    drag: c,
                    dragListener: h = !0
                } = this.getProps();
                c && h && this.start(u)
            }),
            r = () => {
                const {
                    dragConstraints: u
                } = this.getProps();
                fs(u) && u.current && (this.constraints = this.resolveRefConstraints())
            },
            {
                projection: i
            } = this.visualElement,
            s = i.addEventListener("measure", r);
        i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), he.read(r);
        const o = jn(window, "resize", () => this.scalePositionWithinConstraints()),
            a = i.addEventListener("didUpdate", ({
                delta: u,
                hasLayoutChanged: c
            }) => {
                this.isDragging && c && (Ht(h => {
                    const f = this.getAxisMotionValue(h);
                    f && (this.originPoint[h] += u[h].translate, f.set(f.get() + u[h].translate))
                }), this.visualElement.render())
            });
        return () => {
            o(), n(), s(), a && a()
        }
    }
    getProps() {
        const e = this.visualElement.getProps(),
            {
                drag: n = !1,
                dragDirectionLock: r = !1,
                dragPropagation: i = !1,
                dragConstraints: s = !1,
                dragElastic: o = vp,
                dragMomentum: a = !0
            } = e;
        return { ...e,
            drag: n,
            dragDirectionLock: r,
            dragPropagation: i,
            dragConstraints: s,
            dragElastic: o,
            dragMomentum: a
        }
    }
}

function Kl(t, e, n) {
    return (e === !0 || e === t) && (n === null || n === t)
}

function C4(t, e = 10) {
    let n = null;
    return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n
}
class k4 extends ti {
    constructor(e) {
        super(e), this.removeGroupControls = ht, this.removeListeners = ht, this.controls = new R4(e)
    }
    mount() {
        const {
            dragControls: e
        } = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || ht
    }
    unmount() {
        this.removeGroupControls(), this.removeListeners()
    }
}
const Sw = t => (e, n) => {
    t && he.postRender(() => t(e, n))
};
class x4 extends ti {
    constructor() {
        super(...arguments), this.removePointerDownListener = ht
    }
    onPointerDown(e) {
        this.session = new iP(e, this.createPanHandlers(), {
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: mP(this.node)
        })
    }
    createPanHandlers() {
        const {
            onPanSessionStart: e,
            onPanStart: n,
            onPan: r,
            onPanEnd: i
        } = this.node.getProps();
        return {
            onSessionStart: Sw(e),
            onStart: Sw(n),
            onMove: r,
            onEnd: (s, o) => {
                delete this.session, i && he.postRender(() => i(s, o))
            }
        }
    }
    mount() {
        this.removePointerDownListener = Kn(this.node.current, "pointerdown", e => this.onPointerDown(e))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(), this.session && this.session.end()
    }
}
const ph = M.createContext(null);

function b4() {
    const t = M.useContext(ph);
    if (t === null) return [!0, null];
    const {
        isPresent: e,
        onExitComplete: n,
        register: r
    } = t, i = M.useId();
    M.useEffect(() => r(i), []);
    const s = M.useCallback(() => n && n(i), [i, n]);
    return !e && n ? [!1, s] : [!0]
}
const $g = M.createContext({}),
    gP = M.createContext({}),
    vu = {
        hasAnimatedSinceResize: !0,
        hasEverUpdated: !1
    };

function Aw(t, e) {
    return e.max === e.min ? 0 : t / (e.max - e.min) * 100
}
const Co = {
        correct: (t, e) => {
            if (!e.target) return t;
            if (typeof t == "string")
                if (G.test(t)) t = parseFloat(t);
                else return t;
            const n = Aw(t, e.target.x),
                r = Aw(t, e.target.y);
            return `${n}% ${r}%`
        }
    },
    N4 = {
        correct: (t, {
            treeScale: e,
            projectionDelta: n
        }) => {
            const r = t,
                i = Kr.parse(t);
            if (i.length > 5) return r;
            const s = Kr.createTransformer(t),
                o = typeof i[0] != "number" ? 1 : 0,
                a = n.x.scale * e.x,
                u = n.y.scale * e.y;
            i[0 + o] /= a, i[1 + o] /= u;
            const c = Ee(a, u, .5);
            return typeof i[2 + o] == "number" && (i[2 + o] /= c), typeof i[3 + o] == "number" && (i[3 + o] /= c), s(i)
        }
    },
    yc = {};

function D4(t) {
    Object.assign(yc, t)
}
const {
    schedule: zg
} = yA(queueMicrotask, !1);
class V4 extends M.Component {
    componentDidMount() {
        const {
            visualElement: e,
            layoutGroup: n,
            switchLayoutGroup: r,
            layoutId: i
        } = this.props, {
            projection: s
        } = e;
        D4(O4), s && (n.group && n.group.add(s), r && r.register && i && r.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }), s.setOptions({ ...s.options,
            onExitComplete: () => this.safeToRemove()
        })), vu.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(e) {
        const {
            layoutDependency: n,
            visualElement: r,
            drag: i,
            isPresent: s
        } = this.props, o = r.projection;
        return o && (o.isPresent = s, i || e.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? o.promote() : o.relegate() || he.postRender(() => {
            const a = o.getStack();
            (!a || !a.members.length) && this.safeToRemove()
        }))), null
    }
    componentDidUpdate() {
        const {
            projection: e
        } = this.props.visualElement;
        e && (e.root.didUpdate(), zg.postRender(() => {
            !e.currentAnimation && e.isLead() && this.safeToRemove()
        }))
    }
    componentWillUnmount() {
        const {
            visualElement: e,
            layoutGroup: n,
            switchLayoutGroup: r
        } = this.props, {
            projection: i
        } = e;
        i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i))
    }
    safeToRemove() {
        const {
            safeToRemove: e
        } = this.props;
        e && e()
    }
    render() {
        return null
    }
}

function yP(t) {
    const [e, n] = b4(), r = M.useContext($g);
    return D.jsx(V4, { ...t,
        layoutGroup: r,
        switchLayoutGroup: M.useContext(gP),
        isPresent: e,
        safeToRemove: n
    })
}
const O4 = {
        borderRadius: { ...Co,
            applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
        },
        borderTopLeftRadius: Co,
        borderTopRightRadius: Co,
        borderBottomLeftRadius: Co,
        borderBottomRightRadius: Co,
        boxShadow: N4
    },
    vP = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
    L4 = vP.length,
    Pw = t => typeof t == "string" ? parseFloat(t) : t,
    Rw = t => typeof t == "number" || G.test(t);

function M4(t, e, n, r, i, s) {
    i ? (t.opacity = Ee(0, n.opacity !== void 0 ? n.opacity : 1, F4(r)), t.opacityExit = Ee(e.opacity !== void 0 ? e.opacity : 1, 0, U4(r))) : s && (t.opacity = Ee(e.opacity !== void 0 ? e.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
    for (let o = 0; o < L4; o++) {
        const a = `border${vP[o]}Radius`;
        let u = Cw(e, a),
            c = Cw(n, a);
        if (u === void 0 && c === void 0) continue;
        u || (u = 0), c || (c = 0), u === 0 || c === 0 || Rw(u) === Rw(c) ? (t[a] = Math.max(Ee(Pw(u), Pw(c), r), 0), (Sn.test(c) || Sn.test(u)) && (t[a] += "%")) : t[a] = c
    }(e.rotate || n.rotate) && (t.rotate = Ee(e.rotate || 0, n.rotate || 0, r))
}

function Cw(t, e) {
    return t[e] !== void 0 ? t[e] : t.borderRadius
}
const F4 = _P(0, .5, SA),
    U4 = _P(.5, .95, ht);

function _P(t, e, n) {
    return r => r < t ? 0 : r > e ? 1 : n(zs(t, e, r))
}

function kw(t, e) {
    t.min = e.min, t.max = e.max
}

function qt(t, e) {
    kw(t.x, e.x), kw(t.y, e.y)
}

function xw(t, e) {
    t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin
}

function bw(t, e, n, r, i) {
    return t -= e, t = gc(t, 1 / n, r), i !== void 0 && (t = gc(t, 1 / i, r)), t
}

function j4(t, e = 0, n = 1, r = .5, i, s = t, o = t) {
    if (Sn.test(e) && (e = parseFloat(e), e = Ee(o.min, o.max, e / 100) - o.min), typeof e != "number") return;
    let a = Ee(s.min, s.max, r);
    t === s && (a -= e), t.min = bw(t.min, e, n, a, i), t.max = bw(t.max, e, n, a, i)
}

function Nw(t, e, [n, r, i], s, o) {
    j4(t, e[n], e[r], e[i], e.scale, s, o)
}
const B4 = ["x", "scaleX", "originX"],
    $4 = ["y", "scaleY", "originY"];

function Dw(t, e, n, r) {
    Nw(t.x, e, B4, n ? n.x : void 0, r ? r.x : void 0), Nw(t.y, e, $4, n ? n.y : void 0, r ? r.y : void 0)
}

function Vw(t) {
    return t.translate === 0 && t.scale === 1
}

function wP(t) {
    return Vw(t.x) && Vw(t.y)
}

function Ow(t, e) {
    return t.min === e.min && t.max === e.max
}

function z4(t, e) {
    return Ow(t.x, e.x) && Ow(t.y, e.y)
}

function Lw(t, e) {
    return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max)
}

function TP(t, e) {
    return Lw(t.x, e.x) && Lw(t.y, e.y)
}

function Mw(t) {
    return Bt(t.x) / Bt(t.y)
}

function Fw(t, e) {
    return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint
}
class W4 {
    constructor() {
        this.members = []
    }
    add(e) {
        Mg(this.members, e), e.scheduleRender()
    }
    remove(e) {
        if (Fg(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
            const n = this.members[this.members.length - 1];
            n && this.promote(n)
        }
    }
    relegate(e) {
        const n = this.members.findIndex(i => e === i);
        if (n === 0) return !1;
        let r;
        for (let i = n; i >= 0; i--) {
            const s = this.members[i];
            if (s.isPresent !== !1) {
                r = s;
                break
            }
        }
        return r ? (this.promote(r), !0) : !1
    }
    promote(e, n) {
        const r = this.lead;
        if (e !== r && (this.prevLead = r, this.lead = e, e.show(), r)) {
            r.instance && r.scheduleRender(), e.scheduleRender(), e.resumeFrom = r, n && (e.resumeFrom.preserveOpacity = !0), r.snapshot && (e.snapshot = r.snapshot, e.snapshot.latestValues = r.animationValues || r.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const {
                crossfade: i
            } = e.options;
            i === !1 && r.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(e => {
            const {
                options: n,
                resumingFrom: r
            } = e;
            n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete()
        })
    }
    scheduleRender() {
        this.members.forEach(e => {
            e.instance && e.scheduleRender(!1)
        })
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}

function q4(t, e, n) {
    let r = "";
    const i = t.x.translate / e.x,
        s = t.y.translate / e.y,
        o = (n == null ? void 0 : n.z) || 0;
    if ((i || s || o) && (r = `translate3d(${i}px, ${s}px, ${o}px) `), (e.x !== 1 || e.y !== 1) && (r += `scale(${1/e.x}, ${1/e.y}) `), n) {
        const {
            transformPerspective: c,
            rotate: h,
            rotateX: f,
            rotateY: m,
            skewX: _,
            skewY: I
        } = n;
        c && (r = `perspective(${c}px) ${r}`), h && (r += `rotate(${h}deg) `), f && (r += `rotateX(${f}deg) `), m && (r += `rotateY(${m}deg) `), _ && (r += `skewX(${_}deg) `), I && (r += `skewY(${I}deg) `)
    }
    const a = t.x.scale * e.x,
        u = t.y.scale * e.y;
    return (a !== 1 || u !== 1) && (r += `scale(${a}, ${u})`), r || "none"
}
const H4 = (t, e) => t.depth - e.depth;
class K4 {
    constructor() {
        this.children = [], this.isDirty = !1
    }
    add(e) {
        Mg(this.children, e), this.isDirty = !0
    }
    remove(e) {
        Fg(this.children, e), this.isDirty = !0
    }
    forEach(e) {
        this.isDirty && this.children.sort(H4), this.isDirty = !1, this.children.forEach(e)
    }
}

function _u(t) {
    const e = ut(t) ? t.get() : t;
    return jU(e) ? e.toValue() : e
}

function G4(t, e) {
    const n = An.now(),
        r = ({
            timestamp: i
        }) => {
            const s = i - n;
            s >= e && (qr(r), t(s - e))
        };
    return he.read(r, !0), () => qr(r)
}

function Q4(t) {
    return t instanceof SVGElement && t.tagName !== "svg"
}

function Y4(t, e, n) {
    const r = ut(t) ? t : La(t);
    return r.start(Lg("", r, e, n)), r.animation
}
const fi = {
        type: "projectionFrame",
        totalNodes: 0,
        resolvedTargetDeltas: 0,
        recalculatedProjection: 0
    },
    Fo = typeof window < "u" && window.MotionDebug !== void 0,
    Od = ["", "X", "Y", "Z"],
    X4 = {
        visibility: "hidden"
    },
    Uw = 1e3;
let J4 = 0;

function Ld(t, e, n, r) {
    const {
        latestValues: i
    } = e;
    i[t] && (n[t] = i[t], e.setStaticValue(t, 0), r && (r[t] = 0))
}

function EP(t) {
    if (t.hasCheckedOptimisedAppear = !0, t.root === t) return;
    const {
        visualElement: e
    } = t.options;
    if (!e) return;
    const n = ZA(e);
    if (window.MotionHasOptimisedAnimation(n, "transform")) {
        const {
            layout: i,
            layoutId: s
        } = t.options;
        window.MotionCancelOptimisedAnimation(n, "transform", he, !(i || s))
    }
    const {
        parent: r
    } = t;
    r && !r.hasCheckedOptimisedAppear && EP(r)
}

function IP({
    attachResizeListener: t,
    defaultParent: e,
    measureScroll: n,
    checkIsScrollRoot: r,
    resetTransform: i
}) {
    return class {
        constructor(o = {}, a = e == null ? void 0 : e()) {
            this.id = J4++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = {
                x: 1,
                y: 1
            }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
            }, this.updateProjection = () => {
                this.projectionUpdateScheduled = !1, Fo && (fi.totalNodes = fi.resolvedTargetDeltas = fi.recalculatedProjection = 0), this.nodes.forEach(tj), this.nodes.forEach(oj), this.nodes.forEach(aj), this.nodes.forEach(nj), Fo && window.MotionDebug.record(fi)
            }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
            for (let u = 0; u < this.path.length; u++) this.path[u].shouldResetTransform = !0;
            this.root === this && (this.nodes = new K4)
        }
        addEventListener(o, a) {
            return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Ug), this.eventHandlers.get(o).add(a)
        }
        notifyListeners(o, ...a) {
            const u = this.eventHandlers.get(o);
            u && u.notify(...a)
        }
        hasListeners(o) {
            return this.eventHandlers.has(o)
        }
        mount(o, a = this.root.hasTreeAnimated) {
            if (this.instance) return;
            this.isSVG = Q4(o), this.instance = o;
            const {
                layoutId: u,
                layout: c,
                visualElement: h
            } = this.options;
            if (h && !h.current && h.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (c || u) && (this.isLayoutDirty = !0), t) {
                let f;
                const m = () => this.root.updateBlockedByResize = !1;
                t(o, () => {
                    this.root.updateBlockedByResize = !0, f && f(), f = G4(m, 250), vu.hasAnimatedSinceResize && (vu.hasAnimatedSinceResize = !1, this.nodes.forEach(Bw))
                })
            }
            u && this.root.registerSharedNode(u, this), this.options.animate !== !1 && h && (u || c) && this.addEventListener("didUpdate", ({
                delta: f,
                hasLayoutChanged: m,
                hasRelativeTargetChanged: _,
                layout: I
            }) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0, this.relativeTarget = void 0;
                    return
                }
                const R = this.options.transition || h.getDefaultTransition() || dj,
                    {
                        onLayoutAnimationStart: k,
                        onLayoutAnimationComplete: w
                    } = h.getProps(),
                    v = !this.targetLayout || !TP(this.targetLayout, I) || _,
                    T = !m && _;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || T || m && (v || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(f, T);
                    const x = { ...Eg(R, "layout"),
                        onPlay: k,
                        onComplete: w
                    };
                    (h.shouldReduceMotion || this.options.layoutRoot) && (x.delay = 0, x.type = !1), this.startAnimation(x)
                } else m || Bw(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = I
            })
        }
        unmount() {
            this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
            const o = this.getStack();
            o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, qr(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(lj), this.animationId++)
        }
        getTransformTemplate() {
            const {
                visualElement: o
            } = this.options;
            return o && o.getProps().transformTemplate
        }
        willUpdate(o = !0) {
            if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && EP(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
            this.isLayoutDirty = !0;
            for (let h = 0; h < this.path.length; h++) {
                const f = this.path[h];
                f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1)
            }
            const {
                layoutId: a,
                layout: u
            } = this.options;
            if (a === void 0 && !u) return;
            const c = this.getTransformTemplate();
            this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1, this.isUpdateBlocked()) {
                this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(jw);
                return
            }
            this.isUpdating || this.nodes.forEach(ij), this.isUpdating = !1, this.nodes.forEach(sj), this.nodes.forEach(Z4), this.nodes.forEach(ej), this.clearAllSnapshots();
            const a = An.now();
            He.delta = Hr(0, 1e3 / 60, a - He.timestamp), He.timestamp = a, He.isProcessing = !0, Rd.update.process(He), Rd.preRender.process(He), Rd.render.process(He), He.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0, zg.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(rj), this.sharedNodes.forEach(uj)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, he.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            he.postRender(() => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            })
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let u = 0; u < this.path.length; u++) this.path[u].updateScroll();
            const o = this.layout;
            this.layout = this.measure(!1), this.layoutCorrected = ke(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
            const {
                visualElement: a
            } = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
        }
        updateScroll(o = "measure") {
            let a = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a) {
                const u = r(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: o,
                    isRoot: u,
                    offset: n(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : u
                }
            }
        }
        resetTransform() {
            if (!i) return;
            const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
                a = this.projectionDelta && !wP(this.projectionDelta),
                u = this.getTransformTemplate(),
                c = u ? u(this.latestValues, "") : void 0,
                h = c !== this.prevTransformTemplateValue;
            o && (a || di(this.latestValues) || h) && (i(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender())
        }
        measure(o = !0) {
            const a = this.measurePageBox();
            let u = this.removeElementScroll(a);
            return o && (u = this.removeTransform(u)), fj(u), {
                animationId: this.root.animationId,
                measuredBox: a,
                layoutBox: u,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var o;
            const {
                visualElement: a
            } = this.options;
            if (!a) return ke();
            const u = a.measureViewportBox();
            if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(pj))) {
                const {
                    scroll: h
                } = this.root;
                h && (ms(u.x, h.offset.x), ms(u.y, h.offset.y))
            }
            return u
        }
        removeElementScroll(o) {
            var a;
            const u = ke();
            if (qt(u, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot) return u;
            for (let c = 0; c < this.path.length; c++) {
                const h = this.path[c],
                    {
                        scroll: f,
                        options: m
                    } = h;
                h !== this.root && f && m.layoutScroll && (f.wasRoot && qt(u, o), ms(u.x, f.offset.x), ms(u.y, f.offset.y))
            }
            return u
        }
        applyTransform(o, a = !1) {
            const u = ke();
            qt(u, o);
            for (let c = 0; c < this.path.length; c++) {
                const h = this.path[c];
                !a && h.options.layoutScroll && h.scroll && h !== h.root && gs(u, {
                    x: -h.scroll.offset.x,
                    y: -h.scroll.offset.y
                }), di(h.latestValues) && gs(u, h.latestValues)
            }
            return di(this.latestValues) && gs(u, this.latestValues), u
        }
        removeTransform(o) {
            const a = ke();
            qt(a, o);
            for (let u = 0; u < this.path.length; u++) {
                const c = this.path[u];
                if (!c.instance || !di(c.latestValues)) continue;
                _p(c.latestValues) && c.updateSnapshot();
                const h = ke(),
                    f = c.measurePageBox();
                qt(h, f), Dw(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, h)
            }
            return di(this.latestValues) && Dw(a, this.latestValues), a
        }
        setTargetDelta(o) {
            this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
        }
        setOptions(o) {
            this.options = { ...this.options,
                ...o,
                crossfade: o.crossfade !== void 0 ? o.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== He.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(o = !1) {
            var a;
            const u = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = u.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = u.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = u.isSharedProjectionDirty);
            const c = !!this.resumingFrom || this !== u;
            if (!(o || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return;
            const {
                layout: f,
                layoutId: m
            } = this.options;
            if (!(!this.layout || !(f || m))) {
                if (this.resolvedRelativeTargetAt = He.timestamp, !this.targetDelta && !this.relativeTarget) {
                    const _ = this.getClosestProjectingParent();
                    _ && _.layout && this.animationProgress !== 1 ? (this.relativeParent = _, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ke(), this.relativeTargetOrigin = ke(), ra(this.relativeTargetOrigin, this.layout.layoutBox, _.layout.layoutBox), qt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = ke(), this.targetWithTransforms = ke()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), m4(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : qt(this.target, this.layout.layoutBox), fP(this.target, this.targetDelta)) : qt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const _ = this.getClosestProjectingParent();
                        _ && !!_.resumingFrom == !!this.resumingFrom && !_.options.layoutScroll && _.target && this.animationProgress !== 1 ? (this.relativeParent = _, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ke(), this.relativeTargetOrigin = ke(), ra(this.relativeTargetOrigin, this.target, _.target), qt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    Fo && fi.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || _p(this.parent.latestValues) || dP(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var o;
            const a = this.getLead(),
                u = !!this.resumingFrom || this !== a;
            let c = !0;
            if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (c = !1), u && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === He.timestamp && (c = !1), c) return;
            const {
                layout: h,
                layoutId: f
            } = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(h || f)) return;
            qt(this.layoutCorrected, this.layout.layoutBox);
            const m = this.treeScale.x,
                _ = this.treeScale.y;
            S4(this.layoutCorrected, this.treeScale, this.path, u), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = ke());
            const {
                target: I
            } = a;
            if (!I) {
                this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
                return
            }!this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (xw(this.prevProjectionDelta.x, this.projectionDelta.x), xw(this.prevProjectionDelta.y, this.projectionDelta.y)), na(this.projectionDelta, this.layoutCorrected, I, this.latestValues), (this.treeScale.x !== m || this.treeScale.y !== _ || !Fw(this.projectionDelta.x, this.prevProjectionDelta.x) || !Fw(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", I)), Fo && fi.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(o = !0) {
            var a;
            if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) {
                const u = this.getStack();
                u && u.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = ps(), this.projectionDelta = ps(), this.projectionDeltaWithTransform = ps()
        }
        setAnimationOrigin(o, a = !1) {
            const u = this.snapshot,
                c = u ? u.latestValues : {},
                h = { ...this.latestValues
                },
                f = ps();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
            const m = ke(),
                _ = u ? u.source : void 0,
                I = this.layout ? this.layout.source : void 0,
                R = _ !== I,
                k = this.getStack(),
                w = !k || k.members.length <= 1,
                v = !!(R && !w && this.options.crossfade === !0 && !this.path.some(hj));
            this.animationProgress = 0;
            let T;
            this.mixTargetDelta = x => {
                const O = x / 1e3;
                $w(f.x, o.x, O), $w(f.y, o.y, O), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (ra(m, this.layout.layoutBox, this.relativeParent.layout.layoutBox), cj(this.relativeTarget, this.relativeTargetOrigin, m, O), T && z4(this.relativeTarget, T) && (this.isProjectionDirty = !1), T || (T = ke()), qt(T, this.relativeTarget)), R && (this.animationValues = h, M4(h, c, this.latestValues, O, v, w)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = O
            }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(o) {
            this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (qr(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = he.update(() => {
                vu.hasAnimatedSinceResize = !0, this.currentAnimation = Y4(0, Uw, { ...o,
                    onUpdate: a => {
                        this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a)
                    },
                    onComplete: () => {
                        o.onComplete && o.onComplete(), this.completeAnimation()
                    }
                }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
            })
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
            const o = this.getStack();
            o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Uw), this.currentAnimation.stop()), this.completeAnimation()
        }
        applyTransformsToTarget() {
            const o = this.getLead();
            let {
                targetWithTransforms: a,
                target: u,
                layout: c,
                latestValues: h
            } = o;
            if (!(!a || !u || !c)) {
                if (this !== o && this.layout && c && SP(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
                    u = this.target || ke();
                    const f = Bt(this.layout.layoutBox.x);
                    u.x.min = o.target.x.min, u.x.max = u.x.min + f;
                    const m = Bt(this.layout.layoutBox.y);
                    u.y.min = o.target.y.min, u.y.max = u.y.min + m
                }
                qt(a, u), gs(a, h), na(this.projectionDeltaWithTransform, this.layoutCorrected, a, h)
            }
        }
        registerSharedNode(o, a) {
            this.sharedNodes.has(o) || this.sharedNodes.set(o, new W4), this.sharedNodes.get(o).add(a);
            const c = a.options.initialPromotionConfig;
            a.promote({
                transition: c ? c.transition : void 0,
                preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
            })
        }
        isLead() {
            const o = this.getStack();
            return o ? o.lead === this : !0
        }
        getLead() {
            var o;
            const {
                layoutId: a
            } = this.options;
            return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this
        }
        getPrevLead() {
            var o;
            const {
                layoutId: a
            } = this.options;
            return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0
        }
        getStack() {
            const {
                layoutId: o
            } = this.options;
            if (o) return this.root.sharedNodes.get(o)
        }
        promote({
            needsReset: o,
            transition: a,
            preserveFollowOpacity: u
        } = {}) {
            const c = this.getStack();
            c && c.promote(this, u), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({
                transition: a
            })
        }
        relegate() {
            const o = this.getStack();
            return o ? o.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {
                visualElement: o
            } = this.options;
            if (!o) return;
            let a = !1;
            const {
                latestValues: u
            } = o;
            if ((u.z || u.rotate || u.rotateX || u.rotateY || u.rotateZ || u.skewX || u.skewY) && (a = !0), !a) return;
            const c = {};
            u.z && Ld("z", o, c, this.animationValues);
            for (let h = 0; h < Od.length; h++) Ld(`rotate${Od[h]}`, o, c, this.animationValues), Ld(`skew${Od[h]}`, o, c, this.animationValues);
            o.render();
            for (const h in c) o.setStaticValue(h, c[h]), this.animationValues && (this.animationValues[h] = c[h]);
            o.scheduleRender()
        }
        getProjectionStyles(o) {
            var a, u;
            if (!this.instance || this.isSVG) return;
            if (!this.isVisible) return X4;
            const c = {
                    visibility: ""
                },
                h = this.getTransformTemplate();
            if (this.needsReset) return this.needsReset = !1, c.opacity = "", c.pointerEvents = _u(o == null ? void 0 : o.pointerEvents) || "", c.transform = h ? h(this.latestValues, "") : "none", c;
            const f = this.getLead();
            if (!this.projectionDelta || !this.layout || !f.target) {
                const R = {};
                return this.options.layoutId && (R.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, R.pointerEvents = _u(o == null ? void 0 : o.pointerEvents) || ""), this.hasProjected && !di(this.latestValues) && (R.transform = h ? h({}, "") : "none", this.hasProjected = !1), R
            }
            const m = f.animationValues || f.latestValues;
            this.applyTransformsToTarget(), c.transform = q4(this.projectionDeltaWithTransform, this.treeScale, m), h && (c.transform = h(m, c.transform));
            const {
                x: _,
                y: I
            } = this.projectionDelta;
            c.transformOrigin = `${_.origin*100}% ${I.origin*100}% 0`, f.animationValues ? c.opacity = f === this ? (u = (a = m.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && u !== void 0 ? u : 1 : this.preserveOpacity ? this.latestValues.opacity : m.opacityExit : c.opacity = f === this ? m.opacity !== void 0 ? m.opacity : "" : m.opacityExit !== void 0 ? m.opacityExit : 0;
            for (const R in yc) {
                if (m[R] === void 0) continue;
                const {
                    correct: k,
                    applyTo: w
                } = yc[R], v = c.transform === "none" ? m[R] : k(m[R], f);
                if (w) {
                    const T = w.length;
                    for (let x = 0; x < T; x++) c[w[x]] = v
                } else c[R] = v
            }
            return this.options.layoutId && (c.pointerEvents = f === this ? _u(o == null ? void 0 : o.pointerEvents) || "" : "none"), c
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(o => {
                var a;
                return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop()
            }), this.root.nodes.forEach(jw), this.root.sharedNodes.clear()
        }
    }
}

function Z4(t) {
    t.updateLayout()
}

function ej(t) {
    var e;
    const n = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
    if (t.isLead() && t.layout && n && t.hasListeners("didUpdate")) {
        const {
            layoutBox: r,
            measuredBox: i
        } = t.layout, {
            animationType: s
        } = t.options, o = n.source !== t.layout.source;
        s === "size" ? Ht(f => {
            const m = o ? n.measuredBox[f] : n.layoutBox[f],
                _ = Bt(m);
            m.min = r[f].min, m.max = m.min + _
        }) : SP(s, n.layoutBox, r) && Ht(f => {
            const m = o ? n.measuredBox[f] : n.layoutBox[f],
                _ = Bt(r[f]);
            m.max = m.min + _, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[f].max = t.relativeTarget[f].min + _)
        });
        const a = ps();
        na(a, r, n.layoutBox);
        const u = ps();
        o ? na(u, t.applyTransform(i, !0), n.measuredBox) : na(u, r, n.layoutBox);
        const c = !wP(a);
        let h = !1;
        if (!t.resumeFrom) {
            const f = t.getClosestProjectingParent();
            if (f && !f.resumeFrom) {
                const {
                    snapshot: m,
                    layout: _
                } = f;
                if (m && _) {
                    const I = ke();
                    ra(I, n.layoutBox, m.layoutBox);
                    const R = ke();
                    ra(R, r, _.layoutBox), TP(I, R) || (h = !0), f.options.layoutRoot && (t.relativeTarget = R, t.relativeTargetOrigin = I, t.relativeParent = f)
                }
            }
        }
        t.notifyListeners("didUpdate", {
            layout: r,
            snapshot: n,
            delta: u,
            layoutDelta: a,
            hasLayoutChanged: c,
            hasRelativeTargetChanged: h
        })
    } else if (t.isLead()) {
        const {
            onExitComplete: r
        } = t.options;
        r && r()
    }
    t.options.transition = void 0
}

function tj(t) {
    Fo && fi.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty))
}

function nj(t) {
    t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1
}

function rj(t) {
    t.clearSnapshot()
}

function jw(t) {
    t.clearMeasurements()
}

function ij(t) {
    t.isLayoutDirty = !1
}

function sj(t) {
    const {
        visualElement: e
    } = t.options;
    e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform()
}

function Bw(t) {
    t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0
}

function oj(t) {
    t.resolveTargetDelta()
}

function aj(t) {
    t.calcProjection()
}

function lj(t) {
    t.resetSkewAndRotation()
}

function uj(t) {
    t.removeLeadSnapshot()
}

function $w(t, e, n) {
    t.translate = Ee(e.translate, 0, n), t.scale = Ee(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint
}

function zw(t, e, n, r) {
    t.min = Ee(e.min, n.min, r), t.max = Ee(e.max, n.max, r)
}

function cj(t, e, n, r) {
    zw(t.x, e.x, n.x, r), zw(t.y, e.y, n.y, r)
}

function hj(t) {
    return t.animationValues && t.animationValues.opacityExit !== void 0
}
const dj = {
        duration: .45,
        ease: [.4, 0, .1, 1]
    },
    Ww = t => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t),
    qw = Ww("applewebkit/") && !Ww("chrome/") ? Math.round : ht;

function Hw(t) {
    t.min = qw(t.min), t.max = qw(t.max)
}

function fj(t) {
    Hw(t.x), Hw(t.y)
}

function SP(t, e, n) {
    return t === "position" || t === "preserve-aspect" && !p4(Mw(e), Mw(n), .2)
}

function pj(t) {
    var e;
    return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot)
}
const mj = IP({
        attachResizeListener: (t, e) => jn(t, "resize", e),
        measureScroll: () => ({
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop
        }),
        checkIsScrollRoot: () => !0
    }),
    Md = {
        current: void 0
    },
    AP = IP({
        measureScroll: t => ({
            x: t.scrollLeft,
            y: t.scrollTop
        }),
        defaultParent: () => {
            if (!Md.current) {
                const t = new mj({});
                t.mount(window), t.setOptions({
                    layoutScroll: !0
                }), Md.current = t
            }
            return Md.current
        },
        resetTransform: (t, e) => {
            t.style.transform = e !== void 0 ? e : "none"
        },
        checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed"
    }),
    gj = {
        pan: {
            Feature: x4
        },
        drag: {
            Feature: k4,
            ProjectionNode: AP,
            MeasureLayout: yP
        }
    };

function Kw(t, e) {
    const n = e ? "pointerenter" : "pointerleave",
        r = e ? "onHoverStart" : "onHoverEnd",
        i = (s, o) => {
            if (s.pointerType === "touch" || lP()) return;
            const a = t.getProps();
            t.animationState && a.whileHover && t.animationState.setActive("whileHover", e);
            const u = a[r];
            u && he.postRender(() => u(s, o))
        };
    return Kn(t.current, n, i, {
        passive: !t.getProps()[r]
    })
}
class yj extends ti {
    mount() {
        this.unmount = Hn(Kw(this.node, !0), Kw(this.node, !1))
    }
    unmount() {}
}
class vj extends ti {
    constructor() {
        super(...arguments), this.isActive = !1
    }
    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(":focus-visible")
        } catch {
            e = !0
        }!e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
    }
    mount() {
        this.unmount = Hn(jn(this.node.current, "focus", () => this.onFocus()), jn(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
const PP = (t, e) => e ? t === e ? !0 : PP(t, e.parentElement) : !1;

function Fd(t, e) {
    if (!e) return;
    const n = new PointerEvent("pointer" + t);
    e(n, fh(n))
}
class _j extends ti {
    constructor() {
        super(...arguments), this.removeStartListeners = ht, this.removeEndListeners = ht, this.removeAccessibleListeners = ht, this.startPointerPress = (e, n) => {
            if (this.isPressing) return;
            this.removeEndListeners();
            const r = this.node.getProps(),
                s = Kn(window, "pointerup", (a, u) => {
                    if (!this.checkPressEnd()) return;
                    const {
                        onTap: c,
                        onTapCancel: h,
                        globalTapTarget: f
                    } = this.node.getProps(), m = !f && !PP(this.node.current, a.target) ? h : c;
                    m && he.update(() => m(a, u))
                }, {
                    passive: !(r.onTap || r.onPointerUp)
                }),
                o = Kn(window, "pointercancel", (a, u) => this.cancelPress(a, u), {
                    passive: !(r.onTapCancel || r.onPointerCancel)
                });
            this.removeEndListeners = Hn(s, o), this.startPress(e, n)
        }, this.startAccessiblePress = () => {
            const e = s => {
                    if (s.key !== "Enter" || this.isPressing) return;
                    const o = a => {
                        a.key !== "Enter" || !this.checkPressEnd() || Fd("up", (u, c) => {
                            const {
                                onTap: h
                            } = this.node.getProps();
                            h && he.postRender(() => h(u, c))
                        })
                    };
                    this.removeEndListeners(), this.removeEndListeners = jn(this.node.current, "keyup", o), Fd("down", (a, u) => {
                        this.startPress(a, u)
                    })
                },
                n = jn(this.node.current, "keydown", e),
                r = () => {
                    this.isPressing && Fd("cancel", (s, o) => this.cancelPress(s, o))
                },
                i = jn(this.node.current, "blur", r);
            this.removeAccessibleListeners = Hn(n, i)
        }
    }
    startPress(e, n) {
        this.isPressing = !0;
        const {
            onTapStart: r,
            whileTap: i
        } = this.node.getProps();
        i && this.node.animationState && this.node.animationState.setActive("whileTap", !0), r && he.postRender(() => r(e, n))
    }
    checkPressEnd() {
        return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !lP()
    }
    cancelPress(e, n) {
        if (!this.checkPressEnd()) return;
        const {
            onTapCancel: r
        } = this.node.getProps();
        r && he.postRender(() => r(e, n))
    }
    mount() {
        const e = this.node.getProps(),
            n = Kn(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
                passive: !(e.onTapStart || e.onPointerStart)
            }),
            r = jn(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = Hn(n, r)
    }
    unmount() {
        this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners()
    }
}
const Tp = new WeakMap,
    Ud = new WeakMap,
    wj = t => {
        const e = Tp.get(t.target);
        e && e(t)
    },
    Tj = t => {
        t.forEach(wj)
    };

function Ej({
    root: t,
    ...e
}) {
    const n = t || document;
    Ud.has(n) || Ud.set(n, {});
    const r = Ud.get(n),
        i = JSON.stringify(e);
    return r[i] || (r[i] = new IntersectionObserver(Tj, {
        root: t,
        ...e
    })), r[i]
}

function Ij(t, e, n) {
    const r = Ej(e);
    return Tp.set(t, n), r.observe(t), () => {
        Tp.delete(t), r.unobserve(t)
    }
}
const Sj = {
    some: 0,
    all: 1
};
class Aj extends ti {
    constructor() {
        super(...arguments), this.hasEnteredView = !1, this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {
            viewport: e = {}
        } = this.node.getProps(), {
            root: n,
            margin: r,
            amount: i = "some",
            once: s
        } = e, o = {
            root: n ? n.current : void 0,
            rootMargin: r,
            threshold: typeof i == "number" ? i : Sj[i]
        }, a = u => {
            const {
                isIntersecting: c
            } = u;
            if (this.isInView === c || (this.isInView = c, s && !c && this.hasEnteredView)) return;
            c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c);
            const {
                onViewportEnter: h,
                onViewportLeave: f
            } = this.node.getProps(), m = c ? h : f;
            m && m(u)
        };
        return Ij(this.node.current, o, a)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u") return;
        const {
            props: e,
            prevProps: n
        } = this.node;
        ["amount", "margin", "root"].some(Pj(e, n)) && this.startObserver()
    }
    unmount() {}
}

function Pj({
    viewport: t = {}
}, {
    viewport: e = {}
} = {}) {
    return n => t[n] !== e[n]
}
const Rj = {
        inView: {
            Feature: Aj
        },
        tap: {
            Feature: _j
        },
        focus: {
            Feature: vj
        },
        hover: {
            Feature: yj
        }
    },
    Cj = {
        layout: {
            ProjectionNode: AP,
            MeasureLayout: yP
        }
    },
    Wg = M.createContext({
        transformPagePoint: t => t,
        isStatic: !1,
        reducedMotion: "never"
    }),
    mh = M.createContext({}),
    qg = typeof window < "u",
    Hg = qg ? M.useLayoutEffect : M.useEffect,
    RP = M.createContext({
        strict: !1
    });

function kj(t, e, n, r, i) {
    var s, o;
    const {
        visualElement: a
    } = M.useContext(mh), u = M.useContext(RP), c = M.useContext(ph), h = M.useContext(Wg).reducedMotion, f = M.useRef();
    r = r || u.renderer, !f.current && r && (f.current = r(t, {
        visualState: e,
        parent: a,
        props: n,
        presenceContext: c,
        blockInitialAnimation: c ? c.initial === !1 : !1,
        reducedMotionConfig: h
    }));
    const m = f.current,
        _ = M.useContext(gP);
    m && !m.projection && i && (m.type === "html" || m.type === "svg") && xj(f.current, n, i, _);
    const I = M.useRef(!1);
    M.useInsertionEffect(() => {
        m && I.current && m.update(n, c)
    });
    const R = n[JA],
        k = M.useRef(!!R && !(!((s = window.MotionHandoffIsComplete) === null || s === void 0) && s.call(window, R)) && ((o = window.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(window, R)));
    return Hg(() => {
        m && (I.current = !0, window.MotionIsMounted = !0, m.updateFeatures(), zg.render(m.render), k.current && m.animationState && m.animationState.animateChanges())
    }), M.useEffect(() => {
        m && (!k.current && m.animationState && m.animationState.animateChanges(), k.current && (queueMicrotask(() => {
            var w;
            (w = window.MotionHandoffMarkAsComplete) === null || w === void 0 || w.call(window, R)
        }), k.current = !1))
    }), m
}

function xj(t, e, n, r) {
    const {
        layoutId: i,
        layout: s,
        drag: o,
        dragConstraints: a,
        layoutScroll: u,
        layoutRoot: c
    } = e;
    t.projection = new n(t.latestValues, e["data-framer-portal-id"] ? void 0 : CP(t.parent)), t.projection.setOptions({
        layoutId: i,
        layout: s,
        alwaysMeasureLayout: !!o || a && fs(a),
        visualElement: t,
        animationType: typeof s == "string" ? s : "both",
        initialPromotionConfig: r,
        layoutScroll: u,
        layoutRoot: c
    })
}

function CP(t) {
    if (t) return t.options.allowProjection !== !1 ? t.projection : CP(t.parent)
}

function bj(t, e, n) {
    return M.useCallback(r => {
        r && t.mount && t.mount(r), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : fs(n) && (n.current = r))
    }, [e])
}

function gh(t) {
    return ch(t.animate) || Tg.some(e => Da(t[e]))
}

function kP(t) {
    return !!(gh(t) || t.variants)
}

function Nj(t, e) {
    if (gh(t)) {
        const {
            initial: n,
            animate: r
        } = t;
        return {
            initial: n === !1 || Da(n) ? n : void 0,
            animate: Da(r) ? r : void 0
        }
    }
    return t.inherit !== !1 ? e : {}
}

function Dj(t) {
    const {
        initial: e,
        animate: n
    } = Nj(t, M.useContext(mh));
    return M.useMemo(() => ({
        initial: e,
        animate: n
    }), [Gw(e), Gw(n)])
}

function Gw(t) {
    return Array.isArray(t) ? t.join(" ") : t
}
const Qw = {
        animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
        exit: ["exit"],
        drag: ["drag", "dragControls"],
        focus: ["whileFocus"],
        hover: ["whileHover", "onHoverStart", "onHoverEnd"],
        tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
        pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
        inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
        layout: ["layout", "layoutId"]
    },
    Ws = {};
for (const t in Qw) Ws[t] = {
    isEnabled: e => Qw[t].some(n => !!e[n])
};

function Vj(t) {
    for (const e in t) Ws[e] = { ...Ws[e],
        ...t[e]
    }
}
const Oj = Symbol.for("motionComponentSymbol");

function Lj({
    preloadedFeatures: t,
    createVisualElement: e,
    useRender: n,
    useVisualState: r,
    Component: i
}) {
    t && Vj(t);

    function s(a, u) {
        let c;
        const h = { ...M.useContext(Wg),
                ...a,
                layoutId: Mj(a)
            },
            {
                isStatic: f
            } = h,
            m = Dj(a),
            _ = r(a, f);
        if (!f && qg) {
            Fj();
            const I = Uj(h);
            c = I.MeasureLayout, m.visualElement = kj(i, _, h, e, I.ProjectionNode)
        }
        return D.jsxs(mh.Provider, {
            value: m,
            children: [c && m.visualElement ? D.jsx(c, {
                visualElement: m.visualElement,
                ...h
            }) : null, n(i, a, bj(_, m.visualElement, u), _, f, m.visualElement)]
        })
    }
    const o = M.forwardRef(s);
    return o[Oj] = i, o
}

function Mj({
    layoutId: t
}) {
    const e = M.useContext($g).id;
    return e && t !== void 0 ? e + "-" + t : t
}

function Fj(t, e) {
    M.useContext(RP).strict
}

function Uj(t) {
    const {
        drag: e,
        layout: n
    } = Ws;
    if (!e && !n) return {};
    const r = { ...e,
        ...n
    };
    return {
        MeasureLayout: e != null && e.isEnabled(t) || n != null && n.isEnabled(t) ? r.MeasureLayout : void 0,
        ProjectionNode: r.ProjectionNode
    }
}
const jj = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

function Kg(t) {
    return typeof t != "string" || t.includes("-") ? !1 : !!(jj.indexOf(t) > -1 || /[A-Z]/u.test(t))
}

function xP(t, {
    style: e,
    vars: n
}, r, i) {
    Object.assign(t.style, e, i && i.getProjectionStyles(r));
    for (const s in n) t.style.setProperty(s, n[s])
}
const bP = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

function NP(t, e, n, r) {
    xP(t, e, void 0, r);
    for (const i in e.attrs) t.setAttribute(bP.has(i) ? i : Bg(i), e.attrs[i])
}

function DP(t, {
    layout: e,
    layoutId: n
}) {
    return Ui.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!yc[t] || t === "opacity")
}

function Gg(t, e, n) {
    var r;
    const {
        style: i
    } = t, s = {};
    for (const o in i)(ut(i[o]) || e.style && ut(e.style[o]) || DP(o, t) || ((r = n == null ? void 0 : n.getValue(o)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (s[o] = i[o]);
    return s
}

function VP(t, e, n) {
    const r = Gg(t, e, n);
    for (const i in t)
        if (ut(t[i]) || ut(e[i])) {
            const s = tl.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
            r[s] = t[i]
        }
    return r
}

function yh(t) {
    const e = M.useRef(null);
    return e.current === null && (e.current = t()), e.current
}

function Bj({
    scrapeMotionValuesFromProps: t,
    createRenderState: e,
    onMount: n
}, r, i, s) {
    const o = {
        latestValues: $j(r, i, s, t),
        renderState: e()
    };
    return n && (o.mount = a => n(r, a, o)), o
}
const OP = t => (e, n) => {
    const r = M.useContext(mh),
        i = M.useContext(ph),
        s = () => Bj(t, e, r, i);
    return n ? s() : yh(s)
};

function $j(t, e, n, r) {
    const i = {},
        s = r(t, {});
    for (const m in s) i[m] = _u(s[m]);
    let {
        initial: o,
        animate: a
    } = t;
    const u = gh(t),
        c = kP(t);
    e && c && !u && t.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
    let h = n ? n.initial === !1 : !1;
    h = h || o === !1;
    const f = h ? a : o;
    if (f && typeof f != "boolean" && !ch(f)) {
        const m = Array.isArray(f) ? f : [f];
        for (let _ = 0; _ < m.length; _++) {
            const I = _g(t, m[_]);
            if (I) {
                const {
                    transitionEnd: R,
                    transition: k,
                    ...w
                } = I;
                for (const v in w) {
                    let T = w[v];
                    if (Array.isArray(T)) {
                        const x = h ? T.length - 1 : 0;
                        T = T[x]
                    }
                    T !== null && (i[v] = T)
                }
                for (const v in R) i[v] = R[v]
            }
        }
    }
    return i
}
const Qg = () => ({
        style: {},
        transform: {},
        transformOrigin: {},
        vars: {}
    }),
    LP = () => ({ ...Qg(),
        attrs: {}
    }),
    MP = (t, e) => e && typeof t == "number" ? e.transform(t) : t,
    zj = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
        transformPerspective: "perspective"
    },
    Wj = tl.length;

function qj(t, e, n) {
    let r = "",
        i = !0;
    for (let s = 0; s < Wj; s++) {
        const o = tl[s],
            a = t[o];
        if (a === void 0) continue;
        let u = !0;
        if (typeof a == "number" ? u = a === (o.startsWith("scale") ? 1 : 0) : u = parseFloat(a) === 0, !u || n) {
            const c = MP(a, kg[o]);
            if (!u) {
                i = !1;
                const h = zj[o] || o;
                r += `${h}(${c}) `
            }
            n && (e[o] = c)
        }
    }
    return r = r.trim(), n ? r = n(e, i ? "" : r) : i && (r = "none"), r
}

function Yg(t, e, n) {
    const {
        style: r,
        vars: i,
        transformOrigin: s
    } = t;
    let o = !1,
        a = !1;
    for (const u in e) {
        const c = e[u];
        if (Ui.has(u)) {
            o = !0;
            continue
        } else if (kA(u)) {
            i[u] = c;
            continue
        } else {
            const h = MP(c, kg[u]);
            u.startsWith("origin") ? (a = !0, s[u] = h) : r[u] = h
        }
    }
    if (e.transform || (o || n ? r.transform = qj(e, t.transform, n) : r.transform && (r.transform = "none")), a) {
        const {
            originX: u = "50%",
            originY: c = "50%",
            originZ: h = 0
        } = s;
        r.transformOrigin = `${u} ${c} ${h}`
    }
}

function Yw(t, e, n) {
    return typeof t == "string" ? t : G.transform(e + n * t)
}

function Hj(t, e, n) {
    const r = Yw(e, t.x, t.width),
        i = Yw(n, t.y, t.height);
    return `${r} ${i}`
}
const Kj = {
        offset: "stroke-dashoffset",
        array: "stroke-dasharray"
    },
    Gj = {
        offset: "strokeDashoffset",
        array: "strokeDasharray"
    };

function Qj(t, e, n = 1, r = 0, i = !0) {
    t.pathLength = 1;
    const s = i ? Kj : Gj;
    t[s.offset] = G.transform(-r);
    const o = G.transform(e),
        a = G.transform(n);
    t[s.array] = `${o} ${a}`
}

function Xg(t, {
    attrX: e,
    attrY: n,
    attrScale: r,
    originX: i,
    originY: s,
    pathLength: o,
    pathSpacing: a = 1,
    pathOffset: u = 0,
    ...c
}, h, f) {
    if (Yg(t, c, f), h) {
        t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
        return
    }
    t.attrs = t.style, t.style = {};
    const {
        attrs: m,
        style: _,
        dimensions: I
    } = t;
    m.transform && (I && (_.transform = m.transform), delete m.transform), I && (i !== void 0 || s !== void 0 || _.transform) && (_.transformOrigin = Hj(I, i !== void 0 ? i : .5, s !== void 0 ? s : .5)), e !== void 0 && (m.x = e), n !== void 0 && (m.y = n), r !== void 0 && (m.scale = r), o !== void 0 && Qj(m, o, a, u, !1)
}
const Jg = t => typeof t == "string" && t.toLowerCase() === "svg",
    Yj = {
        useVisualState: OP({
            scrapeMotionValuesFromProps: VP,
            createRenderState: LP,
            onMount: (t, e, {
                renderState: n,
                latestValues: r
            }) => {
                he.read(() => {
                    try {
                        n.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect()
                    } catch {
                        n.dimensions = {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        }
                    }
                }), he.render(() => {
                    Xg(n, r, Jg(e.tagName), t.transformTemplate), NP(e, n)
                })
            }
        })
    },
    Xj = {
        useVisualState: OP({
            scrapeMotionValuesFromProps: Gg,
            createRenderState: Qg
        })
    };

function FP(t, e, n) {
    for (const r in e) !ut(e[r]) && !DP(r, n) && (t[r] = e[r])
}

function Jj({
    transformTemplate: t
}, e) {
    return M.useMemo(() => {
        const n = Qg();
        return Yg(n, e, t), Object.assign({}, n.vars, n.style)
    }, [e])
}

function Zj(t, e) {
    const n = t.style || {},
        r = {};
    return FP(r, n, t), Object.assign(r, Jj(t, e)), r
}

function eB(t, e) {
    const n = {},
        r = Zj(t, e);
    return t.drag && t.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = t.drag === !0 ? "none" : `pan-${t.drag==="x"?"y":"x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = r, n
}
const tB = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);

function vc(t) {
    return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || tB.has(t)
}
let UP = t => !vc(t);

function nB(t) {
    t && (UP = e => e.startsWith("on") ? !vc(e) : t(e))
}
try {
    nB(require("@emotion/is-prop-valid").default)
} catch {}

function rB(t, e, n) {
    const r = {};
    for (const i in t) i === "values" && typeof t.values == "object" || (UP(i) || n === !0 && vc(i) || !e && !vc(i) || t.draggable && i.startsWith("onDrag")) && (r[i] = t[i]);
    return r
}

function iB(t, e, n, r) {
    const i = M.useMemo(() => {
        const s = LP();
        return Xg(s, e, Jg(r), t.transformTemplate), { ...s.attrs,
            style: { ...s.style
            }
        }
    }, [e]);
    if (t.style) {
        const s = {};
        FP(s, t.style, t), i.style = { ...s,
            ...i.style
        }
    }
    return i
}

function sB(t = !1) {
    return (n, r, i, {
        latestValues: s
    }, o) => {
        const u = (Kg(n) ? iB : eB)(r, s, o, n),
            c = rB(r, typeof n == "string", t),
            h = n !== M.Fragment ? { ...c,
                ...u,
                ref: i
            } : {},
            {
                children: f
            } = r,
            m = M.useMemo(() => ut(f) ? f.get() : f, [f]);
        return M.createElement(n, { ...h,
            children: m
        })
    }
}

function oB(t, e) {
    return function(r, {
        forwardMotionProps: i
    } = {
        forwardMotionProps: !1
    }) {
        const o = { ...Kg(r) ? Yj : Xj,
            preloadedFeatures: t,
            useRender: sB(i),
            createVisualElement: e,
            Component: r
        };
        return Lj(o)
    }
}
const Ep = {
        current: null
    },
    jP = {
        current: !1
    };

function aB() {
    if (jP.current = !0, !!qg)
        if (window.matchMedia) {
            const t = window.matchMedia("(prefers-reduced-motion)"),
                e = () => Ep.current = t.matches;
            t.addListener(e), e()
        } else Ep.current = !1
}

function lB(t, e, n) {
    for (const r in e) {
        const i = e[r],
            s = n[r];
        if (ut(i)) t.addValue(r, i);
        else if (ut(s)) t.addValue(r, La(i, {
            owner: t
        }));
        else if (s !== i)
            if (t.hasValue(r)) {
                const o = t.getValue(r);
                o.liveStyle === !0 ? o.jump(i) : o.hasAnimated || o.set(i)
            } else {
                const o = t.getStaticValue(r);
                t.addValue(r, La(o !== void 0 ? o : i, {
                    owner: t
                }))
            }
    }
    for (const r in n) e[r] === void 0 && t.removeValue(r);
    return e
}
const Xw = new WeakMap,
    uB = [...NA, st, Kr],
    cB = t => uB.find(bA(t)),
    Jw = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class hB {
    scrapeMotionValuesFromProps(e, n, r) {
        return {}
    }
    constructor({
        parent: e,
        props: n,
        presenceContext: r,
        reducedMotionConfig: i,
        blockInitialAnimation: s,
        visualState: o
    }, a = {}) {
        this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = Pg, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
            this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }, this.renderScheduledAt = 0, this.scheduleRender = () => {
            const m = An.now();
            this.renderScheduledAt < m && (this.renderScheduledAt = m, he.render(this.render, !1, !0))
        };
        const {
            latestValues: u,
            renderState: c
        } = o;
        this.latestValues = u, this.baseTarget = { ...u
        }, this.initialValues = n.initial ? { ...u
        } : {}, this.renderState = c, this.parent = e, this.props = n, this.presenceContext = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!s, this.isControllingVariants = gh(n), this.isVariantNode = kP(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current);
        const {
            willChange: h,
            ...f
        } = this.scrapeMotionValuesFromProps(n, {}, this);
        for (const m in f) {
            const _ = f[m];
            u[m] !== void 0 && ut(_) && _.set(u[m], !1)
        }
    }
    mount(e) {
        this.current = e, Xw.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), jP.current || aB(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Ep.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
    }
    unmount() {
        Xw.delete(this.current), this.projection && this.projection.unmount(), qr(this.notifyUpdate), qr(this.render), this.valueSubscriptions.forEach(e => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
        for (const e in this.events) this.events[e].clear();
        for (const e in this.features) {
            const n = this.features[e];
            n && (n.unmount(), n.isMounted = !1)
        }
        this.current = null
    }
    bindToMotionValue(e, n) {
        this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
        const r = Ui.has(e),
            i = n.on("change", a => {
                this.latestValues[e] = a, this.props.onUpdate && he.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0)
            }),
            s = n.on("renderRequest", this.scheduleRender);
        let o;
        window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, e, n)), this.valueSubscriptions.set(e, () => {
            i(), s(), o && o(), n.owner && n.stop()
        })
    }
    sortNodePosition(e) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
    }
    updateFeatures() {
        let e = "animation";
        for (e in Ws) {
            const n = Ws[e];
            if (!n) continue;
            const {
                isEnabled: r,
                Feature: i
            } = n;
            if (!this.features[e] && i && r(this.props) && (this.features[e] = new i(this)), this.features[e]) {
                const s = this.features[e];
                s.isMounted ? s.update() : (s.mount(), s.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ke()
    }
    getStaticValue(e) {
        return this.latestValues[e]
    }
    setStaticValue(e, n) {
        this.latestValues[e] = n
    }
    update(e, n) {
        (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
        for (let r = 0; r < Jw.length; r++) {
            const i = Jw[r];
            this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
            const s = "on" + i,
                o = e[s];
            o && (this.propEventSubscriptions[i] = this.on(i, o))
        }
        this.prevMotionValues = lB(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(e) {
        const n = this.getClosestVariantNode();
        if (n) return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e)
    }
    addValue(e, n) {
        const r = this.values.get(e);
        n !== r && (r && this.removeValue(e), this.bindToMotionValue(e, n), this.values.set(e, n), this.latestValues[e] = n.get())
    }
    removeValue(e) {
        this.values.delete(e);
        const n = this.valueSubscriptions.get(e);
        n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState)
    }
    hasValue(e) {
        return this.values.has(e)
    }
    getValue(e, n) {
        if (this.props.values && this.props.values[e]) return this.props.values[e];
        let r = this.values.get(e);
        return r === void 0 && n !== void 0 && (r = La(n === null ? void 0 : n, {
            owner: this
        }), this.addValue(e, r)), r
    }
    readValue(e, n) {
        var r;
        let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (r = this.getBaseTargetFromProps(this.props, e)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, e, this.options);
        return i != null && (typeof i == "string" && (RA(i) || PA(i)) ? i = parseFloat(i) : !cB(i) && Kr.test(n) && (i = jA(e, n)), this.setBaseTarget(e, ut(i) ? i.get() : i)), ut(i) ? i.get() : i
    }
    setBaseTarget(e, n) {
        this.baseTarget[e] = n
    }
    getBaseTarget(e) {
        var n;
        const {
            initial: r
        } = this.props;
        let i;
        if (typeof r == "string" || typeof r == "object") {
            const o = _g(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
            o && (i = o[e])
        }
        if (r && i !== void 0) return i;
        const s = this.getBaseTargetFromProps(this.props, e);
        return s !== void 0 && !ut(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e]
    }
    on(e, n) {
        return this.events[e] || (this.events[e] = new Ug), this.events[e].add(n)
    }
    notify(e, ...n) {
        this.events[e] && this.events[e].notify(...n)
    }
}
class BP extends hB {
    constructor() {
        super(...arguments), this.KeyframeResolver = BA
    }
    sortInstanceNodePosition(e, n) {
        return e.compareDocumentPosition(n) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, n) {
        return e.style ? e.style[n] : void 0
    }
    removeValueFromRenderState(e, {
        vars: n,
        style: r
    }) {
        delete n[e], delete r[e]
    }
}

function dB(t) {
    return window.getComputedStyle(t)
}
class fB extends BP {
    constructor() {
        super(...arguments), this.type = "html", this.renderInstance = xP
    }
    readValueFromInstance(e, n) {
        if (Ui.has(n)) {
            const r = xg(n);
            return r && r.default || 0
        } else {
            const r = dB(e),
                i = (kA(n) ? r.getPropertyValue(n) : r[n]) || 0;
            return typeof i == "string" ? i.trim() : i
        }
    }
    measureInstanceViewportBox(e, {
        transformPagePoint: n
    }) {
        return pP(e, n)
    }
    build(e, n, r) {
        Yg(e, n, r.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, n, r) {
        return Gg(e, n, r)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(), delete this.childSubscription);
        const {
            children: e
        } = this.props;
        ut(e) && (this.childSubscription = e.on("change", n => {
            this.current && (this.current.textContent = `${n}`)
        }))
    }
}
class pB extends BP {
    constructor() {
        super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = ke
    }
    getBaseTargetFromProps(e, n) {
        return e[n]
    }
    readValueFromInstance(e, n) {
        if (Ui.has(n)) {
            const r = xg(n);
            return r && r.default || 0
        }
        return n = bP.has(n) ? n : Bg(n), e.getAttribute(n)
    }
    scrapeMotionValuesFromProps(e, n, r) {
        return VP(e, n, r)
    }
    build(e, n, r) {
        Xg(e, n, this.isSVGTag, r.transformTemplate)
    }
    renderInstance(e, n, r, i) {
        NP(e, n, r, i)
    }
    mount(e) {
        this.isSVGTag = Jg(e.tagName), super.mount(e)
    }
}
const mB = (t, e) => Kg(t) ? new pB(e) : new fB(e, {
        allowProjection: t !== M.Fragment
    }),
    gB = oB({ ...s4,
        ...Rj,
        ...gj,
        ...Cj
    }, mB),
    yn = J2(gB);
class yB extends M.Component {
    getSnapshotBeforeUpdate(e) {
        const n = this.props.childRef.current;
        if (n && e.isPresent && !this.props.isPresent) {
            const r = this.props.sizeRef.current;
            r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft
        }
        return null
    }
    componentDidUpdate() {}
    render() {
        return this.props.children
    }
}

function vB({
    children: t,
    isPresent: e
}) {
    const n = M.useId(),
        r = M.useRef(null),
        i = M.useRef({
            width: 0,
            height: 0,
            top: 0,
            left: 0
        }),
        {
            nonce: s
        } = M.useContext(Wg);
    return M.useInsertionEffect(() => {
        const {
            width: o,
            height: a,
            top: u,
            left: c
        } = i.current;
        if (e || !r.current || !o || !a) return;
        r.current.dataset.motionPopId = n;
        const h = document.createElement("style");
        return s && (h.nonce = s), document.head.appendChild(h), h.sheet && h.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${u}px !important;
            left: ${c}px !important;
          }
        `), () => {
            document.head.removeChild(h)
        }
    }, [e]), D.jsx(yB, {
        isPresent: e,
        childRef: r,
        sizeRef: i,
        children: M.cloneElement(t, {
            ref: r
        })
    })
}
const _B = ({
    children: t,
    initial: e,
    isPresent: n,
    onExitComplete: r,
    custom: i,
    presenceAffectsLayout: s,
    mode: o
}) => {
    const a = yh(wB),
        u = M.useId(),
        c = M.useCallback(f => {
            a.set(f, !0);
            for (const m of a.values())
                if (!m) return;
            r && r()
        }, [a, r]),
        h = M.useMemo(() => ({
            id: u,
            initial: e,
            isPresent: n,
            custom: i,
            onExitComplete: c,
            register: f => (a.set(f, !1), () => a.delete(f))
        }), s ? [Math.random(), c] : [n, c]);
    return M.useMemo(() => {
        a.forEach((f, m) => a.set(m, !1))
    }, [n]), M.useEffect(() => {
        !n && !a.size && r && r()
    }, [n]), o === "popLayout" && (t = D.jsx(vB, {
        isPresent: n,
        children: t
    })), D.jsx(ph.Provider, {
        value: h,
        children: t
    })
};

function wB() {
    return new Map
}
const Gl = t => t.key || "";

function Zw(t) {
    const e = [];
    return M.Children.forEach(t, n => {
        M.isValidElement(n) && e.push(n)
    }), e
}
const TB = ({
    children: t,
    exitBeforeEnter: e,
    custom: n,
    initial: r = !0,
    onExitComplete: i,
    presenceAffectsLayout: s = !0,
    mode: o = "sync"
}) => {
    const a = M.useMemo(() => Zw(t), [t]),
        u = a.map(Gl),
        c = M.useRef(!0),
        h = M.useRef(a),
        f = yh(() => new Map),
        [m, _] = M.useState(a),
        [I, R] = M.useState(a);
    Hg(() => {
        c.current = !1, h.current = a;
        for (let v = 0; v < I.length; v++) {
            const T = Gl(I[v]);
            u.includes(T) ? f.delete(T) : f.get(T) !== !0 && f.set(T, !1)
        }
    }, [I, u.length, u.join("-")]);
    const k = [];
    if (a !== m) {
        let v = [...a];
        for (let T = 0; T < I.length; T++) {
            const x = I[T],
                O = Gl(x);
            u.includes(O) || (v.splice(T, 0, x), k.push(x))
        }
        o === "wait" && k.length && (v = k), R(Zw(v)), _(a);
        return
    }
    const {
        forceRender: w
    } = M.useContext($g);
    return D.jsx(D.Fragment, {
        children: I.map(v => {
            const T = Gl(v),
                x = a === I || u.includes(T),
                O = () => {
                    if (f.has(T)) f.set(T, !0);
                    else return;
                    let U = !0;
                    f.forEach(S => {
                        S || (U = !1)
                    }), U && (w == null || w(), R(h.current), i && i())
                };
            return D.jsx(_B, {
                isPresent: x,
                initial: !c.current || r ? void 0 : !1,
                custom: x ? void 0 : n,
                presenceAffectsLayout: s,
                mode: o,
                onExitComplete: x ? void 0 : O,
                children: v
            }, T)
        })
    })
};

function EB(t) {
    t.values.forEach(e => e.stop())
}

function Ip(t, e) {
    [...e].reverse().forEach(r => {
        const i = t.getVariant(r);
        i && jg(t, i), t.variantChildren && t.variantChildren.forEach(s => {
            Ip(s, e)
        })
    })
}

function IB(t, e) {
    if (Array.isArray(e)) return Ip(t, e);
    if (typeof e == "string") return Ip(t, [e]);
    jg(t, e)
}

function SB() {
    const t = new Set,
        e = {
            subscribe(n) {
                return t.add(n), () => void t.delete(n)
            },
            start(n, r) {
                const i = [];
                return t.forEach(s => {
                    i.push(tP(s, n, {
                        transitionOverride: r
                    }))
                }), Promise.all(i)
            },
            set(n) {
                return t.forEach(r => {
                    IB(r, n)
                })
            },
            stop() {
                t.forEach(n => {
                    EB(n)
                })
            },
            mount() {
                return () => {
                    e.stop()
                }
            }
        };
    return e
}

function AB() {
    const t = yh(SB);
    return Hg(t.mount, []), t
}
const $P = AB,
    PB = ({
        isDarkMode: t,
        isIOS: e,
        handleInstallClick: n,
        onClose: r
    }) => D.jsxs(yn.div, {
        initial: {
            y: 50,
            opacity: 0
        },
        animate: {
            y: 0,
            opacity: 1
        },
        className: "install-prompt position-fixed bottom-0 start-50 translate-middle-x mb-4 px-4 py-3 rounded-4 d-flex align-items-center gap-3",
        style: {
            background: t ? "#2d2d2d" : "white",
            boxShadow: "0 4px 20px rgba(0,0,0,0.15)",
            maxWidth: "90%",
            width: "400px",
            zIndex: 1e3
        },
        children: [D.jsxs("div", {
            className: "flex-grow-1",
            children: [D.jsx("p", {
                className: "mb-1 fw-bold",
                style: {
                    color: t ? "white" : "#2c3e50"
                },
                children: "Install Qayyima App"
            }), D.jsx("p", {
                className: "mb-0 small",
                style: {
                    color: t ? "#ccc" : "#666"
                },
                children: e ? 'Tap the share button and select "Add to Home Screen"' : "Install our app for a better experience"
            })]
        }), !e && D.jsx("button", {
            className: "btn fw-bold px-3 py-2",
            onClick: n,
            style: {
                background: t ? "white" : "#2c3e50",
                color: t ? "#2c3e50" : "white",
                border: "none",
                whiteSpace: "nowrap"
            },
            children: "Install"
        }), D.jsx("button", {
            className: "btn-close position-absolute top-0 end-0 mt-2 me-2",
            onClick: r,
            style: {
                opacity: .5,
                transform: "scale(0.8)"
            }
        })]
    }),
    RB = ({
        isDarkMode: t
    }) => {
        const [e, n] = M.useState([]), [r, i] = M.useState(!1), [s, o] = M.useState(new Set);
        M.useEffect(() => {
            const h = localStorage.getItem("readNotifications");
            h && o(new Set(JSON.parse(h)))
        }, []);
        const a = async () => {
            try {
                const h = C1(_1(Q2, "notifications"), dL("timestamp", "desc"), fL(10)),
                    m = (await D1(h)).docs.map(_ => {
                        var I;
                        return {
                            id: _.id,
                            ..._.data(),
                            timestamp: (I = _.data().timestamp) == null ? void 0 : I.toDate()
                        }
                    });
                n(m)
            } catch (h) {
                console.error("Error fetching notifications:", h)
            }
        };
        M.useEffect(() => {
            a()
        }, []);
        const u = () => {
                const h = e.map(m => m.id),
                    f = new Set([...s, ...h]);
                o(f), localStorage.setItem("readNotifications", JSON.stringify([...f]))
            },
            c = e.filter(h => !s.has(h.id)).length;
        return D.jsxs(D.Fragment, {
            children: [D.jsxs("button", {
                className: "notification-btn",
                onClick: () => {
                    i(!r), r || u()
                },
                style: {
                    color: t ? "white" : "#2c3e50",
                    position: "relative",
                    background: "none",
                    border: "none",
                    padding: "8px"
                },
                children: [D.jsx("i", {
                    className: "bi bi-bell-fill fs-5"
                }), c > 0 && D.jsx("span", {
                    className: "position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger",
                    children: c
                })]
            }), D.jsx(TB, {
                children: r && D.jsx(yn.div, {
                    initial: {
                        opacity: 0,
                        y: -20
                    },
                    animate: {
                        opacity: 1,
                        y: 0
                    },
                    exit: {
                        opacity: 0,
                        y: -20
                    },
                    className: "notification-panel",
                    style: {
                        background: t ? "#2d2d2d" : "white",
                        borderRadius: "8px",
                        boxShadow: "0 4px 20px rgba(0,0,0,0.15)",
                        zIndex: 1e3
                    },
                    children: D.jsxs("div", {
                        className: "p-3",
                        children: [D.jsxs("div", {
                            className: "d-flex justify-content-between align-items-center mb-2",
                            children: [D.jsx("h6", {
                                className: t ? "text-light" : "text-dark",
                                children: "Notifications"
                            }), D.jsx("button", {
                                onClick: () => i(!1),
                                className: "btn-close",
                                style: {
                                    filter: t ? "invert(1)" : "none"
                                },
                                "aria-label": "Close notifications"
                            })]
                        }), e.length === 0 ? D.jsx("p", {
                            className: "text-muted small mb-0",
                            children: "No notifications yet"
                        }) : e.map(h => D.jsxs("div", {
                            className: "notification-item p-2 mb-2 rounded",
                            style: {
                                background: t ? "#1f1f1f" : "#f8f9fa"
                            },
                            children: [D.jsx("h6", {
                                className: `mb-1 ${t?"text-light":"text-dark"}`,
                                children: h.title
                            }), D.jsx("p", {
                                className: "small mb-1",
                                style: {
                                    color: t ? "#ccc" : "#666"
                                },
                                children: h.body
                            })]
                        }, h.id))]
                    })
                })
            })]
        })
    },
    CB = ({
        children: t,
        showInstallPrompt: e,
        isIOS: n,
        handleInstallClick: r,
        setShowInstallPrompt: i,
        logoLight: s,
        logoDark: o
    }) => {
        const {
            isDarkMode: a
        } = Fc();
        return D.jsxs("div", {
            className: a ? "dark-mode" : "light-mode",
            children: [D.jsx("header", {
                className: "position-relative",
                style: {
                    zIndex: 1e3
                },
                children: D.jsxs("div", {
                    className: "d-flex justify-content-between align-items-center py-3",
                    style: {
                        maxWidth: "1440px",
                        margin: "0 auto",
                        padding: "0 24px",
                        gap: "1rem"
                    },
                    children: [D.jsxs("div", {
                        className: "d-flex align-items-center",
                        style: {
                            gap: "0.5rem"
                        },
                        children: [D.jsx("img", {
                            src: a ? s : o,
                            alt: "Logo",
                            style: {
                                height: "40px",
                                width: "auto"
                            }
                        }), D.jsx("p", {
                            className: "mb-0 text-uppercase",
                            style: {
                                letterSpacing: "0.5px",
                                fontSize: "0.55rem",
                                color: a ? "#fff" : "#2c3e50",
                                whiteSpace: "nowrap"
                            },
                            children: "Student Journey | Learn Islam"
                        })]
                    }), D.jsxs("div", {
                        className: "d-flex align-items-center",
                        style: {
                            gap: "0.5rem"
                        },
                        children: [D.jsxs("div", {
                            className: "d-none d-md-flex align-items-center",
                            style: {
                                gap: "0.5rem"
                            },
                            children: [D.jsx(Y2, {}), D.jsx(dx, {})]
                        }), D.jsx(RB, {
                            isDarkMode: a
                        }), D.jsx(X2, {})]
                    })]
                })
            }), D.jsxs("div", {
                className: "container my-4",
                children: [e && D.jsx(PB, {
                    isDarkMode: a,
                    isIOS: n,
                    handleInstallClick: r,
                    onClose: () => i(!1)
                }), t]
            })]
        })
    },
    kB = ({
        course: t,
        index: e,
        isDarkMode: n,
        onVideoSelect: r
    }) => {
        const {
            trackEvent: i
        } = to(), s = () => {
            i("video_play", {
                course_title: t.title,
                course_instructor: t.instructor,
                course_index: e,
                video_link: t.link
            }), r(t.link)
        };
        return D.jsx("div", {
            className: "course-card card h-100",
            style: {
                background: n ? "#1e1e1e" : "linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%)",
                border: n ? "1px solid #333" : "1px solid #dee2e6",
                boxShadow: n ? "0 2px 15px rgba(0,0,0,0.2)" : "0 2px 15px rgba(0,0,0,0.05)"
            },
            children: D.jsx("div", {
                className: "card-body p-3",
                children: D.jsxs("div", {
                    className: "d-flex flex-column align-items-center gap-3",
                    children: [D.jsx("img", {
                        src: t.imageUrl,
                        alt: t.title,
                        className: "rounded w-100",
                        style: {
                            aspectRatio: "16/9",
                            width: "100%",
                            objectFit: "cover",
                            objectPosition: "center"
                        }
                    }), D.jsx("div", {
                        className: "text-center w-100",
                        children: D.jsxs("div", {
                            className: "d-flex align-items-center mb-2 gap-2",
                            children: [D.jsx("span", {
                                className: `${n?"bg-light text-dark":"bg-dark text-white"} rounded-circle d-inline-flex align-items-center justify-content-center mx-3`,
                                style: {
                                    width: "35px",
                                    height: "35px",
                                    minWidth: "35px"
                                },
                                children: D.jsx("span", {
                                    className: "fw-bold",
                                    children: e + 1
                                })
                            }), D.jsxs("div", {
                                className: "text-start",
                                children: [D.jsx("h5", {
                                    className: `card-title mb-1 fw-bold ${n?"text-white":"text-dark"}`,
                                    children: t.title
                                }), D.jsxs("p", {
                                    className: `card-text mb-0 ${n?"text-light":"text-secondary"}`,
                                    children: ["By ", t.instructor]
                                }), D.jsx("p", {
                                    className: `card-text small mb-0 ${n?"text-light opacity-75":"text-muted"}`,
                                    children: t.description
                                })]
                            })]
                        })
                    }), D.jsx("button", {
                        className: "btn fw-bold px-4 py-3",
                        style: {
                            borderRadius: "50px",
                            background: n ? "white" : "linear-gradient(135deg, #2c3e50 0%, #1a252f 100%)",
                            border: "none",
                            color: n ? "#1e1e1e" : "white",
                            boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
                            transition: "all 0.3s ease"
                        },
                        onMouseOver: o => o.target.style.transform = "translateY(-2px)",
                        onMouseOut: o => o.target.style.transform = "translateY(0)",
                        onClick: s,
                        children: "START LEARNING"
                    })]
                })
            })
        })
    },
    xB = ({
        isDarkMode: t
    }) => D.jsx("div", {
        className: "card h-100",
        style: {
            background: t ? "#1e1e1e" : "linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%)",
            border: t ? "1px solid #333" : "1px solid #dee2e6",
            boxShadow: t ? "0 2px 15px rgba(0,0,0,0.2)" : "0 2px 15px rgba(0,0,0,0.05)"
        },
        children: D.jsxs("div", {
            className: "card-body p-5",
            children: [D.jsx("i", {
                className: "bi bi-clock-history fs-1 mb-3"
            }), D.jsx("h3", {
                className: `fw-bold ${t?"text-light":"text-dark"}`,
                children: "Coming Soon"
            }), D.jsx("p", {
                className: `mb-0 ${t?"text-light opacity-75":"text-muted"}`,
                children: "We're working on adding new courses for this level."
            })]
        })
    }),
    bB = ({
        isDarkMode: t
    }) => D.jsxs("div", {
        className: "text-center",
        children: [D.jsx("div", {
            className: "mb-2",
            style: {
                height: "2rem",
                width: "200px",
                background: t ? "rgba(255, 255, 255, 0.1)" : "#e9ecef",
                borderRadius: "4px",
                margin: "0 auto",
                animation: "pulse 1.5s infinite"
            }
        }), D.jsx("div", {
            style: {
                height: "1.5rem",
                width: "150px",
                background: t ? "rgba(255, 255, 255, 0.1)" : "#e9ecef",
                borderRadius: "4px",
                margin: "0 auto",
                animation: "pulse 1.5s infinite"
            }
        })]
    }),
    NB = ({
        isDarkMode: t
    }) => D.jsx("div", {
        className: "course-card card h-100",
        style: {
            background: t ? "#1e1e1e" : "linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%)",
            border: t ? "1px solid #333" : "1px solid #dee2e6",
            boxShadow: t ? "0 2px 15px rgba(0,0,0,0.2)" : "0 2px 15px rgba(0,0,0,0.05)"
        },
        children: D.jsx("div", {
            className: "card-body p-3",
            children: D.jsxs("div", {
                className: "d-flex flex-column align-items-center gap-3",
                children: [D.jsx("div", {
                    className: "w-100",
                    style: {
                        height: "150px",
                        background: t ? "rgba(255, 255, 255, 0.1)" : "#e9ecef",
                        borderRadius: "4px",
                        animation: "pulse 1.5s infinite"
                    }
                }), D.jsxs("div", {
                    className: "text-center w-100",
                    children: [D.jsx("div", {
                        style: {
                            height: "24px",
                            width: "80%",
                            background: t ? "rgba(255, 255, 255, 0.1)" : "#e9ecef",
                            borderRadius: "4px",
                            margin: "0 auto 8px",
                            animation: "pulse 1.5s infinite"
                        }
                    }), D.jsx("div", {
                        style: {
                            height: "18px",
                            width: "60%",
                            background: t ? "rgba(255, 255, 255, 0.1)" : "#e9ecef",
                            borderRadius: "4px",
                            margin: "0 auto 8px",
                            animation: "pulse 1.5s infinite"
                        }
                    }), D.jsx("div", {
                        style: {
                            height: "36px",
                            width: "40%",
                            background: t ? "rgba(255, 255, 255, 0.1)" : "#e9ecef",
                            borderRadius: "50px",
                            margin: "16px auto 0",
                            animation: "pulse 1.5s infinite"
                        }
                    })]
                })]
            })
        })
    }),
    DB = ({
        isDarkMode: t,
        isLoading: e,
        activeProgram: n,
        programs: r,
        setActiveProgram: i,
        getPrevProgram: s,
        getNextProgram: o
    }) => {
        var _, I;
        const a = r ? Object.keys(r) : [],
            u = $P(),
            {
                trackEvent: c
            } = to(),
            h = (R, k) => {
                var w;
                R !== n && (c("program_change", {
                    from_program: n,
                    to_program: R,
                    program_title: (w = r == null ? void 0 : r[R]) == null ? void 0 : w.pTitle,
                    method: k
                }), i(R))
            },
            f = async (R, k) => {
                if (k.offset.x > 50 && !e) {
                    const v = a[a.indexOf(n) - 1];
                    v && h(v, "swipe")
                } else if (k.offset.x < -50 && !e) {
                    const v = a[a.indexOf(n) + 1];
                    v && h(v, "swipe")
                }
                await u.start({
                    x: 0
                })
            },
            m = R => {
                h(R, "dot_navigation")
            };
        return D.jsxs("header", {
            className: "mb-5",
            style: {
                background: t ? "linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%)" : "linear-gradient(135deg, #2c3e50 0%, #1a252f 100%)",
                padding: "2rem",
                borderRadius: "10px",
                color: "white",
                boxShadow: t ? "0 4px 20px rgba(0,0,0,0.3)" : "0 4px 20px rgba(0,0,0,0.1)"
            },
            children: [D.jsxs("div", {
                className: "d-flex justify-content-between align-items-center",
                children: [D.jsx("button", {
                    className: "btn text-white",
                    onClick: s,
                    disabled: e,
                    style: {
                        visibility: e ? "hidden" : "visible"
                    },
                    children: D.jsx("i", {
                        className: "bi bi-chevron-left fs-4"
                    })
                }), e ? D.jsx(bB, {
                    isDarkMode: t
                }) : a.length === 0 ? D.jsx(yn.div, {
                    className: "text-center",
                    children: D.jsx(yn.h1, {
                        initial: {
                            opacity: 0,
                            y: 20
                        },
                        animate: {
                            opacity: 1,
                            y: 0
                        },
                        transition: {
                            duration: .5
                        },
                        className: "m-0",
                        style: {
                            fontSize: "1.75rem"
                        },
                        children: "Programs Coming Soon"
                    })
                }) : D.jsxs(yn.div, {
                    className: "text-center",
                    drag: "x",
                    dragConstraints: {
                        left: 0,
                        right: 0
                    },
                    onDragEnd: f,
                    animate: u,
                    children: [D.jsx(yn.h1, {
                        initial: {
                            opacity: 0,
                            y: 20
                        },
                        animate: {
                            opacity: 1,
                            y: 0
                        },
                        transition: {
                            duration: .5
                        },
                        className: "m-0",
                        style: {
                            fontSize: "1.75rem"
                        },
                        children: (_ = r == null ? void 0 : r[n]) == null ? void 0 : _.pTitle
                    }, `title-${n}`), D.jsx(yn.p, {
                        initial: {
                            opacity: 0
                        },
                        animate: {
                            opacity: .8
                        },
                        transition: {
                            duration: .5,
                            delay: .2
                        },
                        className: "m-0 mt-2",
                        style: {
                            fontSize: "1.1rem"
                        },
                        children: (I = r == null ? void 0 : r[n]) == null ? void 0 : I.pDescription
                    }, `desc-${n}`)]
                }), D.jsx("button", {
                    className: "btn text-white",
                    onClick: o,
                    disabled: e,
                    style: {
                        visibility: e ? "hidden" : "visible"
                    },
                    children: D.jsx("i", {
                        className: "bi bi-chevron-right fs-4"
                    })
                })]
            }), D.jsx("div", {
                className: "d-flex justify-content-center gap-2 mt-3",
                children: a.map(R => D.jsx("button", {
                    onClick: () => m(R),
                    className: "btn p-0",
                    style: {
                        width: "10px",
                        height: "10px"
                    },
                    children: D.jsx("div", {
                        style: {
                            width: "100%",
                            height: "100%",
                            borderRadius: "50%",
                            backgroundColor: "white",
                            opacity: n === R ? 1 : .5,
                            transition: "opacity 0.3s ease"
                        }
                    })
                }, R))
            }), D.jsx("hr", {
                className: "mx-auto",
                style: {
                    width: "200px",
                    height: "2px",
                    opacity: t ? "0.3" : "0.5",
                    backgroundColor: "white"
                }
            })]
        })
    },
    bn = ["basic", "intermediate", "advanced"],
    VB = ({
        isDarkMode: t,
        activeLevel: e,
        setActiveLevel: n
    }) => {
        const r = $P(),
            {
                trackEvent: i
            } = to(),
            s = c => {
                i("level_change", {
                    from_level: e,
                    to_level: c,
                    method: "button_click"
                }), n(c)
            },
            o = () => {
                const c = bn.indexOf(e);
                c > 0 && s(bn[c - 1])
            },
            a = () => {
                const c = bn.indexOf(e);
                c < bn.length - 1 && s(bn[c + 1])
            },
            u = async (c, h) => {
                h.offset.x > 50 && e !== "basic" ? s(bn[bn.indexOf(e) - 1]) : h.offset.x < -50 && e !== "advanced" && s(bn[bn.indexOf(e) + 1]), await r.start({
                    x: 0
                })
            };
        return D.jsxs("div", {
            className: "text-center mb-4 d-flex justify-content-center align-items-center gap-3",
            children: [D.jsx("button", {
                className: `btn ${t?"btn-outline-light":"btn-outline-dark"} px-3`,
                onClick: o,
                disabled: e === "basic",
                children: D.jsx("i", {
                    className: "bi bi-chevron-left"
                })
            }), D.jsx(yn.button, {
                drag: "x",
                dragConstraints: {
                    left: 0,
                    right: 0
                },
                onDragEnd: u,
                animate: r,
                className: "btn fw-bold px-4 px-md-5 text-uppercase",
                style: {
                    minWidth: "180px",
                    transition: "all 0.3s ease",
                    background: t ? "white" : "linear-gradient(135deg, #2c3e50 0%, #1a252f 100%)",
                    border: "none",
                    color: t ? "#1e1e1e" : "white",
                    boxShadow: t ? "0 4px 15px rgba(0,0,0,0.3)" : "0 4px 15px rgba(0,0,0,0.1)"
                },
                children: e
            }), D.jsx("button", {
                className: `btn ${t?"btn-outline-light":"btn-outline-dark"} px-3`,
                onClick: a,
                disabled: e === "advanced",
                children: D.jsx("i", {
                    className: "bi bi-chevron-right"
                })
            })]
        })
    },
    OB = ({
        isDarkMode: t,
        animationLogoDark: e,
        animationLogoLight: n
    }) => D.jsx(yn.div, {
        initial: {
            opacity: 1
        },
        exit: {
            opacity: 0
        },
        className: "splash-screen",
        style: {
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            background: t ? "#121212" : "#ffffff",
            zIndex: 9999
        },
        children: D.jsx(yn.div, {
            initial: {
                scale: 1
            },
            animate: {
                scale: 0,
                transition: {
                    duration: .5,
                    delay: 1.5
                }
            },
            children: D.jsx("img", {
                src: t ? n : e,
                alt: "Logo",
                style: {
                    height: window.innerWidth <= 768 ? "150px" : "300px",
                    width: "auto"
                }
            })
        })
    });
var zP = {
    exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t) {
    (function() {
        var e = {}.hasOwnProperty;

        function n() {
            for (var s = "", o = 0; o < arguments.length; o++) {
                var a = arguments[o];
                a && (s = i(s, r(a)))
            }
            return s
        }

        function r(s) {
            if (typeof s == "string" || typeof s == "number") return s;
            if (typeof s != "object") return "";
            if (Array.isArray(s)) return n.apply(null, s);
            if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) return s.toString();
            var o = "";
            for (var a in s) e.call(s, a) && s[a] && (o = i(o, a));
            return o
        }

        function i(s, o) {
            return o ? s ? s + " " + o : s + o : s
        }
        t.exports ? (n.default = n, t.exports = n) : window.classNames = n
    })()
})(zP);
var LB = zP.exports;
const Uo = Pp(LB);

function MB(t) {
    if (Array.isArray(t)) {
        for (var e = 0, n = Array(t.length); e < t.length; e++) n[e] = t[e];
        return n
    } else return Array.from(t)
}
var Zg = !1;
if (typeof window < "u") {
    var eT = {
        get passive() {
            Zg = !0
        }
    };
    window.addEventListener("testPassive", null, eT), window.removeEventListener("testPassive", null, eT)
}
var WP = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1),
    Pr = [],
    _c = !1,
    qP = -1,
    ia = void 0,
    sa = void 0,
    HP = function(e) {
        return Pr.some(function(n) {
            return !!(n.options.allowTouchMove && n.options.allowTouchMove(e))
        })
    },
    wc = function(e) {
        var n = e || window.event;
        return HP(n.target) || n.touches.length > 1 ? !0 : (n.preventDefault && n.preventDefault(), !1)
    },
    FB = function(e) {
        if (sa === void 0) {
            var n = !!e && e.reserveScrollBarGap === !0,
                r = window.innerWidth - document.documentElement.clientWidth;
            n && r > 0 && (sa = document.body.style.paddingRight, document.body.style.paddingRight = r + "px")
        }
        ia === void 0 && (ia = document.body.style.overflow, document.body.style.overflow = "hidden")
    },
    UB = function() {
        sa !== void 0 && (document.body.style.paddingRight = sa, sa = void 0), ia !== void 0 && (document.body.style.overflow = ia, ia = void 0)
    },
    jB = function(e) {
        return e ? e.scrollHeight - e.scrollTop <= e.clientHeight : !1
    },
    BB = function(e, n) {
        var r = e.targetTouches[0].clientY - qP;
        return HP(e.target) ? !1 : n && n.scrollTop === 0 && r > 0 || jB(n) && r < 0 ? wc(e) : (e.stopPropagation(), !0)
    },
    $B = function(e, n) {
        if (!e) {
            console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
            return
        }
        if (!Pr.some(function(i) {
                return i.targetElement === e
            })) {
            var r = {
                targetElement: e,
                options: n || {}
            };
            Pr = [].concat(MB(Pr), [r]), WP ? (e.ontouchstart = function(i) {
                i.targetTouches.length === 1 && (qP = i.targetTouches[0].clientY)
            }, e.ontouchmove = function(i) {
                i.targetTouches.length === 1 && BB(i, e)
            }, _c || (document.addEventListener("touchmove", wc, Zg ? {
                passive: !1
            } : void 0), _c = !0)) : FB(n)
        }
    },
    zB = function(e) {
        if (!e) {
            console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");
            return
        }
        Pr = Pr.filter(function(n) {
            return n.targetElement !== e
        }), WP ? (e.ontouchstart = null, e.ontouchmove = null, _c && Pr.length === 0 && (document.removeEventListener("touchmove", wc, Zg ? {
            passive: !1
        } : void 0), _c = !1)) : Pr.length || UB()
    };

function WB(t = null) {
    let [e, n] = It.useState(t);
    const {
        current: r
    } = It.useRef({
        current: e
    });
    return Object.defineProperty(r, "current", {
        get: () => e,
        set: i => {
            Object.is(e, i) || (e = i, n(i))
        }
    }), r
}

function qB(t, e = {
    isStateful: !0
}) {
    const n = WB(null),
        r = M.useRef(null),
        i = e.isStateful ? n : r;
    return It.useEffect(() => {
        !t || (typeof t == "function" ? t(i.current) : t.current = i.current)
    }), i
}

function Tc() {
    return Tc = Object.assign || function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }, Tc.apply(this, arguments)
}
var HB = function(e) {
        var n = e.classes,
            r = e.classNames,
            i = e.styles,
            s = e.id,
            o = e.closeIcon,
            a = e.onClick;
        return It.createElement("button", {
            id: s,
            className: Uo(n.closeButton, r == null ? void 0 : r.closeButton),
            style: i == null ? void 0 : i.closeButton,
            onClick: a,
            "data-testid": "close-button"
        }, o || It.createElement("svg", {
            className: r == null ? void 0 : r.closeIcon,
            style: i == null ? void 0 : i.closeIcon,
            width: 28,
            height: 28,
            viewBox: "0 0 36 36",
            "data-testid": "close-icon"
        }, It.createElement("path", {
            d: "M28.5 9.62L26.38 7.5 18 15.88 9.62 7.5 7.5 9.62 15.88 18 7.5 26.38l2.12 2.12L18 20.12l8.38 8.38 2.12-2.12L20.12 18z"
        })))
    },
    wu = typeof window < "u",
    KP = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'];

function KB(t) {
    return t.offsetParent === null || getComputedStyle(t).visibility === "hidden"
}

function GB(t, e) {
    for (var n = 0; n < t.length; n++)
        if (t[n].checked && t[n].form === e) return t[n]
}

function QB(t) {
    if (t.tagName !== "INPUT" || t.type !== "radio" || !t.name) return !0;
    var e = t.form || t.ownerDocument,
        n = e.querySelectorAll('input[type="radio"][name="' + t.name + '"]'),
        r = GB(n, t.form);
    return r === t || r === void 0 && n[0] === t
}

function GP(t) {
    for (var e = document.activeElement, n = t.querySelectorAll(KP.join(",")), r = [], i = 0; i < n.length; i++) {
        var s = n[i];
        (e === s || !s.disabled && XB(s) > -1 && !KB(s) && QB(s)) && r.push(s)
    }
    return r
}

function YB(t, e) {
    if (!(!t || t.key !== "Tab")) {
        if (!e || !e.contains) return process, !1;
        if (!e.contains(t.target)) return !1;
        var n = GP(e),
            r = n[0],
            i = n[n.length - 1];
        return t.shiftKey && t.target === r ? (i.focus(), t.preventDefault(), !0) : !t.shiftKey && t.target === i ? (r.focus(), t.preventDefault(), !0) : !1
    }
}

function XB(t) {
    var e = parseInt(t.getAttribute("tabindex"), 10);
    return isNaN(e) ? JB(t) ? 0 : t.tabIndex : e
}

function JB(t) {
    return t.getAttribute("contentEditable")
}
var ZB = function(e) {
        var n = e.container,
            r = e.initialFocusRef,
            i = M.useRef();
        return M.useEffect(function() {
            var s = function(c) {
                n != null && n.current && YB(c, n.current)
            };
            if (wu && document.addEventListener("keydown", s), wu && (n != null && n.current)) {
                var o = function() {
                    KP.findIndex(function(c) {
                        var h;
                        return (h = document.activeElement) == null ? void 0 : h.matches(c)
                    }) !== -1 && (i.current = document.activeElement)
                };
                if (r) o(), requestAnimationFrame(function() {
                    var u;
                    (u = r.current) == null || u.focus()
                });
                else {
                    var a = GP(n.current);
                    a[0] && (o(), a[0].focus())
                }
            }
            return function() {
                if (wu) {
                    var u;
                    document.removeEventListener("keydown", s), (u = i.current) == null || u.focus()
                }
            }
        }, [n, r]), null
    },
    Gi = [],
    Sp = {
        add: function(e) {
            Gi.push(e)
        },
        remove: function(e) {
            Gi = Gi.filter(function(n) {
                return n !== e
            })
        },
        isTopModal: function(e) {
            return !!Gi.length && Gi[Gi.length - 1] === e
        }
    };

function e5(t, e) {
    M.useEffect(function() {
        return e && Sp.add(t),
            function() {
                Sp.remove(t)
            }
    }, [e, t])
}
var t5 = function(e, n, r, i, s) {
        var o = M.useRef(null);
        M.useEffect(function() {
            return n && e.current && i && (o.current = e.current, $B(e.current, {
                    reserveScrollBarGap: s
                })),
                function() {
                    o.current && (zB(o.current), o.current = null)
                }
        }, [n, r, e, i, s])
    },
    pn = {
        root: "react-responsive-modal-root",
        overlay: "react-responsive-modal-overlay",
        overlayAnimationIn: "react-responsive-modal-overlay-in",
        overlayAnimationOut: "react-responsive-modal-overlay-out",
        modalContainer: "react-responsive-modal-container",
        modalContainerCenter: "react-responsive-modal-containerCenter",
        modal: "react-responsive-modal-modal",
        modalAnimationIn: "react-responsive-modal-modal-in",
        modalAnimationOut: "react-responsive-modal-modal-out",
        closeButton: "react-responsive-modal-closeButton"
    },
    n5 = It.forwardRef(function(t, e) {
        var n, r, i, s, o = t.open,
            a = t.center,
            u = t.blockScroll,
            c = u === void 0 ? !0 : u,
            h = t.closeOnEsc,
            f = h === void 0 ? !0 : h,
            m = t.closeOnOverlayClick,
            _ = m === void 0 ? !0 : m,
            I = t.container,
            R = t.showCloseIcon,
            k = R === void 0 ? !0 : R,
            w = t.closeIconId,
            v = t.closeIcon,
            T = t.focusTrapped,
            x = T === void 0 ? !0 : T,
            O = t.initialFocusRef,
            U = O === void 0 ? void 0 : O,
            S = t.animationDuration,
            g = S === void 0 ? 300 : S,
            E = t.classNames,
            A = t.styles,
            C = t.role,
            b = C === void 0 ? "dialog" : C,
            P = t.ariaDescribedby,
            ze = t.ariaLabelledby,
            dn = t.containerId,
            sr = t.modalId,
            le = t.onClose,
            B = t.onEscKeyDown,
            K = t.onOverlayClick,
            Q = t.onAnimationEnd,
            pe = t.children,
            ue = t.reserveScrollBarGap,
            _e = qB(e),
            Tt = M.useRef(null),
            Je = M.useRef(null),
            Oe = M.useRef(null);
        Oe.current === null && wu && (Oe.current = document.createElement("div"));
        var Wt = M.useState(!1),
            ni = Wt[0],
            il = Wt[1];
        e5(Tt, o), t5(Tt, o, ni, c, ue);
        var ji = function() {
                Oe.current && !I && !document.body.contains(Oe.current) && document.body.appendChild(Oe.current), document.addEventListener("keydown", $i)
            },
            Bi = function() {
                Oe.current && !I && document.body.contains(Oe.current) && document.body.removeChild(Oe.current), document.removeEventListener("keydown", $i)
            },
            $i = function(ar) {
                ar.keyCode !== 27 || !Sp.isTopModal(Tt) || (B == null || B(ar), f && le())
            };
        M.useEffect(function() {
            return function() {
                ni && Bi()
            }
        }, [ni]), M.useEffect(function() {
            o && !ni && (il(!0), ji())
        }, [o]);
        var ro = function(ar) {
                if (Je.current === null && (Je.current = !0), !Je.current) {
                    Je.current = null;
                    return
                }
                K == null || K(ar), _ && le(), Je.current = null
            },
            ri = function() {
                Je.current = !1
            },
            io = function() {
                o || il(!1), Q == null || Q()
            },
            so = I || Oe.current,
            vh = o ? (n = E == null ? void 0 : E.overlayAnimationIn) != null ? n : pn.overlayAnimationIn : (r = E == null ? void 0 : E.overlayAnimationOut) != null ? r : pn.overlayAnimationOut,
            _h = o ? (i = E == null ? void 0 : E.modalAnimationIn) != null ? i : pn.modalAnimationIn : (s = E == null ? void 0 : E.modalAnimationOut) != null ? s : pn.modalAnimationOut;
        return ni && so ? ex.createPortal(It.createElement("div", {
            className: Uo(pn.root, E == null ? void 0 : E.root),
            style: A == null ? void 0 : A.root,
            "data-testid": "root"
        }, It.createElement("div", {
            className: Uo(pn.overlay, E == null ? void 0 : E.overlay),
            "data-testid": "overlay",
            "aria-hidden": !0,
            style: Tc({
                animation: vh + " " + g + "ms"
            }, A == null ? void 0 : A.overlay)
        }), It.createElement("div", {
            ref: Tt,
            id: dn,
            className: Uo(pn.modalContainer, a && pn.modalContainerCenter, E == null ? void 0 : E.modalContainer),
            style: A == null ? void 0 : A.modalContainer,
            "data-testid": "modal-container",
            onClick: ro
        }, It.createElement("div", {
            ref: _e,
            className: Uo(pn.modal, E == null ? void 0 : E.modal),
            style: Tc({
                animation: _h + " " + g + "ms"
            }, A == null ? void 0 : A.modal),
            onMouseDown: ri,
            onMouseUp: ri,
            onClick: ri,
            onAnimationEnd: io,
            id: sr,
            role: b,
            "aria-modal": "true",
            "aria-labelledby": ze,
            "aria-describedby": P,
            "data-testid": "modal",
            tabIndex: -1
        }, x && It.createElement(ZB, {
            container: _e,
            initialFocusRef: U
        }), pe, k && It.createElement(HB, {
            classes: pn,
            classNames: E,
            styles: A,
            closeIcon: v,
            onClick: le,
            id: w
        })))), so) : null
    });
const r5 = ({
        playlistId: t,
        onClose: e
    }) => D.jsx(n5, {
        open: t !== null,
        onClose: e,
        center: !0,
        classNames: {
            modal: "customModal",
            overlay: "customOverlay"
        },
        styles: {
            modal: {
                background: "#fff",
                maxWidth: "900px",
                width: "90%",
                padding: "0"
            },
            overlay: {
                background: "rgba(0, 0, 0, 0.75)"
            }
        },
        children: D.jsx("div", {
            className: "ratio ratio-16x9",
            children: D.jsx("iframe", {
                src: `https://www.youtube.com/embed/videoseries?list=${t}`,
                title: "YouTube video player",
                allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
                allowFullScreen: !0
            })
        })
    }),
    i5 = "https://script.google.com/macros/s/AKfycbzNHxuW2zLr8ZxQvLytI2m2nVd6h251IqCAR-5THv41sdMmZv4pF7tNxYYXTRb-TDXy/exec",
    s5 = async () => {
        try {
            if (!navigator.onLine) throw new Error("No internet connection");
            const t = await fetch(i5);
            if (!t.ok) throw new Error("Network response was not ok");
            const e = await t.json(),
                n = sessionStorage.getItem("language") || "ml";
            return e.languages[n] || {}
        } catch (t) {
            throw console.error("Error fetching programs:", t), t
        }
    },
    o5 = () => {
        const [t, e] = M.useState(null), [n, r] = M.useState(!0), [i, s] = M.useState(null), o = async () => {
            try {
                r(!0);
                const a = await s5();
                e(a), s(null)
            } catch (a) {
                s(a.message)
            } finally {
                r(!1)
            }
        };
        return M.useEffect(() => (o(), window.addEventListener("languageChange", o), () => {
            window.removeEventListener("languageChange", o)
        }), []), {
            programs: t,
            isLoading: n,
            error: i
        }
    };
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const a5 = "/firebase-messaging-sw.js",
    l5 = "/firebase-cloud-messaging-push-scope",
    QP = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4",
    u5 = "https://fcmregistrations.googleapis.com/v1",
    YP = "google.c.a.c_id",
    c5 = "google.c.a.c_l",
    h5 = "google.c.a.ts",
    d5 = "google.c.a.e";
var tT;
(function(t) {
    t[t.DATA_MESSAGE = 1] = "DATA_MESSAGE", t[t.DISPLAY_NOTIFICATION = 3] = "DISPLAY_NOTIFICATION"
})(tT || (tT = {}));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
var Ma;
(function(t) {
    t.PUSH_RECEIVED = "push-received", t.NOTIFICATION_CLICKED = "notification-clicked"
})(Ma || (Ma = {}));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Dn(t) {
    const e = new Uint8Array(t);
    return btoa(String.fromCharCode(...e)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_")
}

function f5(t) {
    const e = "=".repeat((4 - t.length % 4) % 4),
        n = (t + e).replace(/\-/g, "+").replace(/_/g, "/"),
        r = atob(n),
        i = new Uint8Array(r.length);
    for (let s = 0; s < r.length; ++s) i[s] = r.charCodeAt(s);
    return i
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const jd = "fcm_token_details_db",
    p5 = 5,
    nT = "fcm_token_object_Store";
async function m5(t) {
    if ("databases" in indexedDB && !(await indexedDB.databases()).map(s => s.name).includes(jd)) return null;
    let e = null;
    return (await Bc(jd, p5, {
        upgrade: async (r, i, s, o) => {
            var a;
            if (i < 2 || !r.objectStoreNames.contains(nT)) return;
            const u = o.objectStore(nT),
                c = await u.index("fcmSenderId").get(t);
            if (await u.clear(), !!c) {
                if (i === 2) {
                    const h = c;
                    if (!h.auth || !h.p256dh || !h.endpoint) return;
                    e = {
                        token: h.fcmToken,
                        createTime: (a = h.createTime) !== null && a !== void 0 ? a : Date.now(),
                        subscriptionOptions: {
                            auth: h.auth,
                            p256dh: h.p256dh,
                            endpoint: h.endpoint,
                            swScope: h.swScope,
                            vapidKey: typeof h.vapidKey == "string" ? h.vapidKey : Dn(h.vapidKey)
                        }
                    }
                } else if (i === 3) {
                    const h = c;
                    e = {
                        token: h.fcmToken,
                        createTime: h.createTime,
                        subscriptionOptions: {
                            auth: Dn(h.auth),
                            p256dh: Dn(h.p256dh),
                            endpoint: h.endpoint,
                            swScope: h.swScope,
                            vapidKey: Dn(h.vapidKey)
                        }
                    }
                } else if (i === 4) {
                    const h = c;
                    e = {
                        token: h.fcmToken,
                        createTime: h.createTime,
                        subscriptionOptions: {
                            auth: Dn(h.auth),
                            p256dh: Dn(h.p256dh),
                            endpoint: h.endpoint,
                            swScope: h.swScope,
                            vapidKey: Dn(h.vapidKey)
                        }
                    }
                }
            }
        }
    })).close(), await fd(jd), await fd("fcm_vapid_details_db"), await fd("undefined"), g5(e) ? e : null
}

function g5(t) {
    if (!t || !t.subscriptionOptions) return !1;
    const {
        subscriptionOptions: e
    } = t;
    return typeof t.createTime == "number" && t.createTime > 0 && typeof t.token == "string" && t.token.length > 0 && typeof e.auth == "string" && e.auth.length > 0 && typeof e.p256dh == "string" && e.p256dh.length > 0 && typeof e.endpoint == "string" && e.endpoint.length > 0 && typeof e.swScope == "string" && e.swScope.length > 0 && typeof e.vapidKey == "string" && e.vapidKey.length > 0
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const y5 = "firebase-messaging-database",
    v5 = 1,
    Fa = "firebase-messaging-store";
let Bd = null;

function XP() {
    return Bd || (Bd = Bc(y5, v5, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    t.createObjectStore(Fa)
            }
        }
    })), Bd
}
async function _5(t) {
    const e = JP(t),
        r = await (await XP()).transaction(Fa).objectStore(Fa).get(e);
    if (r) return r; {
        const i = await m5(t.appConfig.senderId);
        if (i) return await ey(t, i), i
    }
}
async function ey(t, e) {
    const n = JP(t),
        i = (await XP()).transaction(Fa, "readwrite");
    return await i.objectStore(Fa).put(e, n), await i.done, e
}

function JP({
    appConfig: t
}) {
    return t.appId
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const w5 = {
        "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
        "only-available-in-window": "This method is available in a Window context.",
        "only-available-in-sw": "This method is available in a service worker context.",
        "permission-default": "The notification permission was not granted and dismissed instead.",
        "permission-blocked": "The notification permission was not granted and blocked instead.",
        "unsupported-browser": "This browser doesn't support the API's required to use the Firebase SDK.",
        "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
        "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}",
        "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}",
        "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.",
        "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
        "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}",
        "token-update-no-token": "FCM returned no token when updating the user to push.",
        "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
        "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
        "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.",
        "invalid-vapid-key": "The public VAPID key must be a string.",
        "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
    },
    dt = new Xr("messaging", "Messaging", w5);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function T5(t, e) {
    const n = await ny(t),
        r = ZP(e),
        i = {
            method: "POST",
            headers: n,
            body: JSON.stringify(r)
        };
    let s;
    try {
        s = await (await fetch(ty(t.appConfig), i)).json()
    } catch (o) {
        throw dt.create("token-subscribe-failed", {
            errorInfo: o == null ? void 0 : o.toString()
        })
    }
    if (s.error) {
        const o = s.error.message;
        throw dt.create("token-subscribe-failed", {
            errorInfo: o
        })
    }
    if (!s.token) throw dt.create("token-subscribe-no-token");
    return s.token
}
async function E5(t, e) {
    const n = await ny(t),
        r = ZP(e.subscriptionOptions),
        i = {
            method: "PATCH",
            headers: n,
            body: JSON.stringify(r)
        };
    let s;
    try {
        s = await (await fetch(`${ty(t.appConfig)}/${e.token}`, i)).json()
    } catch (o) {
        throw dt.create("token-update-failed", {
            errorInfo: o == null ? void 0 : o.toString()
        })
    }
    if (s.error) {
        const o = s.error.message;
        throw dt.create("token-update-failed", {
            errorInfo: o
        })
    }
    if (!s.token) throw dt.create("token-update-no-token");
    return s.token
}
async function I5(t, e) {
    const r = {
        method: "DELETE",
        headers: await ny(t)
    };
    try {
        const s = await (await fetch(`${ty(t.appConfig)}/${e}`, r)).json();
        if (s.error) {
            const o = s.error.message;
            throw dt.create("token-unsubscribe-failed", {
                errorInfo: o
            })
        }
    } catch (i) {
        throw dt.create("token-unsubscribe-failed", {
            errorInfo: i == null ? void 0 : i.toString()
        })
    }
}

function ty({
    projectId: t
}) {
    return `${u5}/projects/${t}/registrations`
}
async function ny({
    appConfig: t,
    installations: e
}) {
    const n = await e.getToken();
    return new Headers({
        "Content-Type": "application/json",
        Accept: "application/json",
        "x-goog-api-key": t.apiKey,
        "x-goog-firebase-installations-auth": `FIS ${n}`
    })
}

function ZP({
    p256dh: t,
    auth: e,
    endpoint: n,
    vapidKey: r
}) {
    const i = {
        web: {
            endpoint: n,
            auth: e,
            p256dh: t
        }
    };
    return r !== QP && (i.web.applicationPubKey = r), i
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const S5 = 7 * 24 * 60 * 60 * 1e3;
async function A5(t) {
    const e = await R5(t.swRegistration, t.vapidKey),
        n = {
            vapidKey: t.vapidKey,
            swScope: t.swRegistration.scope,
            endpoint: e.endpoint,
            auth: Dn(e.getKey("auth")),
            p256dh: Dn(e.getKey("p256dh"))
        },
        r = await _5(t.firebaseDependencies);
    if (r) {
        if (C5(r.subscriptionOptions, n)) return Date.now() >= r.createTime + S5 ? P5(t, {
            token: r.token,
            createTime: Date.now(),
            subscriptionOptions: n
        }) : r.token;
        try {
            await I5(t.firebaseDependencies, r.token)
        } catch (i) {
            console.warn(i)
        }
        return rT(t.firebaseDependencies, n)
    } else return rT(t.firebaseDependencies, n)
}
async function P5(t, e) {
    try {
        const n = await E5(t.firebaseDependencies, e),
            r = Object.assign(Object.assign({}, e), {
                token: n,
                createTime: Date.now()
            });
        return await ey(t.firebaseDependencies, r), n
    } catch (n) {
        throw n
    }
}
async function rT(t, e) {
    const r = {
        token: await T5(t, e),
        createTime: Date.now(),
        subscriptionOptions: e
    };
    return await ey(t, r), r.token
}
async function R5(t, e) {
    const n = await t.pushManager.getSubscription();
    return n || t.pushManager.subscribe({
        userVisibleOnly: !0,
        applicationServerKey: f5(e)
    })
}

function C5(t, e) {
    const n = e.vapidKey === t.vapidKey,
        r = e.endpoint === t.endpoint,
        i = e.auth === t.auth,
        s = e.p256dh === t.p256dh;
    return n && r && i && s
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function iT(t) {
    const e = {
        from: t.from,
        collapseKey: t.collapse_key,
        messageId: t.fcmMessageId
    };
    return k5(e, t), x5(e, t), b5(e, t), e
}

function k5(t, e) {
    if (!e.notification) return;
    t.notification = {};
    const n = e.notification.title;
    n && (t.notification.title = n);
    const r = e.notification.body;
    r && (t.notification.body = r);
    const i = e.notification.image;
    i && (t.notification.image = i);
    const s = e.notification.icon;
    s && (t.notification.icon = s)
}

function x5(t, e) {
    e.data && (t.data = e.data)
}

function b5(t, e) {
    var n, r, i, s, o;
    if (!e.fcmOptions && !(!((n = e.notification) === null || n === void 0) && n.click_action)) return;
    t.fcmOptions = {};
    const a = (i = (r = e.fcmOptions) === null || r === void 0 ? void 0 : r.link) !== null && i !== void 0 ? i : (s = e.notification) === null || s === void 0 ? void 0 : s.click_action;
    a && (t.fcmOptions.link = a);
    const u = (o = e.fcmOptions) === null || o === void 0 ? void 0 : o.analytics_label;
    u && (t.fcmOptions.analyticsLabel = u)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function N5(t) {
    return typeof t == "object" && !!t && YP in t
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function D5(t) {
    if (!t || !t.options) throw $d("App Configuration Object");
    if (!t.name) throw $d("App Name");
    const e = ["projectId", "apiKey", "appId", "messagingSenderId"],
        {
            options: n
        } = t;
    for (const r of e)
        if (!n[r]) throw $d(r);
    return {
        appName: t.name,
        projectId: n.projectId,
        apiKey: n.apiKey,
        appId: n.appId,
        senderId: n.messagingSenderId
    }
}

function $d(t) {
    return dt.create("missing-app-config-values", {
        valueName: t
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class V5 {
    constructor(e, n, r) {
        this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1;
        const i = D5(e);
        this.firebaseDependencies = {
            app: e,
            appConfig: i,
            installations: n,
            analyticsProvider: r
        }
    }
    _delete() {
        return Promise.resolve()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function O5(t) {
    try {
        t.swRegistration = await navigator.serviceWorker.register(a5, {
            scope: l5
        }), t.swRegistration.update().catch(() => {})
    } catch (e) {
        throw dt.create("failed-service-worker-registration", {
            browserErrorMessage: e == null ? void 0 : e.message
        })
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function L5(t, e) {
    if (!e && !t.swRegistration && await O5(t), !(!e && t.swRegistration)) {
        if (!(e instanceof ServiceWorkerRegistration)) throw dt.create("invalid-sw-registration");
        t.swRegistration = e
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function M5(t, e) {
    e ? t.vapidKey = e : t.vapidKey || (t.vapidKey = QP)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function eR(t, e) {
    if (!navigator) throw dt.create("only-available-in-window");
    if (Notification.permission === "default" && await Notification.requestPermission(), Notification.permission !== "granted") throw dt.create("permission-blocked");
    return await M5(t, e == null ? void 0 : e.vapidKey), await L5(t, e == null ? void 0 : e.serviceWorkerRegistration), A5(t)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function F5(t, e, n) {
    const r = U5(e);
    (await t.firebaseDependencies.analyticsProvider.get()).logEvent(r, {
        message_id: n[YP],
        message_name: n[c5],
        message_time: n[h5],
        message_device_time: Math.floor(Date.now() / 1e3)
    })
}

function U5(t) {
    switch (t) {
        case Ma.NOTIFICATION_CLICKED:
            return "notification_open";
        case Ma.PUSH_RECEIVED:
            return "notification_foreground";
        default:
            throw new Error
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function j5(t, e) {
    const n = e.data;
    if (!n.isFirebaseMessaging) return;
    t.onMessageHandler && n.messageType === Ma.PUSH_RECEIVED && (typeof t.onMessageHandler == "function" ? t.onMessageHandler(iT(n)) : t.onMessageHandler.next(iT(n)));
    const r = n.data;
    N5(r) && r[d5] === "1" && await F5(t, n.messageType, r)
}
const sT = "@firebase/messaging",
    oT = "0.12.14";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const B5 = t => {
        const e = new V5(t.getProvider("app").getImmediate(), t.getProvider("installations-internal").getImmediate(), t.getProvider("analytics-internal"));
        return navigator.serviceWorker.addEventListener("message", n => j5(e, n)), e
    },
    $5 = t => {
        const e = t.getProvider("messaging").getImmediate();
        return {
            getToken: r => eR(e, r)
        }
    };

function z5() {
    jt(new Nt("messaging", B5, "PUBLIC")), jt(new Nt("messaging-internal", $5, "PRIVATE")), ct(sT, oT), ct(sT, oT, "esm2017")
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function W5() {
    try {
        await Em()
    } catch {
        return !1
    }
    return typeof window < "u" && Tm() && NI() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey")
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function q5(t, e) {
    if (!navigator) throw dt.create("only-available-in-window");
    return t.onMessageHandler = e, () => {
        t.onMessageHandler = null
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function H5(t = qa()) {
    return W5().then(e => {
        if (!e) throw dt.create("unsupported-browser")
    }, e => {
        throw dt.create("indexed-db-unsupported")
    }), ir(Ce(t), "messaging").getImmediate()
}
async function K5(t, e) {
    return t = Ce(t), eR(t, e)
}

function G5(t, e) {
    return t = Ce(t), q5(t, e)
}
z5();
const tR = H5(eo),
    Ap = w1(eo),
    Q5 = () => {
        if (!("Notification" in window)) throw new Error("This browser does not support notifications")
    },
    Y5 = async () => {
        try {
            if (Q5(), Notification.permission === "denied") throw new Error("Notification permission was denied");
            const t = await navigator.serviceWorker.ready;
            if (!t) throw new Error("No service worker registration found");
            if (await Notification.requestPermission() === "granted") try {
                const n = await K5(tR, {
                    vapidKey: "BEZUorAC9EgRwnF4ykMTQJ4_Ni9Jig1NZGKvYFZtnF9NGJ8USFIJKtGjSfk6ssBQpNdUDMk431nZuk9ZYnMP-ms",
                    serviceWorkerRegistration: t
                });
                if (n) return await X5(n), n;
                throw new Error("No registration token available")
            } catch (n) {
                throw console.error("Error getting token:", n), n
            }
            throw new Error("Notification permission denied")
        } catch (t) {
            throw console.error("Notification permission error:", t), t
        }
    },
    X5 = async t => {
        try {
            const e = eL(Ap, "notification_tokens", t),
                n = await yL(e),
                r = {
                    token: t,
                    platform: navigator.platform,
                    userAgent: navigator.userAgent,
                    lastActive: new Date
                };
            n.exists() || (r.createdAt = new Date), await vL(e, r, {
                merge: !0
            }), await J5()
        } catch (e) {
            throw console.error("Error saving token to Firestore:", e), e
        }
    },
    J5 = async () => {
        try {
            const t = new Date;
            t.setDate(t.getDate() - 30);
            const e = C1(_1(Ap, "notification_tokens"), hL("lastActive", "<", t)),
                n = await D1(e),
                r = TL(Ap);
            n.forEach(i => {
                r.delete(i.ref)
            }), n.empty || await r.commit()
        } catch (t) {
            console.error("Error cleaning up old tokens:", t)
        }
    },
    Z5 = () => new Promise(t => {
        G5(tR, e => {
            t(e)
        })
    }),
    e3 = () => {
        const [t, e] = M.useState(null), [n, r] = M.useState(!1), {
            trackEvent: i
        } = to();
        return M.useEffect(() => {
            (async () => {
                try {
                    const o = await Y5();
                    o && (r(!0), i("notification_permission_granted", {
                        token: o.slice(0, 10)
                    }))
                } catch (o) {
                    i("notification_permission_denied", {
                        error: o.message
                    })
                }
            })()
        }, [i]), M.useEffect(() => {
            const s = Z5().then(o => {
                var a;
                e(o), i("notification_received", {
                    title: (a = o == null ? void 0 : o.notification) == null ? void 0 : a.title
                })
            }).catch(o => {
                console.error("Failed to receive notification:", o)
            });
            return () => s
        }, [i]), {
            notification: t,
            isPermissionGranted: n
        }
    },
    t3 = () => {
        const {
            isDarkMode: t
        } = Fc(), e = ox(), [n, r] = M.useState("basic"), [i, s] = M.useState(null), [o, a] = M.useState(null), [u, c] = M.useState(!0), [h, f] = M.useState(!1), [m, _] = M.useState(!1), [I, R] = M.useState(null), {
            isPermissionGranted: k,
            requestPermission: w
        } = e3(), [v, T] = M.useState(!1), {
            programs: x,
            isLoading: O,
            error: U
        } = o5();
        to();
        const S = () => !x || !x[o] ? [] : x[o].courses.filter(E => E.level === n);
        M.useEffect(() => {
            document.body.style.backgroundColor = t ? "#121212" : "#ffffff", TI(t)
        }, [t]), M.useEffect(() => {
            const E = setTimeout(() => {
                c(!1)
            }, 2e3);
            return () => clearTimeout(E)
        }, []), M.useEffect(() => {
            _(u_()), window.addEventListener("beforeinstallprompt", E => {
                E.preventDefault(), R(E), f(!0)
            }), u_() && !window.matchMedia("(display-mode: standalone)").matches && f(!0)
        }, []);
        const g = async () => {
            if (I) {
                await I.prompt();
                const {
                    outcome: E
                } = await I.userChoice;
                E === "accepted" && f(!1), R(null)
            }
        };
        return M.useEffect(() => {
            !localStorage.getItem("notificationPrompted") && !k && T(!0)
        }, [k]), M.useEffect(() => {
            x && Object.keys(x).length > 0 && a(Object.keys(x)[0])
        }, [x]), !e || U ? D.jsx(ax, {
            isDarkMode: t
        }) : u ? D.jsx(OB, {
            isDarkMode: t,
            animationLogoDark: cx,
            animationLogoLight: hx
        }) : D.jsxs(CB, {
            showInstallPrompt: h,
            isIOS: m,
            handleInstallClick: g,
            setShowInstallPrompt: f,
            logoLight: ux,
            logoDark: lx,
            showNotificationPrompt: v,
            onNotificationAccept: async () => {
                await w(), T(!1), localStorage.setItem("notificationPrompted", "true")
            },
            onNotificationDecline: () => {
                T(!1), localStorage.setItem("notificationPrompted", "true")
            },
            children: [D.jsx(DB, {
                isDarkMode: t,
                isLoading: O,
                activeProgram: o,
                programs: x,
                setActiveProgram: a,
                getPrevProgram: () => a(nx(o, x)),
                getNextProgram: () => a(tx(o, x))
            }), D.jsx(VB, {
                isDarkMode: t,
                activeLevel: n,
                setActiveLevel: r
            }), D.jsx("div", {
                className: "course-cards-container mx-auto",
                children: O ? D.jsx(D.Fragment, {
                    children: [1, 2, 3].map(E => D.jsx(NB, {
                        isDarkMode: t
                    }, E))
                }) : S().length === 0 ? D.jsx("div", {
                    className: "col-12 text-center",
                    children: D.jsx(xB, {
                        isDarkMode: t
                    })
                }) : S().map((E, A) => D.jsx(kB, {
                    course: E,
                    index: A,
                    isDarkMode: t,
                    onVideoSelect: C => s(rx(C))
                }, E.id))
            }), D.jsx(r5, {
                playlistId: i,
                onClose: () => s(null)
            })]
        })
    };
wI(document.getElementById("root")).render(D.jsx(M.StrictMode, {
    children: D.jsx(sx, {
        children: D.jsx(t3, {})
    })
}));